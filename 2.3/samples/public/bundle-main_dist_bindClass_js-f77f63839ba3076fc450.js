(self["webpackChunk"] = self["webpackChunk"] || []).push([["main_dist_bindClass_js"],{

/***/ "../../main/dist/bindClass.js":
/*!************************************!*\
  !*** ../../main/dist/bindClass.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
MIT License

Copyright (c) 2021 Egor Nepomnyaschih

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var Class_1 = __importDefault(__webpack_require__(/*! ./Class */ "../../main/dist/Class.js"));

var ClassUpdater = /*#__PURE__*/function (_Class_1$default) {
  _inherits(ClassUpdater, _Class_1$default);

  var _super = _createSuper(ClassUpdater);

  function ClassUpdater(el, cls, property) {
    var _this;

    _classCallCheck(this, ClassUpdater);

    _this = _super.call(this);
    _this.el = el;
    _this.cls = cls;
    _this.property = property;

    _this._update();

    _this.own(property.onChange.listen(_this._update, _assertThisInitialized(_this)));

    return _this;
  }

  _createClass(ClassUpdater, [{
    key: "_update",
    value: function _update() {
      this.el.toggleClass(this.cls, !!this.property.get());
    }
  }]);

  return ClassUpdater;
}(Class_1.default);

var ClassNameUpdater = /*#__PURE__*/function (_Class_1$default2) {
  _inherits(ClassNameUpdater, _Class_1$default2);

  var _super2 = _createSuper(ClassNameUpdater);

  function ClassNameUpdater(el, property) {
    var _this2;

    _classCallCheck(this, ClassNameUpdater);

    _this2 = _super2.call(this);
    _this2.el = el;

    _this2.el.addClass(property.get());

    _this2.own(property.onChange.listen(function (_ref) {
      var value = _ref.value,
          oldValue = _ref.oldValue;

      _this2.el.removeClass(oldValue);

      _this2.el.addClass(value);
    }));

    return _this2;
  }

  return ClassNameUpdater;
}(Class_1.default);

function bindClass(el, a, b) {
  return b != null ? new ClassUpdater(el, a, b) : new ClassNameUpdater(el, a);
}

exports.default = bindClass;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9iaW5kQ2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0YsSUFBQSxPQUFBLEdBQUEsZUFBQSxDQUFBLE9BQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQTs7SUFHTSxZOzs7OztBQUNMLHdCQUFvQixFQUFwQixFQUFxRCxHQUFyRCxFQUEwRSxRQUExRSxFQUFpRztBQUFBOztBQUFBOztBQUNoRztBQURtQixVQUFBLEVBQUEsR0FBQSxFQUFBO0FBQWlDLFVBQUEsR0FBQSxHQUFBLEdBQUE7QUFBcUIsVUFBQSxRQUFBLEdBQUEsUUFBQTs7QUFFekUsVUFBSyxPQUFMOztBQUNBLFVBQUssR0FBTCxDQUFTLFFBQVEsQ0FBQyxRQUFULENBQWtCLE1BQWxCLENBQXlCLE1BQUssT0FBOUIsZ0NBQVQ7O0FBSGdHO0FBSWhHOzs7O1dBRU8sbUJBQU87QUFDZCxXQUFLLEVBQUwsQ0FBUSxXQUFSLENBQW9CLEtBQUssR0FBekIsRUFBOEIsQ0FBQyxDQUFDLEtBQUssUUFBTCxDQUFjLEdBQWQsRUFBaEM7QUFDQTs7OztFQVR5QixPQUFBLENBQUEsTzs7SUFZckIsZ0I7Ozs7O0FBQ0wsNEJBQW9CLEVBQXBCLEVBQWlELFFBQWpELEVBQTJFO0FBQUE7O0FBQUE7O0FBQzFFO0FBRG1CLFdBQUEsRUFBQSxHQUFBLEVBQUE7O0FBRW5CLFdBQUssRUFBTCxDQUFRLFFBQVIsQ0FBaUIsUUFBUSxDQUFDLEdBQVQsRUFBakI7O0FBQ0EsV0FBSyxHQUFMLENBQVMsUUFBUSxDQUFDLFFBQVQsQ0FBa0IsTUFBbEIsQ0FBeUIsZ0JBQXNCO0FBQUEsVUFBcEIsS0FBb0IsUUFBcEIsS0FBb0I7QUFBQSxVQUFiLFFBQWEsUUFBYixRQUFhOztBQUN2RCxhQUFLLEVBQUwsQ0FBUSxXQUFSLENBQW9CLFFBQXBCOztBQUNBLGFBQUssRUFBTCxDQUFRLFFBQVIsQ0FBaUIsS0FBakI7QUFDQSxLQUhRLENBQVQ7O0FBSDBFO0FBTzFFOzs7RUFSNkIsT0FBQSxDQUFBLE87O0FBMkIvQixTQUF3QixTQUF4QixDQUFrQyxFQUFsQyxFQUEyQyxDQUEzQyxFQUFtRCxDQUFuRCxFQUEwRDtBQUN6RCxTQUFRLENBQUMsSUFBSSxJQUFOLEdBQWMsSUFBSSxZQUFKLENBQWlCLEVBQWpCLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCLENBQWQsR0FBMkMsSUFBSSxnQkFBSixDQUFxQixFQUFyQixFQUF5QixDQUF6QixDQUFsRDtBQUNBOztBQUZELE9BQUEsQ0FBQSxPQUFBLEdBQUEsU0FBQSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMjEgRWdvciBOZXBvbW55YXNjaGloXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbmltcG9ydCBCaW5kYWJsZSBmcm9tICcuL0JpbmRhYmxlJztcbmltcG9ydCBDbGFzcyBmcm9tICcuL0NsYXNzJztcbmltcG9ydCBEZXN0cm95YWJsZSBmcm9tICcuL0Rlc3Ryb3lhYmxlJztcblxuY2xhc3MgQ2xhc3NVcGRhdGVyIGV4dGVuZHMgQ2xhc3Mge1xuXHRjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBDbGFzc1VwZGF0ZXJFbGVtZW50LCBwcml2YXRlIGNsczogc3RyaW5nLCBwcml2YXRlIHByb3BlcnR5OiBCaW5kYWJsZTxhbnk+KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm93bihwcm9wZXJ0eS5vbkNoYW5nZS5saXN0ZW4odGhpcy5fdXBkYXRlLCB0aGlzKSk7XG5cdH1cblxuXHRwcml2YXRlIF91cGRhdGUoKSB7XG5cdFx0dGhpcy5lbC50b2dnbGVDbGFzcyh0aGlzLmNscywgISF0aGlzLnByb3BlcnR5LmdldCgpKTtcblx0fVxufVxuXG5jbGFzcyBDbGFzc05hbWVVcGRhdGVyIGV4dGVuZHMgQ2xhc3Mge1xuXHRjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBDbGFzc05hbWVVcGRhdGVyRWxlbWVudCwgcHJvcGVydHk6IEJpbmRhYmxlPHN0cmluZz4pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuZWwuYWRkQ2xhc3MocHJvcGVydHkuZ2V0KCkpO1xuXHRcdHRoaXMub3duKHByb3BlcnR5Lm9uQ2hhbmdlLmxpc3Rlbigoe3ZhbHVlLCBvbGRWYWx1ZX0pID0+IHtcblx0XHRcdHRoaXMuZWwucmVtb3ZlQ2xhc3Mob2xkVmFsdWUpO1xuXHRcdFx0dGhpcy5lbC5hZGRDbGFzcyh2YWx1ZSk7XG5cdFx0fSkpO1xuXHR9XG59XG5cbi8qKlxuICogQmluZHMgcHJlc2VuY2Ugb2YgYSBDU1MgY2xhc3Mgb2YgYSBET00gZWxlbWVudCB0byBhIGJvb2xlYW4gYFByb3BlcnR5YC5cbiAqIEBwYXJhbSBlbCBET00gZWxlbWVudC5cbiAqIEBwYXJhbSBjbHMgQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcGFyYW0gcHJvcGVydHkgUHJvcGVydHkgdG8gYmluZCBwcmVzZW5jZSBvZiB0aGUgQ1NTIGNsYXNzIHRvLlxuICogQHJldHVybnMgQmluZGluZyBvYmplY3QuIFlvdSBtdXN0IGRlc3Ryb3kgaXQgdG8gc3RvcCB0aGUgc3luY2hyb25pemF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQ2xhc3MoZWw6IENsYXNzVXBkYXRlckVsZW1lbnQsIGNsczogc3RyaW5nLCBwcm9wZXJ0eTogQmluZGFibGU8Ym9vbGVhbj4pOiBEZXN0cm95YWJsZTtcblxuLyoqXG4gKiBCaW5kcyBuYW1lIG9mIGEgQ1NTIGNsYXNzIG9mIGEgRE9NIGVsZW1lbnQgdG8gYSBzdHJpbmcgYFByb3BlcnR5YC5cbiAqIEBwYXJhbSBlbCBET00gZWxlbWVudC5cbiAqIEBwYXJhbSBjbHMgUHJvcGVydHkgY29udGFpbmluZyBhIENTUyBjbGFzcyBuYW1lLlxuICogQHJldHVybnMgQmluZGluZyBvYmplY3QuIFlvdSBtdXN0IGRlc3Ryb3kgaXQgdG8gc3RvcCB0aGUgc3luY2hyb25pemF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQ2xhc3MoZWw6IENsYXNzTmFtZVVwZGF0ZXJFbGVtZW50LCBjbHM6IEJpbmRhYmxlPHN0cmluZz4pOiBEZXN0cm95YWJsZTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRDbGFzcyhlbDogYW55LCBhOiBhbnksIGI/OiBhbnkpOiBEZXN0cm95YWJsZSB7XG5cdHJldHVybiAoYiAhPSBudWxsKSA/IG5ldyBDbGFzc1VwZGF0ZXIoZWwsIGEsIGIpIDogbmV3IENsYXNzTmFtZVVwZGF0ZXIoZWwsIGEpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsYXNzVXBkYXRlckVsZW1lbnQge1xuXHR0b2dnbGVDbGFzcyhjbHM6IHN0cmluZywgdmFsdWU6IGJvb2xlYW4pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsYXNzTmFtZVVwZGF0ZXJFbGVtZW50IHtcblxuXHRhZGRDbGFzcyhjbHM6IHN0cmluZyk6IHZvaWQ7XG5cblx0cmVtb3ZlQ2xhc3MoY2xzOiBzdHJpbmcpOiB2b2lkO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbWFpbi9kaXN0L2JpbmRDbGFzcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMkJBQTJCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFeFgsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4sMENBQTBDLCtEQUErRCwyRUFBMkUsRUFBRSx5RUFBeUUsZUFBZSxzREFBc0QsRUFBRSxFQUFFLHVEQUF1RDs7QUFFL1gsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssZ0NBQWdDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQseURBQXlELEVBQUUsT0FBTyx1Q0FBdUMsRUFBRSxpREFBaUQsR0FBRzs7QUFFdmEsaURBQWlELDBFQUEwRSxhQUFhLEVBQUUscUNBQXFDOztBQUUvSyx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLHNDQUFzQyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDZFQUE2RSxHQUFHLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRTs7QUFFdlUsNkJBQTZCLGdHQUFnRyxnREFBZ0QsR0FBRywyQkFBMkI7O0FBRTNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLDhCQUE4QixtQkFBTyxDQUFDLHlDQUFTOztBQUUvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmLDJDQUEyQyxjQUFjLHVoTCIsImZpbGUiOiJidW5kbGUtbWFpbl9kaXN0X2JpbmRDbGFzc19qcy1mNzdmNjM4MzliYTMwNzZmYzQ1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcclxuTUlUIExpY2Vuc2VcclxuXHJcbkNvcHlyaWdodCAoYykgMjAyMSBFZ29yIE5lcG9tbnlhc2NoaWhcclxuXHJcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcblNPRlRXQVJFLlxyXG4qL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIF9faW1wb3J0RGVmYXVsdCA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBDbGFzc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0NsYXNzXCIpKTtcblxudmFyIENsYXNzVXBkYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NsYXNzXzEkZGVmYXVsdCkge1xuICBfaW5oZXJpdHMoQ2xhc3NVcGRhdGVyLCBfQ2xhc3NfMSRkZWZhdWx0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENsYXNzVXBkYXRlcik7XG5cbiAgZnVuY3Rpb24gQ2xhc3NVcGRhdGVyKGVsLCBjbHMsIHByb3BlcnR5KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsYXNzVXBkYXRlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLmVsID0gZWw7XG4gICAgX3RoaXMuY2xzID0gY2xzO1xuICAgIF90aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgICBfdGhpcy5fdXBkYXRlKCk7XG5cbiAgICBfdGhpcy5vd24ocHJvcGVydHkub25DaGFuZ2UubGlzdGVuKF90aGlzLl91cGRhdGUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2xhc3NVcGRhdGVyLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG4gICAgICB0aGlzLmVsLnRvZ2dsZUNsYXNzKHRoaXMuY2xzLCAhIXRoaXMucHJvcGVydHkuZ2V0KCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGFzc1VwZGF0ZXI7XG59KENsYXNzXzEuZGVmYXVsdCk7XG5cbnZhciBDbGFzc05hbWVVcGRhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2xhc3NfMSRkZWZhdWx0Mikge1xuICBfaW5oZXJpdHMoQ2xhc3NOYW1lVXBkYXRlciwgX0NsYXNzXzEkZGVmYXVsdDIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKENsYXNzTmFtZVVwZGF0ZXIpO1xuXG4gIGZ1bmN0aW9uIENsYXNzTmFtZVVwZGF0ZXIoZWwsIHByb3BlcnR5KSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGFzc05hbWVVcGRhdGVyKTtcblxuICAgIF90aGlzMiA9IF9zdXBlcjIuY2FsbCh0aGlzKTtcbiAgICBfdGhpczIuZWwgPSBlbDtcblxuICAgIF90aGlzMi5lbC5hZGRDbGFzcyhwcm9wZXJ0eS5nZXQoKSk7XG5cbiAgICBfdGhpczIub3duKHByb3BlcnR5Lm9uQ2hhbmdlLmxpc3RlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZSA9IF9yZWYub2xkVmFsdWU7XG5cbiAgICAgIF90aGlzMi5lbC5yZW1vdmVDbGFzcyhvbGRWYWx1ZSk7XG5cbiAgICAgIF90aGlzMi5lbC5hZGRDbGFzcyh2YWx1ZSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHJldHVybiBDbGFzc05hbWVVcGRhdGVyO1xufShDbGFzc18xLmRlZmF1bHQpO1xuXG5mdW5jdGlvbiBiaW5kQ2xhc3MoZWwsIGEsIGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCA/IG5ldyBDbGFzc1VwZGF0ZXIoZWwsIGEsIGIpIDogbmV3IENsYXNzTmFtZVVwZGF0ZXIoZWwsIGEpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBiaW5kQ2xhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OWlhVzVrUTJ4aGMzTXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk96czdPenM3T3pzN096czdPenM3T3pzN096czdPMEZCYzBKRk96czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzBGQlIwWXNTVUZCUVN4UFFVRkJMRWRCUVVFc1pVRkJRU3hEUVVGQkxFOUJRVUVzUTBGQlFTeFRRVUZCTEVOQlFVRXNRMEZCUVRzN1NVRkhUU3haT3pzN096dEJRVU5NTEhkQ1FVRnZRaXhGUVVGd1FpeEZRVUZ4UkN4SFFVRnlSQ3hGUVVFd1JTeFJRVUV4UlN4RlFVRnBSenRCUVVGQk96dEJRVUZCT3p0QlFVTm9SenRCUVVSdFFpeFZRVUZCTEVWQlFVRXNSMEZCUVN4RlFVRkJPMEZCUVdsRExGVkJRVUVzUjBGQlFTeEhRVUZCTEVkQlFVRTdRVUZCY1VJc1ZVRkJRU3hSUVVGQkxFZEJRVUVzVVVGQlFUczdRVUZGZWtVc1ZVRkJTeXhQUVVGTU96dEJRVU5CTEZWQlFVc3NSMEZCVEN4RFFVRlRMRkZCUVZFc1EwRkJReXhSUVVGVUxFTkJRV3RDTEUxQlFXeENMRU5CUVhsQ0xFMUJRVXNzVDBGQk9VSXNaME5CUVZRN08wRkJTR2RITzBGQlNXaEhPenM3TzFkQlJVOHNiVUpCUVU4N1FVRkRaQ3hYUVVGTExFVkJRVXdzUTBGQlVTeFhRVUZTTEVOQlFXOUNMRXRCUVVzc1IwRkJla0lzUlVGQk9FSXNRMEZCUXl4RFFVRkRMRXRCUVVzc1VVRkJUQ3hEUVVGakxFZEJRV1FzUlVGQmFFTTdRVUZEUVRzN096dEZRVlI1UWl4UFFVRkJMRU5CUVVFc1R6czdTVUZaY2tJc1owSTdPenM3TzBGQlEwd3NORUpCUVc5Q0xFVkJRWEJDTEVWQlFXbEVMRkZCUVdwRUxFVkJRVEpGTzBGQlFVRTdPMEZCUVVFN08wRkJRekZGTzBGQlJHMUNMRmRCUVVFc1JVRkJRU3hIUVVGQkxFVkJRVUU3TzBGQlJXNUNMRmRCUVVzc1JVRkJUQ3hEUVVGUkxGRkJRVklzUTBGQmFVSXNVVUZCVVN4RFFVRkRMRWRCUVZRc1JVRkJha0k3TzBGQlEwRXNWMEZCU3l4SFFVRk1MRU5CUVZNc1VVRkJVU3hEUVVGRExGRkJRVlFzUTBGQmEwSXNUVUZCYkVJc1EwRkJlVUlzWjBKQlFYTkNPMEZCUVVFc1ZVRkJjRUlzUzBGQmIwSXNVVUZCY0VJc1MwRkJiMEk3UVVGQlFTeFZRVUZpTEZGQlFXRXNVVUZCWWl4UlFVRmhPenRCUVVOMlJDeGhRVUZMTEVWQlFVd3NRMEZCVVN4WFFVRlNMRU5CUVc5Q0xGRkJRWEJDT3p0QlFVTkJMR0ZCUVVzc1JVRkJUQ3hEUVVGUkxGRkJRVklzUTBGQmFVSXNTMEZCYWtJN1FVRkRRU3hMUVVoUkxFTkJRVlE3TzBGQlNEQkZPMEZCVHpGRk96czdSVUZTTmtJc1QwRkJRU3hEUVVGQkxFODdPMEZCTWtJdlFpeFRRVUYzUWl4VFFVRjRRaXhEUVVGclF5eEZRVUZzUXl4RlFVRXlReXhEUVVFelF5eEZRVUZ0UkN4RFFVRnVSQ3hGUVVFd1JEdEJRVU42UkN4VFFVRlJMRU5CUVVNc1NVRkJTU3hKUVVGT0xFZEJRV01zU1VGQlNTeFpRVUZLTEVOQlFXbENMRVZCUVdwQ0xFVkJRWEZDTEVOQlFYSkNMRVZCUVhkQ0xFTkJRWGhDTEVOQlFXUXNSMEZCTWtNc1NVRkJTU3huUWtGQlNpeERRVUZ4UWl4RlFVRnlRaXhGUVVGNVFpeERRVUY2UWl4RFFVRnNSRHRCUVVOQk96dEJRVVpFTEU5QlFVRXNRMEZCUVN4UFFVRkJMRWRCUVVFc1UwRkJRU0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cVhHNU5TVlFnVEdsalpXNXpaVnh1WEc1RGIzQjVjbWxuYUhRZ0tHTXBJREl3TWpFZ1JXZHZjaUJPWlhCdmJXNTVZWE5qYUdsb1hHNWNibEJsY20xcGMzTnBiMjRnYVhNZ2FHVnlaV0o1SUdkeVlXNTBaV1FzSUdaeVpXVWdiMllnWTJoaGNtZGxMQ0IwYnlCaGJua2djR1Z5YzI5dUlHOWlkR0ZwYm1sdVp5QmhJR052Y0hsY2JtOW1JSFJvYVhNZ2MyOW1kSGRoY21VZ1lXNWtJR0Z6YzI5amFXRjBaV1FnWkc5amRXMWxiblJoZEdsdmJpQm1hV3hsY3lBb2RHaGxJRndpVTI5bWRIZGhjbVZjSWlrc0lIUnZJR1JsWVd4Y2JtbHVJSFJvWlNCVGIyWjBkMkZ5WlNCM2FYUm9iM1YwSUhKbGMzUnlhV04wYVc5dUxDQnBibU5zZFdScGJtY2dkMmwwYUc5MWRDQnNhVzFwZEdGMGFXOXVJSFJvWlNCeWFXZG9kSE5jYm5SdklIVnpaU3dnWTI5d2VTd2diVzlrYVdaNUxDQnRaWEpuWlN3Z2NIVmliR2x6YUN3Z1pHbHpkSEpwWW5WMFpTd2djM1ZpYkdsalpXNXpaU3dnWVc1a0wyOXlJSE5sYkd4Y2JtTnZjR2xsY3lCdlppQjBhR1VnVTI5bWRIZGhjbVVzSUdGdVpDQjBieUJ3WlhKdGFYUWdjR1Z5YzI5dWN5QjBieUIzYUc5dElIUm9aU0JUYjJaMGQyRnlaU0JwYzF4dVpuVnlibWx6YUdWa0lIUnZJR1J2SUhOdkxDQnpkV0pxWldOMElIUnZJSFJvWlNCbWIyeHNiM2RwYm1jZ1kyOXVaR2wwYVc5dWN6cGNibHh1VkdobElHRmliM1psSUdOdmNIbHlhV2RvZENCdWIzUnBZMlVnWVc1a0lIUm9hWE1nY0dWeWJXbHpjMmx2YmlCdWIzUnBZMlVnYzJoaGJHd2dZbVVnYVc1amJIVmtaV1FnYVc0Z1lXeHNYRzVqYjNCcFpYTWdiM0lnYzNWaWMzUmhiblJwWVd3Z2NHOXlkR2x2Ym5NZ2IyWWdkR2hsSUZOdlpuUjNZWEpsTGx4dVhHNVVTRVVnVTA5R1ZGZEJVa1VnU1ZNZ1VGSlBWa2xFUlVRZ1hDSkJVeUJKVTF3aUxDQlhTVlJJVDFWVUlGZEJVbEpCVGxSWklFOUdJRUZPV1NCTFNVNUVMQ0JGV0ZCU1JWTlRJRTlTWEc1SlRWQk1TVVZFTENCSlRrTk1WVVJKVGtjZ1FsVlVJRTVQVkNCTVNVMUpWRVZFSUZSUElGUklSU0JYUVZKU1FVNVVTVVZUSUU5R0lFMUZVa05JUVU1VVFVSkpURWxVV1N4Y2JrWkpWRTVGVTFNZ1JrOVNJRUVnVUVGU1ZFbERWVXhCVWlCUVZWSlFUMU5GSUVGT1JDQk9UMDVKVGtaU1NVNUhSVTFGVGxRdUlFbE9JRTVQSUVWV1JVNVVJRk5JUVV4TUlGUklSVnh1UVZWVVNFOVNVeUJQVWlCRFQxQlpVa2xIU0ZRZ1NFOU1SRVZTVXlCQ1JTQk1TVUZDVEVVZ1JrOVNJRUZPV1NCRFRFRkpUU3dnUkVGTlFVZEZVeUJQVWlCUFZFaEZVbHh1VEVsQlFrbE1TVlJaTENCWFNFVlVTRVZTSUVsT0lFRk9JRUZEVkVsUFRpQlBSaUJEVDA1VVVrRkRWQ3dnVkU5U1ZDQlBVaUJQVkVoRlVsZEpVMFVzSUVGU1NWTkpUa2NnUmxKUFRTeGNiazlWVkNCUFJpQlBVaUJKVGlCRFQwNU9SVU5VU1U5T0lGZEpWRWdnVkVoRklGTlBSbFJYUVZKRklFOVNJRlJJUlNCVlUwVWdUMUlnVDFSSVJWSWdSRVZCVEVsT1IxTWdTVTRnVkVoRlhHNVRUMFpVVjBGU1JTNWNiaW92WEc1Y2JtbHRjRzl5ZENCQ2FXNWtZV0pzWlNCbWNtOXRJQ2N1TDBKcGJtUmhZbXhsSnp0Y2JtbHRjRzl5ZENCRGJHRnpjeUJtY205dElDY3VMME5zWVhOekp6dGNibWx0Y0c5eWRDQkVaWE4wY205NVlXSnNaU0JtY205dElDY3VMMFJsYzNSeWIzbGhZbXhsSnp0Y2JseHVZMnhoYzNNZ1EyeGhjM05WY0dSaGRHVnlJR1Y0ZEdWdVpITWdRMnhoYzNNZ2UxeHVYSFJqYjI1emRISjFZM1J2Y2lod2NtbDJZWFJsSUdWc09pQkRiR0Z6YzFWd1pHRjBaWEpGYkdWdFpXNTBMQ0J3Y21sMllYUmxJR05zY3pvZ2MzUnlhVzVuTENCd2NtbDJZWFJsSUhCeWIzQmxjblI1T2lCQ2FXNWtZV0pzWlR4aGJuaytLU0I3WEc1Y2RGeDBjM1Z3WlhJb0tUdGNibHgwWEhSMGFHbHpMbDkxY0dSaGRHVW9LVHRjYmx4MFhIUjBhR2x6TG05M2JpaHdjbTl3WlhKMGVTNXZia05vWVc1blpTNXNhWE4wWlc0b2RHaHBjeTVmZFhCa1lYUmxMQ0IwYUdsektTazdYRzVjZEgxY2JseHVYSFJ3Y21sMllYUmxJRjkxY0dSaGRHVW9LU0I3WEc1Y2RGeDBkR2hwY3k1bGJDNTBiMmRuYkdWRGJHRnpjeWgwYUdsekxtTnNjeXdnSVNGMGFHbHpMbkJ5YjNCbGNuUjVMbWRsZENncEtUdGNibHgwZlZ4dWZWeHVYRzVqYkdGemN5QkRiR0Z6YzA1aGJXVlZjR1JoZEdWeUlHVjRkR1Z1WkhNZ1EyeGhjM01nZTF4dVhIUmpiMjV6ZEhKMVkzUnZjaWh3Y21sMllYUmxJR1ZzT2lCRGJHRnpjMDVoYldWVmNHUmhkR1Z5Uld4bGJXVnVkQ3dnY0hKdmNHVnlkSGs2SUVKcGJtUmhZbXhsUEhOMGNtbHVaejRwSUh0Y2JseDBYSFJ6ZFhCbGNpZ3BPMXh1WEhSY2RIUm9hWE11Wld3dVlXUmtRMnhoYzNNb2NISnZjR1Z5ZEhrdVoyVjBLQ2twTzF4dVhIUmNkSFJvYVhNdWIzZHVLSEJ5YjNCbGNuUjVMbTl1UTJoaGJtZGxMbXhwYzNSbGJpZ29lM1poYkhWbExDQnZiR1JXWVd4MVpYMHBJRDArSUh0Y2JseDBYSFJjZEhSb2FYTXVaV3d1Y21WdGIzWmxRMnhoYzNNb2IyeGtWbUZzZFdVcE8xeHVYSFJjZEZ4MGRHaHBjeTVsYkM1aFpHUkRiR0Z6Y3loMllXeDFaU2s3WEc1Y2RGeDBmU2twTzF4dVhIUjlYRzU5WEc1Y2JpOHFLbHh1SUNvZ1FtbHVaSE1nY0hKbGMyVnVZMlVnYjJZZ1lTQkRVMU1nWTJ4aGMzTWdiMllnWVNCRVQwMGdaV3hsYldWdWRDQjBieUJoSUdKdmIyeGxZVzRnWUZCeWIzQmxjblI1WUM1Y2JpQXFJRUJ3WVhKaGJTQmxiQ0JFVDAwZ1pXeGxiV1Z1ZEM1Y2JpQXFJRUJ3WVhKaGJTQmpiSE1nUTFOVElHTnNZWE56SUc1aGJXVXVYRzRnS2lCQWNHRnlZVzBnY0hKdmNHVnlkSGtnVUhKdmNHVnlkSGtnZEc4Z1ltbHVaQ0J3Y21WelpXNWpaU0J2WmlCMGFHVWdRMU5USUdOc1lYTnpJSFJ2TGx4dUlDb2dRSEpsZEhWeWJuTWdRbWx1WkdsdVp5QnZZbXBsWTNRdUlGbHZkU0J0ZFhOMElHUmxjM1J5YjNrZ2FYUWdkRzhnYzNSdmNDQjBhR1VnYzNsdVkyaHliMjVwZW1GMGFXOXVMbHh1SUNvdlhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCbWRXNWpkR2x2YmlCaWFXNWtRMnhoYzNNb1pXdzZJRU5zWVhOelZYQmtZWFJsY2tWc1pXMWxiblFzSUdOc2N6b2djM1J5YVc1bkxDQndjbTl3WlhKMGVUb2dRbWx1WkdGaWJHVThZbTl2YkdWaGJqNHBPaUJFWlhOMGNtOTVZV0pzWlR0Y2JseHVMeW9xWEc0Z0tpQkNhVzVrY3lCdVlXMWxJRzltSUdFZ1ExTlRJR05zWVhOeklHOW1JR0VnUkU5TklHVnNaVzFsYm5RZ2RHOGdZU0J6ZEhKcGJtY2dZRkJ5YjNCbGNuUjVZQzVjYmlBcUlFQndZWEpoYlNCbGJDQkVUMDBnWld4bGJXVnVkQzVjYmlBcUlFQndZWEpoYlNCamJITWdVSEp2Y0dWeWRIa2dZMjl1ZEdGcGJtbHVaeUJoSUVOVFV5QmpiR0Z6Y3lCdVlXMWxMbHh1SUNvZ1FISmxkSFZ5Ym5NZ1FtbHVaR2x1WnlCdlltcGxZM1F1SUZsdmRTQnRkWE4wSUdSbGMzUnliM2tnYVhRZ2RHOGdjM1J2Y0NCMGFHVWdjM2x1WTJoeWIyNXBlbUYwYVc5dUxseHVJQ292WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JtZFc1amRHbHZiaUJpYVc1a1EyeGhjM01vWld3NklFTnNZWE56VG1GdFpWVndaR0YwWlhKRmJHVnRaVzUwTENCamJITTZJRUpwYm1SaFlteGxQSE4wY21sdVp6NHBPaUJFWlhOMGNtOTVZV0pzWlR0Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUdaMWJtTjBhVzl1SUdKcGJtUkRiR0Z6Y3lobGJEb2dZVzU1TENCaE9pQmhibmtzSUdJL09pQmhibmtwT2lCRVpYTjBjbTk1WVdKc1pTQjdYRzVjZEhKbGRIVnliaUFvWWlBaFBTQnVkV3hzS1NBL0lHNWxkeUJEYkdGemMxVndaR0YwWlhJb1pXd3NJR0VzSUdJcElEb2dibVYzSUVOc1lYTnpUbUZ0WlZWd1pHRjBaWElvWld3c0lHRXBPMXh1ZlZ4dVhHNWxlSEJ2Y25RZ2FXNTBaWEptWVdObElFTnNZWE56VlhCa1lYUmxja1ZzWlcxbGJuUWdlMXh1WEhSMGIyZG5iR1ZEYkdGemN5aGpiSE02SUhOMGNtbHVaeXdnZG1Gc2RXVTZJR0p2YjJ4bFlXNHBPaUIyYjJsa08xeHVmVnh1WEc1bGVIQnZjblFnYVc1MFpYSm1ZV05sSUVOc1lYTnpUbUZ0WlZWd1pHRjBaWEpGYkdWdFpXNTBJSHRjYmx4dVhIUmhaR1JEYkdGemN5aGpiSE02SUhOMGNtbHVaeWs2SUhadmFXUTdYRzVjYmx4MGNtVnRiM1psUTJ4aGMzTW9ZMnh6T2lCemRISnBibWNwT2lCMmIybGtPMXh1ZlZ4dUlsMHNJbk52ZFhKalpWSnZiM1FpT2lJaWZRPT0iXSwic291cmNlUm9vdCI6IiJ9