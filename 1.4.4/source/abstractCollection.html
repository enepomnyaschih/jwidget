<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
	jWidget Lib source file.

	Copyright (C) 2015 Egor Nepomnyaschih

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public License
	along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

<span id='JW-AbstractCollection'>/**
</span> * @class
 *
 * `&lt;T&gt;` Abstract collection of items of type T.
 *
 * There are 3 collection types:
 *
 * - JW.AbstractArray, extends JW.IndexedCollection
 * - JW.AbstractMap, extends JW.IndexedCollection
 * - JW.AbstractSet
 *
 * You can convert collections to each other using algorithms.
 *
 * Each collection has 2 implementations:
 *
 * - Simple collections: JW.Array, JW.Map, JW.Set
 * - Observable collection: JW.ObservableArray, JW.ObservableMap, JW.ObservableSet
 *
 * The difference is that observable collection triggers the events about its modifications.
 * It lets you to synchronize view with data on fly in accordance to Model-View architecture.
 * The next synchronizers exist to connect observable collections to each other:
 *
 * &lt;table&gt;
 *   &lt;tbody&gt;
 *     &lt;tr&gt;&lt;td&gt;Synchronizer&lt;/td&gt;&lt;td&gt;Class&lt;/td&gt;&lt;td&gt;Creation methods&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Item mapper&lt;/td&gt;&lt;td&gt;JW.AbstractCollection.Mapper&lt;/td&gt;&lt;td&gt;#$$mapValues, #$$mapObjects, #createMapper&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Filterer&lt;/td&gt;&lt;td&gt;JW.AbstractCollection.Filterer&lt;/td&gt;&lt;td&gt;#$$filter, #createFilterer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Matching item counter&lt;/td&gt;&lt;td&gt;JW.AbstractCollection.Counter&lt;/td&gt;&lt;td&gt;#$$count, #createCounter&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Converter to set&lt;/td&gt;&lt;td&gt;JW.AbstractCollection.Lister&lt;/td&gt;&lt;td&gt;#$$toSet, #createLister&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Converter to map (indexer)&lt;/td&gt;&lt;td&gt;JW.AbstractCollection.Indexer&lt;/td&gt;&lt;td&gt;#$$index, #createIndexer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Converter to array (orderer)&lt;/td&gt;&lt;td&gt;JW.AbstractCollection.Orderer&lt;/td&gt;&lt;td&gt;#$$toArray, #createOrderer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Converter to array (sorter by comparer)&lt;/td&gt;&lt;td&gt;JW.AbstractCollection.SorterComparing&lt;/td&gt;&lt;td&gt;#$$toSortedComparing, #createSorterComparing&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Observer&lt;/td&gt;&lt;td&gt;JW.AbstractCollection.Observer&lt;/td&gt;&lt;td&gt;#createObserver&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;View synchronizers&lt;/td&gt;&lt;td&gt;JW.AbstractArray.Inserter, JW.AbstractMap.Inserter, JW.UI.Inserter&lt;/td&gt;&lt;td&gt;createInserter&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Arrays merger&lt;/td&gt;&lt;td&gt;JW.AbstractArray.Merger&lt;/td&gt;&lt;td&gt;{@link JW.AbstractArray#$$merge $$merge}, {@link JW.AbstractArray#createMerger createMerger}&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;Array reverser&lt;/td&gt;&lt;td&gt;JW.AbstractArray.Reverser&lt;/td&gt;&lt;td&gt;{@link JW.AbstractArray#$$toReversed $$toReversed}, {@link JW.AbstractArray#createReverser createReverser}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;/tbody&gt;
 * &lt;/table&gt;
 *
 * Internally, simple collections are very similar to native JavaScript collections.
 * But their API is identical to observable collections' (excepting lack of events).
 * So you can use simple collections as a bridge between native JavaScript collections and
 * jWidget observable collections.
 *
 * Please keep the next rules in mind whenever you work with jWidget collections.
 *
 * 1) null and undefined items are prohibited in jWidget collections.
 * Use &quot;Null Object&quot; pattern if it is neccessary.
 *
 * 2) The majority of collection modification methods have 2 implementations: **tryMethod** and **method**.
 * These methods perform the same collection modification but return different result.
 * tryMethod is introduced for internal use mainly,
 * and *it always returns undefined if collection has not been modified*.
 * For example, &lt;a href=&quot;#tryclear&quot;&gt;tryClear&lt;/a&gt; returns undefined if collection is empty,
 * else it returns old collection contents.
 * **method** returns result in more friendly format.
 * For example, &lt;a href=&quot;#clear&quot;&gt;clear&lt;/a&gt; always returns old collection contents.
 * So, if you want to clear collection and destroy all items, &lt;a href=&quot;#clear&quot;&gt;clear&lt;/a&gt; method fits better:
 *
 *     JW.Array.each(array.clear(), JW.destroy); // correct
 *     JW.Array.each(array.tryClear(), JW.destroy); // incorrect: 'undefined' exception if array is empty
 *
 * 3) Majority of collection returning methods have 3 implementations: **method**, **$method** and **$$method**.
 * These methods perform the same modification but return the result in different format.
 *
 * * **method** returns native JavaScript collection: Array or Object.
 * * **$method** returns jWidget collection: JW.Array, JW.Map or JW.Set.
 * * **$$method** returns jWidget collection and starts continuous synchronization with original
 * collection if one is observable. To stop synchronization, #destroy the target collection.
 *
 * Use one method that's more convenient in your specific situation.
 * For example, `$method` is convenient for chaining algorithm method calls.
 * So, previous example can be changed next way:
 *
 *     array.{@link JW.AbstractArray#$clear $clear}().{@link JW.AbstractArray#each each}(JW.destroy);
 *
 * But in the next example `method` is more appropriate:
 *
 *     set.{@link JW.AbstractArray#addAll addAll}(array.{@link JW.AbstractArray#clear clear}());
 *
 * Whereas `$$method` is just a shorthand for synchronizer creation:
 *
 *     this.set = this.own(array.{@link JW.AbstractArray#$$toSet $$toSet}());
 *     // pretty much the same as
 *     this.set = this.own(array.{@link JW.AbstractArray#createLister createLister}()).target;
 *
 * 4) It is better if all items in collection are unique. Some methods like
 * JW.AbstractArray#performReorder require each item to have an unique key.
 * If 2 items of collection are equal, then their keys are equal as well, so this method won't work correctly.
 *
 * # Collection methods
 *
 * Content retrieving:
 *
 * - {@link #getLength} - Returns count of items in collection. For observable collections, `length` property may come
 * in handy if you want to track collection length dynamically.
 * - {@link #isEmpty} - Checks collection for emptiness.
 * - {@link #getFirst} - Returns first item in collection.
 * - {@link #containsItem} - Does collection contain the item?
 *
 * Iteration algorhitms:
 *
 * - {@link #every} - Checks all items by criteria.
 * Returns `true` if all items match the criteria.
 * - {@link #some} - Checks each item by criteria.
 * Returns `true` if some items matches the criteria.
 * - {@link #each} - Iterates items.
 * - {@link #search} - Finds item by criteria.
 * Returns first item matching the criteria.
 * - {@link #filter}, #$filter, #$$filter - Filters collection by criteria.
 * Builds new collection of the same type, consisting of items matching the criteria.
 * - {@link #count}, #$count, #$$count - Counts the items matching criteria.
 * - {@link #map}, #$map, #$$mapValues, #$$mapObjects - Maps collection items.
 * Builds new collection of the same type, consisting of results of mapping function call for each collection item.
 * - {@link #toSorted}, #$toSorted, #toSortedComparing, #$toSortedComparing, #$$toSortedComparing -
 * Builds array consisting of collection items sorted by indexer or comparer.
 * - {@link #index}, #$index, #$$index - Indexes collection.
 * Builds new map by rule: key is the result of indexer function call, value is the corresponding item.
 * - {@link #toArray}, #$toArray, #$$toArray - Builds new array consisting of collection items.
 * - {@link #toSet}, #$toSet, #$$toSet - Builds new set consisting of collection items.
 * - {@link #asArray}, #$asArray - Represents collection as array.
 * - {@link #asSet}, #$asSet - Represents collection as set.
 *
 * Collection modification:
 *
 * - {@link #removeItem} - Removes first occurency of an item in collection.
 * - {@link #removeItems} - Removes all occurencies of items in collection.
 * - {@link #clear}, #$clear, #tryClear - Clears collection.
 *
 * Synchronizers creation:
 *
 * - {@link #createMapper} - Creates item mapper. Extended version of #$$mapValues and #$$mapObjects methods.
 * - {@link #createFilterer} - Creates filterer. Extended version of #$$filter method.
 * - {@link #createCounter} - Creates matching item counter. Extended version of #$$count method.
 * - {@link #createLister} - Creates converter to set. Extended version of #$$toSet method.
 * - {@link #createIndexer} - Creates converter to map (indexer). Extended version of #$$index method.
 * - {@link #createOrderer} - Creates converter to array (orderer). Extended version of #$$toArray method.
 * - {@link #createSorterComparing} - Creates converter to array (sorter by comparer). Extended version of #$$toSortedComparing method.
 * - {@link #createObserver} - Creates observer.
 *
 * Similar collection creation (for algorithms and synchronizers implementation):
 *
 * - {@link #createEmpty} - Creates empty collection of the same type.
 * - {@link #createEmptyArray} - Creates empty array of the same observability type.
 * - {@link #createEmptyMap} - Creates empty map of the same observability type.
 * - {@link #createEmptySet} - Creates empty set of the same observability type.
 *
 * All the same algorithms are also available for native JavaScript collections:
 *
 * - Array, see JW.Array static methods.
 * - Object as map, see JW.Map static methods.
 * - Object as set, see JW.Set static methods.
 *
 * @extends JW.Class
 * @abstract
 */
JW.AbstractCollection = function() {
	JW.AbstractCollection._super.call(this);
	this._ownsItems = false;
};

JW.AbstractCollection._create$Array = function(algorithm) {
	return function() {
		return new JW.Array(this[algorithm].apply(this, arguments), true);
	};
};

JW.AbstractCollection._create$Map = function(algorithm) {
	return function() {
		return new JW.Map(this[algorithm].apply(this, arguments), true);
	};
};

JW.AbstractCollection._create$Set = function(algorithm) {
	return function() {
		return new JW.Set(this[algorithm].apply(this, arguments), true);
	};
};

JW.extend(JW.AbstractCollection, JW.Class, {
<span id='JW-AbstractCollection-method-ownItems'>	/**
</span>	 * Makes this collection an owner of its items, which means that its items are alive while they are present in
	 * this collection. The item is destroyed when it leaves the
	 * collection, and all items are destroyed on the collection destruction.
	 * @returns {JW.AbstractCollection} this
	 */
	ownItems: function() {
		this._ownsItems = true;
		return this;
	},

	destroyObject: function() {
		this.tryClear();
		this._super();
	},

<span id='JW-AbstractCollection-method-getLength'>	/**
</span>	 * @method getLength
	 * Returns count of items in collection.
	 * @returns {number} Count of items in collection.
	 */
<span id='JW-AbstractCollection-method-isEmpty'>	/**
</span>	 * @method isEmpty
	 * Checks collection for emptiness.
	 * @returns {boolean} Collection doesn't contain any items.
	 */
<span id='JW-AbstractCollection-method-getFirst'>	/**
</span>	 * Returns first item in collection. If collection is empty, returns `undefined`.
	 * @returns {T} Item.
	 */
	getFirst: function() {
		return this._callStatic(&quot;getFirst&quot;);
	},

<span id='JW-AbstractCollection-method-containsItem'>	/**
</span>	 * @method containsItem
	 * Checks item existance in collection.
	 * @param {T} item Item.
	 * @returns {boolean} Collection contains specified item.
	 */
<span id='JW-AbstractCollection-method-removeItem'>	/**
</span>	 * @method removeItem
	 * Removes first occurency of an item in collection.
	 * @param {T} item Item.
	 * @returns {void}
	 */
<span id='JW-AbstractCollection-method-removeItems'>	/**
</span>	 * @method removeItems
	 * Removes all occurencies of items in collection.
	 * Works for `&lt;T extends JW.Class&gt;` only.
	 * @param {Array} items `&lt;T&gt;` Item.
	 * @returns {void}
	 */
<span id='JW-AbstractCollection-method-tryClear'>	/**
</span>	 * @method tryClear
	 * Clears collection.
	 * @returns {Array/Object} `&lt;T&gt;` Old collection contents. If not modified - `undefined`.
	 */
<span id='JW-AbstractCollection-method-clear'>	/**
</span>	 * @method clear
	 * Clears collection.
	 * @returns {Array/Object} `&lt;T&gt;` Old collection contents.
	 */
<span id='JW-AbstractCollection-method-S-clear'>	/**
</span>	 * @method $clear
	 * Clears collection.
	 * @returns {JW.AbstractCollection} `&lt;T&gt;` Old collection contents.
	 */
<span id='JW-AbstractCollection-method-every'>	/**
</span>	 * @method every
	 *
	 * Checks all items by criteria.
	 *
	 * Returns true if function `f` returns !== `false` for all collection items.
	 *
	 * Algorithms iterates items sequentially, and stops after first item not matching the criteria.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {boolean} Result.
	 */

<span id='JW-AbstractCollection-method-some'>	/**
</span>	 * Checks each item by criteria.
	 *
	 * Returns true if function `f` returns !== `false` for some collection item.
	 *
	 * Algorithms iterates items sequentially, and stops after first item matching the criteria.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {boolean} Result.
	 */
	some: function(callback, scope) {
		return !this.every(function(item) {
			return callback.call(this, item) === false;
		}, scope);
	},

<span id='JW-AbstractCollection-method-each'>	/**
</span>	 * Iterates collection items. Calls specified function for all items.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): void`
	 *
	 * Function.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {void}
	 */
	each: function(callback, scope) {
		this.every(function(item) {
			callback.call(this, item);
			return true;
		}, scope);
	},

<span id='JW-AbstractCollection-method-search'>	/**
</span>	 * Finds item by criteria.
	 *
	 * Returns first item for which `f` returns !== `false`.
	 *
	 * Algorithms iterates items sequentially, and stops after first item matching the criteria.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {T} Found item or `undefined`.
	 */
	search: function(callback, scope) {
		var result;
		this.every(function(item) {
			if (callback.call(this, item) !== false) {
				result = item;
				return false;
			}
			return true;
		}, scope);
		return result;
	},

<span id='JW-AbstractCollection-method-toSorted'>	/**
</span>	 * Converts collection to sorted array.
	 *
	 * Builds array consisting of collection items sorted by result of `f` call for each item.
	 *
	 * @param {Function} [f]
	 *
	 * `f(item: T): number/string`
	 *
	 * Indexer function. Returns `item` by default.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @param {1/-1} [order] Sorting order.
	 * @returns {Array} `&lt;T&gt;` Sorted array.
	 */
	toSorted: function(callback, scope, order) {
		return this._callStatic(&quot;toSorted&quot;, [callback, scope || this, order]);
	},

<span id='JW-AbstractCollection-method-S-toSorted'>	/**
</span>	 * Converts collection to sorted array.
	 *
	 * Builds array consisting of collection items sorted by result of `f` call for each item.
	 *
	 * @param {Function} [f]
	 *
	 * `f(item: T): number/string`
	 *
	 * Indexer function. Returns `item` by default.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @param {1/-1} [order] Sorting order.
	 * @returns {JW.Array} `&lt;T&gt;` Sorted array.
	 */
	$toSorted: JW.AbstractCollection._create$Array(&quot;toSorted&quot;),

<span id='JW-AbstractCollection-method-toSortedComparing'>	/**
</span>	 * Converts collection to sorted array.
	 *
	 * Builds array consisting of collection items sorted by comparer.
	 *
	 * @param {Function} [compare]
	 *
	 * `f(t1: T, t2: T): number`
	 *
	 * Comparer function. Returns positive value if t1 &gt; t2; nagative value if t1 &lt; t2; 0 if t1 == t2.
	 * Defaults to `JW.cmp(t1, t2)`.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @param {1/-1} [order] Sorting order.
	 * @returns {Array} `&lt;T&gt;` Sorted array.
	 */
	toSortedComparing: function(compare, scope, order) {
		return this._callStatic(&quot;toSortedComparing&quot;, [compare, scope || this, order]);
	},

<span id='JW-AbstractCollection-method-S-toSortedComparing'>	/**
</span>	 * Converts collection to sorted array.
	 *
	 * Builds array consisting of collection items sorted by comparer.
	 *
	 * @param {Function} [compare]
	 *
	 * `f(t1: T, t2: T): number`
	 *
	 * Comparer function. Returns positive value if t1 &gt; t2; nagative value if t1 &lt; t2; 0 if t1 == t2.
	 * Defaults to `JW.cmp(t1, t2)`.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @param {1/-1} [order] Sorting order.
	 * @returns {JW.Array} `&lt;T&gt;` Sorted array.
	 */
	$toSortedComparing: JW.AbstractCollection._create$Array(&quot;toSortedComparing&quot;),

<span id='JW-AbstractCollection-method-S-S-toSortedComparing'>	/**
</span>	 * Converts collection to sorted array.
	 *
	 * Builds array consisting of collection items sorted by comparer.
	 * If this collection is observable, starts continuous synchronization,
	 * i.e. creates JW.AbstractCollection.SorterComparing implicitly.
	 *
	 * @param {Function} [compare]
	 *
	 * `f(t1: T, t2: T): number`
	 *
	 * Comparer function. Returns positive value if t1 &gt; t2; nagative value if t1 &lt; t2; 0 if t1 == t2.
	 * Defaults to `JW.cmp(t1, t2)`.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @param {1/-1} [order] Sorting order.
	 * @returns {JW.AbstractArray} `&lt;T&gt;` Sorted array.
	 */
	$$toSortedComparing: function(compare, scope, order) {
		return this.$toSortedComparing(compare, scope, order);
	},

<span id='JW-AbstractCollection-method-index'>	/**
</span>	 * Indexes collection.
	 *
	 * Builds new map by rule: key is the result of indexer function call, value is the corresponding item.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): string`
	 *
	 * Indexer function.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {Object} `&lt;T&gt;` Collection index.
	 */
	index: function(callback, scope) {
		var result = {};
		this.every(function(item) {
			var key = callback.call(this, item);
			if (JW.isSet(key)) {
				result[key] = item;
			}
			return true;
		}, scope);
		return result;
	},

<span id='JW-AbstractCollection-method-S-index'>	/**
</span>	 * Indexes collection.
	 *
	 * Builds new map by rule: key is the result of indexer function call, value is the corresponding item.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): string`
	 *
	 * Indexer function.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.Map} `&lt;T&gt;` Collection index.
	 */
	$index: JW.AbstractCollection._create$Map(&quot;index&quot;),

<span id='JW-AbstractCollection-method-S-S-index'>	/**
</span>	 * Indexes collection.
	 *
	 * Builds new map by rule: key is the result of indexer function call, value is the corresponding item.
	 * If this collection is observable, starts continuous synchronization,
	 * i.e. creates JW.AbstractCollection.Indexer implicitly.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): string`
	 *
	 * Indexer function.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.AbstractMap} `&lt;T&gt;` Collection index.
	 */
	$$index: function(callback, scope) {
		return this.$index(callback, scope);
	},

<span id='JW-AbstractCollection-method-toArray'>	/**
</span>	 * Converts collection to array.
	 *
	 * Builds new array consisting of collection items.
	 *
	 * @returns {Array} `&lt;T&gt;` Items array.
	 */
	toArray: function() {
		var result = new Array(this.getLength());
		var index = 0;
		this.every(function(item) {
			result[index++] = item;
		});
		return result;
	},

<span id='JW-AbstractCollection-method-S-toArray'>	/**
</span>	 * Converts collection to array.
	 *
	 * Builds new array consisting of collection items.
	 *
	 * @returns {JW.Array} `&lt;T&gt;` Items array.
	 */
	$toArray: JW.AbstractCollection._create$Array(&quot;toArray&quot;),

<span id='JW-AbstractCollection-method-S-S-toArray'>	/**
</span>	 * Converts collection to array.
	 *
	 * Builds new array consisting of collection items.
	 * If this collection is observable, starts continuous synchronization,
	 * i.e. creates JW.AbstractCollection.Orderer implicitly.
	 *
	 * @returns {JW.AbstractArray} `&lt;T&gt;` Items array.
	 */
	$$toArray: function() {
		return this.$toArray();
	},

<span id='JW-AbstractCollection-method-toSet'>	/**
</span>	 * Converts collection to set.
	 *
	 * Builds new set consisting of collection items.
	 *
	 * @returns {Object} `&lt;T&gt;` Items set.
	 */
	toSet: function() {
		var result = {};
		this.every(function(item) {
			JW.Set.add(result, item);
		});
		return result;
	},

<span id='JW-AbstractCollection-method-S-toSet'>	/**
</span>	 * Converts collection to set.
	 *
	 * Builds new set consisting of collection items.
	 *
	 * @returns {JW.Set} `&lt;T&gt;` Items set.
	 */
	$toSet: JW.AbstractCollection._create$Set(&quot;toSet&quot;),

<span id='JW-AbstractCollection-method-S-S-toSet'>	/**
</span>	 * Converts collection to set.
	 *
	 * Builds new set consisting of collection items.
	 * If this collection is observable, starts continuous synchronization,
	 * i.e. creates JW.AbstractCollection.Lister implicitly.
	 *
	 * @returns {JW.AbstractSet} `&lt;T&gt;` Items set.
	 */
	$$toSet: function() {
		return this.$toSet();
	},

<span id='JW-AbstractCollection-method-asArray'>	/**
</span>	 * Represents collection as array.
	 *
	 * If this collection is array, returns it immediately. Else, executes #toArray method.
	 * This method works probably faster than #toArray, but please make sure that the returned array
	 * won't be modified externally, because it can cause strange unexpected bugs.
	 *
	 * @returns {Array} `&lt;T&gt;` Items array.
	 */
	asArray: function() {
		return this.toArray();
	},

<span id='JW-AbstractCollection-method-S-asArray'>	/**
</span>	 * Represents collection as array.
	 *
	 * If this collection is array, returns it immediately. Else, executes #toArray method.
	 * This method works probably faster than #toArray, but please make sure that the returned array
	 * won't be modified externally, because it can cause strange unexpected bugs.
	 *
	 * @returns {JW.Array} `&lt;T&gt;` Items array
	 */
	$asArray: JW.AbstractCollection._create$Array(&quot;asArray&quot;),

<span id='JW-AbstractCollection-method-asSet'>	/**
</span>	 * Represents collection as set.
	 *
	 * If this collection is set, returns it immediately. Else, executes #toSet method.
	 * This method works probably faster than #toSet, but please make sure that the returned set
	 * won't be modified externally, because it can cause strange unexpected bugs.
	 *
	 * @returns {Object} `&lt;T&gt;` Items set.
	 */
	asSet: function() {
		return this.toSet();
	},

<span id='JW-AbstractCollection-method-S-asSet'>	/**
</span>	 * Represents collection as set.
	 *
	 * If this collection is set, returns it immediately. Else, executes #toSet method.
	 * This method works probably faster than #toSet, but please make sure that the returned set
	 * won't be modified externally, because it can cause strange unexpected bugs.
	 *
	 * @returns {JW.Set} `&lt;T&gt;` Items set.
	 */
	$asSet: JW.AbstractCollection._create$Set(&quot;asSet&quot;),

<span id='JW-AbstractCollection-method-filter'>	/**
</span>	 * @method filter
	 *
	 * Filters collection by criteria.
	 *
	 * Builds new collection of the same type, consisting of items for which `f` returns !== `false`.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {Array/Object} `&lt;T&gt;` Filtered collection.
	 */
<span id='JW-AbstractCollection-method-S-filter'>	/**
</span>	 * @method $filter
	 *
	 * Filters collection by criteria.
	 *
	 * Builds new collection of the same type, consisting of items for which `f` returns !== `false`.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.AbstractCollection} `&lt;T&gt;` Filtered collection.
	 */
<span id='JW-AbstractCollection-method-S-S-filter'>	/**
</span>	 * Filters collection by criteria.
	 *
	 * Builds new collection of the same type, consisting of items for which `f` returns !== `false`.
	 * If this collection is observable, starts continuous synchronization,
	 * i.e. creates JW.AbstractCollection.Filterer implicitly.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T, index: number): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.AbstractCollection} `&lt;T&gt;` Filtered collection.
	 */
	$$filter: function(callback, scope) {
		return this.$filter(callback, scope);
	},

<span id='JW-AbstractCollection-method-count'>	/**
</span>	 * @method count
	 *
	 * Counts the items matching criteria.
	 *
	 * Returns the number of items for which `f` returns !== `false`.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {number} Number of items.
	 */
<span id='JW-AbstractCollection-method-S-count'>	/**
</span>	 * Counts the items matching criteria.
	 *
	 * Returns the number of items for which `f` returns !== `false`.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.Property} `&lt;number&gt;` Number of items.
	 */
	$count: function(callback, scope) {
		return new JW.Property(this.count(callback, scope));
	},

<span id='JW-AbstractCollection-method-S-S-count'>	/**
</span>	 * Counts the items matching criteria.
	 *
	 * Returns the number of items for which `f` returns !== `false`.
	 * If this collection is observable, starts continuous synchronization,
	 * i.e. creates JW.AbstractCollection.Counter implicitly.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): boolean`
	 *
	 * Criteria.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.Property} `&lt;number&gt;` Number of items.
	 */
	$$count: function(callback, scope) {
		return this.$count(callback, scope);
	},

<span id='JW-AbstractCollection-method-map'>	/**
</span>	 * @method map
	 *
	 * `&lt;U&gt;` Maps collection items.
	 *
	 * Builds new collection of the same type, consisting of results of `f` call for each collection item.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): U`
	 *
	 * Mapping function.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {Array/Object} `&lt;U&gt;` Mapped collection.
	 */
<span id='JW-AbstractCollection-method-S-map'>	/**
</span>	 * @method $map
	 *
	 * `&lt;U&gt;` Maps collection items.
	 *
	 * Builds new collection of the same type, consisting of results of `f` call for each collection item.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): U`
	 *
	 * Mapping function.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.AbstractCollection} `&lt;U&gt;` Mapped collection.
	 */
<span id='JW-AbstractCollection-method-S-S-mapValues'>	/**
</span>	 * `&lt;U&gt;` Maps collection items.
	 *
	 * Builds new collection of the same type, consisting of results of `f` call for each collection item.
	 * If this collection is observable, starts continuous synchronization,
	 * i.e. creates JW.AbstractCollection.Mapper implicitly.
	 * In comparison to #$$mapObjects method, doesn't destroy the resulting items after their removal.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): U`
	 *
	 * Mapping function.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.AbstractCollection} `&lt;U&gt;` Mapped collection.
	 */
	$$mapValues: function(callback, scope) {
		return this.$map(callback, scope);
	},
<span id='JW-AbstractCollection-method-S-S-mapObjects'>	/**
</span>	 * `&lt;U&gt;` Maps collection items.
	 *
	 * Builds new collection of the same type, consisting of results of `f` call for each collection item.
	 * If this collection is observable, starts continuous synchronization,
	 * i.e. creates JW.AbstractCollection.Mapper implicitly.
	 * In comparison to #$$mapValues method, destroys the resulting items after their removal.
	 *
	 * @param {Function} f
	 *
	 * `f(item: T): U`
	 *
	 * Mapping function.
	 *
	 * @param {Object} [scope] `f` call scope. Defaults to `this`.
	 * @returns {JW.AbstractCollection} `&lt;U&gt;` Mapped collection.
	 */
	$$mapObjects: function(callback, scope) {
		return this.$map(callback, scope).ownItems();
	}

<span id='JW-AbstractCollection-method-createEmpty'>	/**
</span>	 * @method createEmpty
	 * `&lt;U&gt;` Creates empty collection of the same type.
	 * @returns {JW.AbstractCollection} `&lt;U&gt;` Collection.
	 */
<span id='JW-AbstractCollection-method-createEmptyArray'>	/**
</span>	 * @method createEmptyArray
	 * `&lt;U&gt;` Creates empty array of the same observability level.
	 * @returns {JW.AbstractArray} `&lt;U&gt;` Array.
	 */
<span id='JW-AbstractCollection-method-createEmptyMap'>	/**
</span>	 * @method createEmptyMap
	 * `&lt;U&gt;` Creates empty map of the same observability level.
	 * @returns {JW.AbstractMap} `&lt;U&gt;` Map.
	 */
<span id='JW-AbstractCollection-method-createEmptySet'>	/**
</span>	 * @method createEmptySet
	 * `&lt;U&gt;` Creates empty set of the same observability level.
	 * @returns {JW.AbstractSet} `&lt;U&gt;` Set.
	 */
<span id='JW-AbstractCollection-method-createMapper'>	/**
</span>	 * @method createMapper
	 * `&lt;U&gt;` Creates collection item mapper.
	 * Selects appropriate synchronizer implementation automatically.
	 * Extended version of #$$mapValues and #$$mapObjects methods.
	 * @param {Object} config Configuration (see synchronizer's Config options).
	 * @returns {JW.AbstractCollection.Mapper}
	 * `&lt;T, U, JW.AbstractCollection&lt;T&gt;, JW.AbstractCollection&lt;U&gt;&gt;` Synchronizer.
	 */
<span id='JW-AbstractCollection-method-createFilterer'>	/**
</span>	 * @method createFilterer
	 * Creates collection filterer.
	 * Selects appropriate synchronizer implementation automatically.
	 * Extended version of #$$filter method.
	 * @param {Object} config Configuration (see synchronizer's Config options).
	 * @returns {JW.AbstractCollection.Filterer}
	 * `&lt;T, JW.AbstractCollection&lt;T&gt;&gt;` Synchronizer.
	 */
<span id='JW-AbstractCollection-method-createCounter'>	/**
</span>	 * @method createCounter
	 * Creates matching item counter.
	 * Selects appropriate synchronizer implementation automatically.
	 * Extended version of #$$count method.
	 * @param {Object} config Configuration (see synchronizer's Config options).
	 * @returns {JW.AbstractCollection.Counter}
	 * `&lt;T&gt;` Synchronizer.
	 */
<span id='JW-AbstractCollection-method-createObserver'>	/**
</span>	 * @method createObserver
	 * Creates collection observer.
	 * Selects appropriate synchronizer implementation automatically.
	 * @param {Object} config Configuration (see synchronizer's Config options).
	 * @returns {JW.AbstractCollection.Observer}
	 * `&lt;T, JW.AbstractCollection&lt;T&gt;&gt;` Synchronizer.
	 */
<span id='JW-AbstractCollection-method-createOrderer'>	/**
</span>	 * @method createOrderer
	 * Creates collection converter to array (orderer).
	 * Selects appropriate synchronizer implementation automatically.
	 * Extended version of #$$toArray method.
	 * @param {Object} [config] Configuration (see synchronizer's Config options).
	 * @returns {JW.AbstractCollection.Orderer}
	 * `&lt;T, JW.AbstractCollection&lt;T&gt;&gt;` Synchronizer.
	 */
<span id='JW-AbstractCollection-method-createSorterComparing'>	/**
</span>	 * @method createSorterComparing
	 * Creates collection converter to array (sorter by comparer).
	 * Selects appropriate synchronizer implementation automatically.
	 * Extended version of #$$toSortedComparing method.
	 * @param {Object} config Configuration (see synchronizer's Config options).
	 * @returns {JW.AbstractCollection.SorterComparing}
	 * `&lt;T, JW.AbstractCollection&lt;T&gt;&gt;` Synchronizer.
	 */
<span id='JW-AbstractCollection-method-createIndexer'>	/**
</span>	 * @method createIndexer
	 * Creates collection converter to map (indexer).
	 * Selects appropriate synchronizer implementation automatically.
	 * Extended version of #$$index method.
	 * @param {Object} config Configuration (see synchronizer's Config options).
	 * @returns {JW.AbstractCollection.Indexer}
	 * `&lt;T, JW.AbstractCollection&lt;T&gt;&gt;` Synchronizer.
	 */
<span id='JW-AbstractCollection-method-createLister'>	/**
</span>	 * @method createLister
	 * Creates collection converter to set.
	 * Selects appropriate synchronizer implementation automatically.
	 * Extended version of #$$toSet method.
	 * @param {Object} [config] Configuration (see synchronizer's Config options).
	 * @returns {JW.AbstractCollection.Lister}
	 * `&lt;T, JW.AbstractCollection&lt;T&gt;&gt;` Synchronizer.
	 */
});
</pre>
</body>
</html>
