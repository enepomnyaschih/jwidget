Ext.data.JsonP.ruphilosophy({"guide":"<h1 id='ruphilosophy-section-%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F-jwidget'>Философия jWidget</h1>\n\n<p>Ниже приведены общие правила, из которых складывается философия фреймворка jWidget.</p>\n\n<p><strong>Модель и представление</strong></p>\n\n<ol>\n<li>Все основные классы приложения делятся на модель (model) и представление (view).</li>\n<li>Классы модели хранят данные. Все данные хранятся в модели. Классы модели наследуются от <a href=\"#!/guide/rujwclass\">JW.Class</a>.</li>\n<li>Классы представления (компоненты) выводят информацию на экран. Классы представления наследуются от <a href=\"#!/guide/rujwuicomponent\">JW.UI.Component</a>.</li>\n<li>Компонент имеет прямую ссылку на соответствующие модели. При действии пользователя компонент вызывает\nсоответствующий метод модели, чтобы изменить ее.</li>\n<li>Модель не имеет прямых ссылок на представление, но выбрасывает события о своем изменении.</li>\n<li>Представление прослушивает события модели для того, чтобы вовремя обновляться.</li>\n</ol>\n\n\n<p><strong>Уничтожение объектов</strong></p>\n\n<ol>\n<li>Все объекты нужно уничтожать, когда они больше не нужны, чтобы освободить ресурсы и отписаться от событий.</li>\n<li>Уничтожает объект тот, кто спровоцировал его создание.</li>\n<li>Уничтожать объекты желательно с помощью механизма агрегации, реализуемого методом <a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>, или с помощью\nвстроенных возможностей классов:\n\n<ul>\n<li>Метод <a href=\"#!/api/JW.Property-method-ownValue\" rel=\"JW.Property-method-ownValue\" class=\"docClass\">JW.Property.ownValue</a></li>\n<li>Метод <a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">JW.AbstractCollection.ownItems</a></li>\n<li>Конфигурационные опции <a href=\"#!/api/JW.Switcher-cfg-done\" rel=\"JW.Switcher-cfg-done\" class=\"docClass\">JW.Switcher.done</a> и <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-destroyItem\" rel=\"JW.AbstractCollection.Mapper-cfg-destroyItem\" class=\"docClass\">JW.AbstractCollection.Mapper.destroyItem</a></li>\n</ul>\n</li>\n<li>В некоторых случаях объект можно уничтожать явно методом <a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>.</li>\n</ol>\n\n\n<p><strong>Data binding</strong></p>\n\n<ol>\n<li>Объекты и DOM-элементы никогда не пересоздаются без причины, а только обновляются путем data binding'а.</li>\n<li>Data binding одиночных значений осуществляется с помощью класса <a href=\"#!/guide/rujwproperty\">JW.Property</a> и его хелперов.</li>\n</ol>\n\n\n<p><strong>Data binding коллекций</strong></p>\n\n<ol>\n<li>Данные и компоненты структурированы на базе трех классов коллекций:\nмассивов (<a href=\"#!/guide/rujwabstractarray\">JW.AbstractArray</a>),\nсловарей (<a href=\"#!/guide/rujwabstractmap\">JW.AbstractMap</a>) и\nмножеств (<a href=\"#!/guide/rujwabstractset\">JW.AbstractSet</a>). Все коллекции имеют общие интерфейсы\n(<a href=\"#!/guide/rujwabstractcollection\">JW.AbstractCollection</a>,\n<a href=\"#!/guide/rujwindexedcollection\">JW.IndexedCollection</a>). О сфере использования, преимуществах и недостатках каждой\nколлекции читайте общую теорию алгоритмов и структур данных.</li>\n<li>Каждая коллекция имеет две реализации: простая (<a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>, <a href=\"#!/api/JW.Map\" rel=\"JW.Map\" class=\"docClass\">JW.Map</a>, <a href=\"#!/api/JW.Set\" rel=\"JW.Set\" class=\"docClass\">JW.Set</a>) и оповещающая\n(<a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, <a href=\"#!/api/JW.ObservableMap\" rel=\"JW.ObservableMap\" class=\"docClass\">JW.ObservableMap</a>, <a href=\"#!/api/JW.ObservableSet\" rel=\"JW.ObservableSet\" class=\"docClass\">JW.ObservableSet</a>). Оповещающие коллекции выбрасывают события о своем изменении.</li>\n<li>Не нужно прослушивать все события оповещающих коллекций вручную. Вместо этого предлагается использовать\nстандартные <a href=\"#!/guide/rujwabstractcollection\">синхронизаторы jWidget</a>. Синхронизаторы позволяют наладить связь между коллекциями.</li>\n<li>Коллекции замкнуты относительно синхронизаторов. Всякое изменение одной коллекции влечет не более одного\nизменения другой коллекции, связанной с первой с помощью стандартного синхронизатора.</li>\n<li>Почти на всякое действие пользователя должно производиться одно ручное изменение некоторой коллекции.\nВсе остальные коллекции (включая коллекции компонентов представления) должны синхронизироваться автоматически\nс помощью синхронизаторов.</li>\n<li>Для правильной и быстрой работы приложения достаточно один раз правильно сконфигурировать синхронизаторы по\nаналогии с тем, как конфигурируются индексы и внешние ключи таблиц баз данных.</li>\n</ol>\n\n","title":"Философия jWidget"});