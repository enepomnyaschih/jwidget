Ext.data.JsonP.JW_UI_Component({"tagname":"class","name":"JW.UI.Component","autodetected":{},"files":[{"filename":"component.js","href":"component2.html#JW-UI-Component"}],"extends":"JW.Class","members":[{"name":"_iid","tagname":"property","owner":"JW.Class","id":"property-_iid","meta":{}},{"name":"allChildren","tagname":"property","owner":"JW.UI.Component","id":"property-allChildren","meta":{}},{"name":"children","tagname":"property","owner":"JW.UI.Component","id":"property-children","meta":{}},{"name":"constructor","tagname":"property","owner":"JW.Class","id":"property-constructor","meta":{}},{"name":"destroyed","tagname":"property","owner":"JW.UI.Component","id":"property-destroyed","meta":{}},{"name":"el","tagname":"property","owner":"JW.UI.Component","id":"property-el","meta":{}},{"name":"parent","tagname":"property","owner":"JW.UI.Component","id":"property-parent","meta":{}},{"name":"replacedEl","tagname":"property","owner":"JW.UI.Component","id":"property-replacedEl","meta":{}},{"name":"templates","tagname":"property","owner":"JW.UI.Component","id":"property-templates","meta":{}},{"name":"wasAfterAppend","tagname":"property","owner":"JW.UI.Component","id":"property-wasAfterAppend","meta":{}},{"name":"constructor","tagname":"method","owner":"JW.UI.Component","id":"method-constructor","meta":{}},{"name":"_super","tagname":"method","owner":"JW.Class","id":"method-_super","meta":{}},{"name":"addArray","tagname":"method","owner":"JW.UI.Component","id":"method-addArray","meta":{}},{"name":"afterAppend","tagname":"method","owner":"JW.UI.Component","id":"method-afterAppend","meta":{}},{"name":"beforeRender","tagname":"method","owner":"JW.UI.Component","id":"method-beforeRender","meta":{}},{"name":"destroy","tagname":"method","owner":"JW.Class","id":"method-destroy","meta":{}},{"name":"destroyComponent","tagname":"method","owner":"JW.UI.Component","id":"method-destroyComponent","meta":{}},{"name":"getElement","tagname":"method","owner":"JW.UI.Component","id":"method-getElement","meta":{}},{"name":"remove","tagname":"method","owner":"JW.UI.Component","id":"method-remove","meta":{}},{"name":"removeElement","tagname":"method","owner":"JW.UI.Component","id":"method-removeElement","meta":{}},{"name":"render","tagname":"method","owner":"JW.UI.Component","id":"method-render","meta":{}},{"name":"renderAs","tagname":"method","owner":"JW.UI.Component","id":"method-renderAs","meta":{}},{"name":"renderComponent","tagname":"method","owner":"JW.UI.Component","id":"method-renderComponent","meta":{}},{"name":"renderTo","tagname":"method","owner":"JW.UI.Component","id":"method-renderTo","meta":{}},{"name":"setElement","tagname":"method","owner":"JW.UI.Component","id":"method-setElement","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-JW.UI.Component","short_doc":"Базовый класс визуального компонента. ...","component":false,"superclasses":["JW.Class"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'><a href='#!/api/JW.Class' rel='JW.Class' class='docClass'>JW.Class</a><div class='subclass '><strong>JW.UI.Component</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/component2.html#JW-UI-Component' target='_blank'>component.js</a></div></pre><div class='doc-contents'><p>Базовый класс визуального компонента.</p>\n\n<p>Возможности:</p>\n\n<ul>\n<li>Рендеринг по HTML-шаблону</li>\n<li>Прямой доступ к элементам компонента</li>\n<li><a href=\"http://api.jquery.com/\">jQuery-интерфейс</a> для работы с элементами</li>\n<li>Удобный интерфейс для создания дочерних компонентов</li>\n</ul>\n\n\n<p>У компонента jWidget очень простой интерфейс, но довольно нетипичная философия, обеспечивающая полное соблюдение\nметодики Model-View без особых усилий. Поэтому начнем с примеров.</p>\n\n<h3>Пример jWidget UI-компонента</h3>\n\n<pre><code>// Объявляем пространство имен\nvar MyApp = {};\n\n// Объявляем конструктор компонента\nMyApp.Component = function(message, link) {\n    MyApp.Component._super.call(this);\n    this.message = message;\n    this.link = link;\n};\n\n// Наследуем от <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyApp.Component, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // String message;\n    // String link;\n\n    // override\n    renderComponent: function() {\n        this._super();\n        this.getElement(\"hello-message\").text(message);\n        this.getElement(\"link\").attr(\"href\", this.link);\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyApp.Component, {\n    main:\n        '&lt;div jwclass=\"myapp-component\"&gt;' +\n            '&lt;div jwid=\"hello-message\" /&gt;' +\n            '&lt;a href=\"#\" jwid=\"link\"&gt;Click me!&lt;/a&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p>Сначала рассмотрим, как работает HTML-шаблон. У каждого компонента есть основной шаблон, который описывается в\nфункции <a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>, имеет название <code>main</code> и по умолчанию равен\n<code>&lt;div /&gt;</code>. Можно добавить и другие шаблоны, они будут доступны в компоненте через поле\n<code><a href=\"#!/api/JW.UI.Component-property-templates\" rel=\"JW.UI.Component-property-templates\" class=\"docClass\">this.templates</a>.&lt;название_шаблона&gt;</code> (но они, как правило, не используются).</p>\n\n<p>Обратите внимание на специальные атрибуты <code>jwclass</code> и <code>jwid</code>. <code>jwclass</code> - это корневой CSS-класс компонента,\nа <code>jwid</code> - это приставка к <code>jwclass</code> в данном элементе. Так, в результате рендеринга этого компонента получится\nследующий фрагмент HTML:</p>\n\n<pre><code>&lt;div class=\"myapp-component\"&gt;\n    &lt;div class=\"myapp-component-hello-message\" /&gt;\n    &lt;a href=\"#\" class=\"myapp-component-link\"&gt;Click me!&lt;/a&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Элементы, для которых указан атрибут <code>jwid</code>, могут быть мгновенно получены методом <a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>. Результатом вызова\nэтого метода будет <a href=\"http://api.jquery.com/\">jQuery-обертка</a> над соответствующим элементом. Кроме того, у каждого\nкомпонента всегда есть поле <a href=\"#!/api/JW.UI.Component-property-el\" rel=\"JW.UI.Component-property-el\" class=\"docClass\">el</a>, которое ссылается на корневой jQuery-элемент компонента.</p>\n\n<h3>Создание компонента в коде</h3>\n\n<p>Компонент создается конструированием объекта соответствующего класса. Далее, пользуясь методом <a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>\nили <a href=\"#!/api/JW.UI.Component-method-renderAs\" rel=\"JW.UI.Component-method-renderAs\" class=\"docClass\">renderAs</a>, можно вставить компонент в DOM.</p>\n\n<pre><code>var component;\n\njQuery(function() {\n    component = new MyApp.Component(\"Hello world!\", \"http://google.com\");\n    component.renderTo(\"body\");\n});\n</code></pre>\n\n<h3>Дочерние компоненты</h3>\n\n<p>Есть 3 способа добавить дочерний компонент:</p>\n\n<ul>\n<li>Добавить компонент в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> с ключом, равным <code>jwid</code> элемента, вместо которого вы хотите вставить\nдочерний компонент. Как правило, это делается в методе <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>.</li>\n<li>Добавить список дочерних компонентов внутрь какого-то элемента вызовом метода <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>. Если переданный массив\nявляется <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, то фреймворк обеспечит непрерывную синхронизацию с этим массивом в ходе работы\nприложения.</li>\n<li>Определить метод <code>render&lt;ChildId&gt;</code>, где <code>&lt;ChildId&gt;</code> - это <code>jwid</code> элемента,\nзаписанный в CamelCase с заглавной буквы. Пример: <code>renderArticle</code> (рендерит элемент с <code>jwid=\"article\"</code>).\nЕсли метод вернет <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a> или <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, то результат станет дочерним компонентом или списком\nдочерних компонентов соответственно. Подробнее читайте в следующем разделе.</li>\n</ul>\n\n\n<p>Такой интерфейс обеспечивает краткость, с одной стороны, и гибкость в плане соблюдения методики Model-View,\nс другой стороны.</p>\n\n<p><a href=\"#!/guide/sample1\">Учебник. Часть 1. Модель и представление</a></p>\n\n<h3>Подробнее о списках дочерних компонентов</h3>\n\n<p>Для создания дочерних компонентов на основе массивов данных очень удобно использовать конвертеры элементов\n<a href=\"#!/api/JW.AbstractCollection.Mapper\" rel=\"JW.AbstractCollection.Mapper\" class=\"docClass\">JW.AbstractCollection.Mapper</a> и другие синхронизаторы. Благодаря им представление будет реагировать на любые\nизменения в модели автоматически.</p>\n\n<p>Именно по этой причине в модели рекомендуется использовать <a href=\"#!/api/JW.AbstractCollection\" rel=\"JW.AbstractCollection\" class=\"docClass\">коллекции jWidget</a> вместо\nнативных Array и Object: эти коллекции имеют Observable-реализации и синхронизаторы.</p>\n\n<p><a href=\"#!/guide/sample5\">Учебник. Часть 5. Синхронизаторы коллекций</a></p>\n\n<h3>Подробнее о методе render&lt;ChildId&gt;</h3>\n\n<p>Для каждого <code>jwid</code> в HTML-шаблоне компонента можно определить метод <code>render&lt;ChildId&gt;</code>, где <code>&lt;ChildId&gt;</code> равен этому\n<code>jwid</code>, записанному в CamelCase с заглавной буквы. Сигнатура метода:</p>\n\n<p><code>renderChildId(el: <a href=\"http://api.jquery.com/\">jQuery</a>): Mixed</code></p>\n\n<p><code>el</code> - элемент с данным <code>jwid</code>.</p>\n\n<p>В зависимости от возвращаемого значения доступны следующие варианты:</p>\n\n<ul>\n<li>Если метод вернет экземпляр <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, то он будет добавлен в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> с ключом, равным <code>jwid</code>,\nи станет дочерним компонентом.</li>\n<li>Если метод вернет экземпляр <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, то он будет добавлен как список дочерних компонентов\nметодом <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>.</li>\n<li>Если метод вернет строго false (===), то элемент будет удален.</li>\n<li>В любом другом случае никаких дополнительных действий выполнено не будет.</li>\n</ul>\n\n\n<h3>Удаление и уничтожение компонентов</h3>\n\n<p>Чтобы уничтожить компонент, нужно вызвать метод <a href=\"#!/api/JW.UI.Component-method-destroy\" rel=\"JW.UI.Component-method-destroy\" class=\"docClass\">destroy</a>. При этом компонент не должен состоять в качестве\nдочернего компонента внутри какого-то другого компонента (в таком случае будет выброшено исключение). Чтобы удалить\nкомпонент из родителя, нужно произвести операцию, обратную операции добавления. Так, для удаления компонента\nс <code>jwid=\"comments\"</code> нужно вызвать метод <a href=\"#!/api/JW.AbstractMap-method-remove\" rel=\"JW.AbstractMap-method-remove\" class=\"docClass\">JW.AbstractMap.remove</a> объекта <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>. При желании\nможно тут же этот компонент уничтожить:</p>\n\n<pre><code>this.children.remove(\"comments\").destroy();\n</code></pre>\n\n<p>При этом элемент с соответствующим <code>jwid</code> вернется в свое изначальное состояние, каким оно было до добавления\nдочернего компонента.</p>\n\n<p><strong>Замечание:</strong> Если вы попытаетесь уничтожить дочерний компонент до его удаления из родителя, возникнет исключение.</p>\n\n<p>Со списками дочерних компонентов все чуть-чуть сложнее. Метод <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a> возвращает экземпляр класса\n<a href=\"#!/api/JW.UI.Component.Array\" rel=\"JW.UI.Component.Array\" class=\"docClass\">JW.UI.Component.Array</a>. Если его уничтожить, список меток будет удален из родительского компонента:</p>\n\n<pre><code>    // override\n    renderComponent: function() {\n        this._labelMapper = this.labels.createMapper({\n            createItem: function(label) { return new LabelView(label); },\n            destroyItem: <a href=\"#!/api/JW-static-method-destroy\" rel=\"JW-static-method-destroy\" class=\"docClass\">JW.destroy</a>,\n            scope: this\n        });\n        // Добавляем метки внутрь элемента с jwid \"labels\"\n        this._labelArray = this.addArray(this._labelMapper.target, \"labels\");\n    },\n\n    clearLabels: function() {\n        this._labelArray.destroy();\n    }\n</code></pre>\n\n<p><strong>Замечание:</strong> Внутри метода <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a> все списки уже уничтожены, т.е. все такие дочерние компоненты уже\nудалены из родителя. Но сами дочерние компоненты еще не уничтожены, для этого мы запускаем уничтожение\nсинхронизатора:</p>\n\n<pre><code>    // override\n    destroyComponent: function() {\n        // В destroyComponent уничтожаем синхронизатор\n        this._labelMapper.destroy();\n        this._super();\n    }\n</code></pre>\n\n<p>Строчка <code>this._labelMapper.destroy()</code> уничтожит все представления меток.</p>\n\n<h3>Жизненный цикл компонента</h3>\n\n<p>Каждый компонент проходит несколько этапов жизненного цикла.</p>\n\n<ol>\n<li>Как и у всех классов, сначала вызывается *конструктор*. Здесь обычно объявляются все поля, устанавливаются их\nизначальные значения, создаются события и т.п. Здесь осуществляется работа только с моделью компонента,\nа представление не затрагивается. Заметим, что после конструирования компонент еще не отрендерен, т.е. у него нет\nполя <a href=\"#!/api/JW.UI.Component-property-el\" rel=\"JW.UI.Component-property-el\" class=\"docClass\">el</a> и словаря <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>, не будет работать метод <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>. Это сделано для того, чтобы между\nконструированием и рендерингом компонента еще была возможность поменять какие-нибудь поля или вызвать\nкакие-нибудь методы. Вторая причина: в любом объектно-ориентированном языке вызывать виртуальные методы\nв конструкторе не рекомендуется. Рендеринг можно осуществить напрямую вызовом метода <a href=\"#!/api/JW.UI.Component-method-render\" rel=\"JW.UI.Component-method-render\" class=\"docClass\">render</a>, <a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>, <a href=\"#!/api/JW.UI.Component-method-renderAs\" rel=\"JW.UI.Component-method-renderAs\" class=\"docClass\">renderAs</a>,\nлибо добавив компонент внутрь другого компонента. Например, после добавления в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> компонент будет\nотрендерен. Можете вызывать рендеринг компонента несколько раз: отрендерен он будет лишь при первом запуске.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-beforeRender\" rel=\"JW.UI.Component-method-beforeRender\" class=\"docClass\">beforeRender</a> вызывается во время рендеринга, после чтения HTML-шаблона и инициализации ссылок на все\nэлементы этого шаблона. Здесь удобно произвести какие-то предварительные действия перед созданием дочерних\nкомпонентов. Добавлять дочерние компоненты уже можно. Вызов <code>this._super()</code> осуществляется в начале\nметода.</li>\n<li>Вызываются все методы <code>render&lt;ChildId&gt;</code> для элементов HTML-шаблона, т.е. начинается создание\nдочерних компонентов.</li>\n<li>Вызывается метод <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>. Здесь следует присваивать атрибуты элементов, создавать дочерние компоненты,\nподписываться на события и наделять компонент поведением. Вызов <code>this._super()</code> осуществляется в\nначале метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-afterAppend\" rel=\"JW.UI.Component-method-afterAppend\" class=\"docClass\">afterAppend</a> вызывается после того, как компонент был впервые добавлен в HTML DOM и дерево\nвизуальных компонентов. Здесь удобно осуществлять лайаутинг компонента (вычислять размеры элементов).\nЗдесь заканчивается рендеринг компонента. Вызов <code>this._super()</code> осуществляется в начале метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a> служит для уничтожения компонента. Здесь откатывается все, что было сделано во время\nрендеринга компонента, т.е. на шагах 2-5. При вызове этого метода все списки дочерних компонентов, добавленные\nчерез метод <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>, уже удалены, но еще не уничтожены. Уничтожать их надо явно. Напротив, дочерние компоненты,\nсостоящие в <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> нужно удалить оттуда вручную, если вы не хотите, чтобы они были уничтожены.\nВызов <code>this._super()</code> осуществляется в конце метода.</li>\n<li>Деструктор <a href=\"#!/api/JW.UI.Component-method-destroy\" rel=\"JW.UI.Component-method-destroy\" class=\"docClass\">destroy</a>. Здесь откатываем все, что было сделано в конструкторе класса. Как правило, этот метод для\nкомпонентов не перегружается: все необходимое делается в методе <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a>.</li>\n</ol>\n\n\n<h3>Интеграция с jWidget SDK</h3>\n\n<p>Библиотека jWidget идеально интегрируется с <a href=\"https://github.com/enepomnyaschih/jwsdk/wiki/ru\">jWidget SDK</a>, что\nдает хорошую оптимизацию JS-кода и возможность выносить HTML-шаблоны в отдельные файлы. Например, самый первый\nпример можно упростить, разбив на 2 файла:</p>\n\n<p><strong>component.js</strong></p>\n\n<pre><code>// Объявляем пространство имен\nvar MyApp = {};\n\n// Объявляем конструктор компонента\nMyApp.Component = function(message, link) {\n    MyApp.Component._super.call(this);\n    this.message = message;\n    this.link = link;\n};\n\n// Наследуем от <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyApp.Component, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // String message;\n    // String link;\n\n    // override\n    renderComponent: function() {\n        this._super();\n        this.getElement(\"hello-message\").text(message);\n        this.getElement(\"link\").attr(\"href\", this.link);\n    }\n});\n</code></pre>\n\n<p><strong>component.jw.html</strong></p>\n\n<pre><code>&lt;div jwclass=\"myapp-component\"&gt;\n    &lt;div jwid=\"hello-message\" /&gt;\n    &lt;a href=\"#\" jwid=\"link\"&gt;Click me!&lt;/a&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Чтобы это заработало, достаточно прописать следующие ресурсы в соответствующем пакете jWidget SDK:</p>\n\n<pre><code>{\n    \"resources\" : [\n        \"component.js\",\n        \"component.jw.html : MyApp.Component\",\n        ...\n    ]\n}\n</code></pre>\n\n<p>Естественно, вы можете использовать jWidget и без jWidget SDK, но тогда HTML-шаблоны придется либо загружать\nдинамически, либо описывать явно в исходном JavaScript-коде с использованием функции <a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>.</p>\n\n<p>Более полный пример смотрите здесь:</p>\n\n<p><a href=\"#!/guide/sample6\">Учебник. Часть 6. Инфраструктура проекта</a></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-property'>Properties</h3><div class='subsection'><div id='property-_iid' class='member first-child inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/JW.Class' rel='JW.Class' class='defined-in docClass'>JW.Class</a><br/><a href='source/class.html#JW-Class-property-_iid' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.Class-property-_iid' class='name expandable'>_iid</a> : number<span class=\"signature\"></span></div><div class='description'><div class='short'>Instance ID. ...</div><div class='long'><p>Instance ID.</p>\n\n<p>Автоинкрементный уникальный идентификатор объекта. Каждый экземпляр <a href=\"#!/api/JW.Class\" rel=\"JW.Class\" class=\"docClass\">JW.Class</a> получает такой идентификатор.\nИспользуется в множестве <a href=\"#!/api/JW.AbstractSet\" rel=\"JW.AbstractSet\" class=\"docClass\">JW.AbstractSet</a> в качестве ключа словаря для быстрого поиска.</p>\n</div></div></div><div id='property-allChildren' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-property-allChildren' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-property-allChildren' class='name expandable'>allChildren</a> : Object<span class=\"signature\"></span></div><div class='description'><div class='short'>Множество всех дочерних компонентов (включая именованные и состоящие в списках). ...</div><div class='long'><p>Множество всех дочерних компонентов (включая именованные и состоящие в списках).\nПоле доступно только с начала рендеринга компонента.</p>\n</div></div></div><div id='property-children' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-property-children' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-property-children' class='name expandable'>children</a> : <a href=\"#!/api/JW.ObservableMap\" rel=\"JW.ObservableMap\" class=\"docClass\">JW.ObservableMap</a><span class=\"signature\"></span></div><div class='description'><div class='short'>&lt;JW.UI.Component&gt; (mutable) Именованные дочерние компоненты. ...</div><div class='long'><p><code>&lt;<a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>&gt;</code> (mutable) Именованные дочерние компоненты. Используйте этот словарь, чтобы добавлять\nдочерние компоненты на место элементов с соответствующими jwid.\nПоле доступно только с начала рендеринга компонента.</p>\n</div></div></div><div id='property-constructor' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/JW.Class' rel='JW.Class' class='defined-in docClass'>JW.Class</a><br/><a href='source/class.html#JW-Class-property-constructor' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.Class-property-constructor' class='name expandable'>constructor</a> : Function<span class=\"signature\"></span></div><div class='description'><div class='short'>Конструктор как класс. ...</div><div class='long'><p>Конструктор как класс. Если в вашем распоряжении есть некоторый объект, то вы с легкостью можете узнать его класс\nвоспользовавшись полем <a href=\"#!/api/JW.Class-property-constructor\" rel=\"JW.Class-property-constructor\" class=\"docClass\">constructor</a>.</p>\n</div></div></div><div id='property-destroyed' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-property-destroyed' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-property-destroyed' class='name expandable'>destroyed</a> : boolean<span class=\"signature\"></span></div><div class='description'><div class='short'><p>Уничтожен ли компонент.</p>\n</div><div class='long'><p>Уничтожен ли компонент.</p>\n</div></div></div><div id='property-el' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-property-el' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-property-el' class='name expandable'>el</a> : <a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a><span class=\"signature\"></span></div><div class='description'><div class='short'>Корневой элемент. ...</div><div class='long'><p>Корневой элемент.\nПоле доступно только с начала рендеринга компонента.</p>\n</div></div></div><div id='property-parent' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-property-parent' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-property-parent' class='name expandable'>parent</a> : <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a><span class=\"signature\"></span></div><div class='description'><div class='short'>Родительский компонент. ...</div><div class='long'><p>Родительский компонент.\nПоле доступно только с начала рендеринга компонента.</p>\n</div></div></div><div id='property-replacedEl' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-property-replacedEl' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-property-replacedEl' class='name expandable'>replacedEl</a> : <a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a><span class=\"signature\"></span></div><div class='description'><div class='short'>Элемент, на место которого отрендерен компонент. ...</div><div class='long'><p>Элемент, на место которого отрендерен компонент. Автоматически присваивается в момент добавления в\nсловарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> родительского компонента.\nПоле доступно только с начала рендеринга компонента.</p>\n</div></div></div><div id='property-templates' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-property-templates' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-property-templates' class='name expandable'>templates</a> : Object<span class=\"signature\"></span></div><div class='description'><div class='short'>Словарь из ID шаблона в шаблон. ...</div><div class='long'><p>Словарь из ID шаблона в шаблон. Шаблоны определяются методом <a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>.</p>\n</div></div></div><div id='property-wasAfterAppend' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-property-wasAfterAppend' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-property-wasAfterAppend' class='name expandable'>wasAfterAppend</a> : boolean<span class=\"signature\"></span></div><div class='description'><div class='short'><p>Вызван ли уже <a href=\"#!/api/JW.UI.Component-method-afterAppend\" rel=\"JW.UI.Component-method-afterAppend\" class=\"docClass\">afterAppend</a>.</p>\n</div><div class='long'><p>Вызван ли уже <a href=\"#!/api/JW.UI.Component-method-afterAppend\" rel=\"JW.UI.Component-method-afterAppend\" class=\"docClass\">afterAppend</a>.</p>\n</div></div></div></div></div><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-constructor' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-constructor' target='_blank' class='view-source'>view source</a></div><strong class='new-keyword'>new</strong><a href='#!/api/JW.UI.Component-method-constructor' class='name expandable'>JW.UI.Component</a>( <span class='pre'></span> ) : <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a><span class=\"signature\"></span></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-_super' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/JW.Class' rel='JW.Class' class='defined-in docClass'>JW.Class</a><br/><a href='source/class.html#JW-Class-method-_super' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.Class-method-_super' class='name expandable'>_super</a>( <span class='pre'></span> ) : Mixed<span class=\"signature\"></span></div><div class='description'><div class='short'>Этот метод доступен только внутри методов класса, переданных в функцию JW.extend при создании данного класса. ...</div><div class='long'><p>Этот метод доступен только внутри методов класса, переданных в функцию <a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a> при создании данного класса. Метод\n<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a> - это простой способ вызова того же метода базового класса:</p>\n\n<pre><code>...\n// Метод класса\nmyMethod: function(a, b, c) {\n    return this._super(a, b) + c;\n}\n...\n</code></pre>\n\n<p>Эквивалентный вариант:</p>\n\n<pre><code>...\n// Метод класса\nmyMethod: function(a, b, c) {\n    return MyClass.superclass.myMethod.call(this, a, b) + c;\n}\n...\n</code></pre>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>Mixed</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-addArray' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-addArray' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-addArray' class='name expandable'>addArray</a>( <span class='pre'>components, [el]</span> ) : <a href=\"#!/api/JW.UI.Component.Array\" rel=\"JW.UI.Component.Array\" class=\"docClass\">JW.UI.Component.Array</a><span class=\"signature\"></span></div><div class='description'><div class='short'>Добавить список дочерних компонентов в указанный элемент. ...</div><div class='long'><p>Добавить список дочерних компонентов в указанный элемент.</p>\n\n<p>Работает на базе синхронизатора <a href=\"#!/api/JW.AbstractArray.Inserter\" rel=\"JW.AbstractArray.Inserter\" class=\"docClass\">JW.AbstractArray.Inserter</a>. Благодаря этому, если в качестве аргумента\ncomponents передать <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, то представление будет налету синхронизироваться с содержимым\nэтого массива.</p>\n\n<p>Массив components удобно создавать на основе данных с помощью метода <a href=\"#!/api/JW.AbstractArray-method-createMapper\" rel=\"JW.AbstractArray-method-createMapper\" class=\"docClass\">JW.AbstractArray.createMapper</a>\nмассива данных, т.е. путем создания конвертера элементов <a href=\"#!/api/JW.AbstractCollection.Mapper\" rel=\"JW.AbstractCollection.Mapper\" class=\"docClass\">JW.AbstractCollection.Mapper</a>.</p>\n\n<p>Метод возвращает объект класса <a href=\"#!/api/JW.UI.Component.Array\" rel=\"JW.UI.Component.Array\" class=\"docClass\">JW.UI.Component.Array</a>. Этот объект предназначен для удаления списка дочерних\nкомпонентов из родительского компонента. Делается это путем его уничтожения методом\n<a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>. Помимо этого, список будет автоматически удален при уничтожении\nродительского компонента непосредственно перед вызовом метода <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a>.\nДочерние компоненты внутри списка при этом уничтожены не будут - обычно это делается в\nметоде <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a> путем уничтожения соответствующего <a href=\"#!/api/JW.AbstractCollection.Mapper\" rel=\"JW.AbstractCollection.Mapper\" class=\"docClass\">JW.AbstractCollection.Mapper</a>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>components</span> : <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a><div class='sub-desc'><p>Массив дочерних компонентов.</p>\n</div></li><li><span class='pre'>el</span> : <a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a>/string (optional)<div class='sub-desc'><p>Элемент, внутрь которого добавить дочерние компоненты, или его jwid.\nПо умолчанию, добавляется в корневой элемент родительского компонента.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/JW.UI.Component.Array\" rel=\"JW.UI.Component.Array\" class=\"docClass\">JW.UI.Component.Array</a></span><div class='sub-desc'><p>Список дочерних компонентов.</p>\n</div></li></ul></div></div></div><div id='method-afterAppend' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-afterAppend' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-afterAppend' class='name expandable'>afterAppend</a>( <span class='pre'></span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Метод жизненного цикла компонента. ...</div><div class='long'><p>Метод жизненного цикла компонента. Вызывается после того, как компонент был впервые добавлен в HTML DOM и\nдерево визуальных компонентов. Здесь удобно осуществлять лайаутинг компонента (вычислять размеры элементов).\nЗдесь заканчивается рендеринг компонента. Вызов <code>this._super()</code> осуществляется в начале метода.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-beforeRender' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-beforeRender' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-beforeRender' class='name expandable'>beforeRender</a>( <span class='pre'></span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Метод жизненного цикла компонента. ...</div><div class='long'><p>Метод жизненного цикла компонента. Вызывается в момент рендеринга компонента после чтения HTML-шаблона и\nинициализации ссылок на все элементы этого шаблона, и до вызова методов вида <code>render&lt;ChildId&gt;</code> и метода</p>\n\n<h1>renderComponent. Здесь удобно произвести какие-то предварительные действия перед созданием дочерних</h1>\n\n<p>компонентов. Добавлять дочерние компоненты уже можно. Вызов <code>this._super()</code> осуществляется в\nначале метода.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-destroy' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/JW.Class' rel='JW.Class' class='defined-in docClass'>JW.Class</a><br/><a href='source/class.html#JW-Class-method-destroy' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.Class-method-destroy' class='name expandable'>destroy</a>( <span class='pre'></span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Деструктор класса. ...</div><div class='long'><p>Деструктор класса. Сюда рекомендуется помещать всю логику уничтожения экземпляра класса. Этот метод нужно явно\nвызывать снаружи, поскольку JavaScript не поддерживает автоматические деструкторы классов. Этот метод можно\nперегружать, не забывая вызывать деструктор базового класса:</p>\n\n<pre><code>destroy: function() {\n    // Освобождаем ресурсы\n    ...\n    // Вызываем деструктор базового класса\n    this._super();\n}\n</code></pre>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-destroyComponent' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-destroyComponent' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-destroyComponent' class='name expandable'>destroyComponent</a>( <span class='pre'></span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Метод жизненного цикла компонента. ...</div><div class='long'><p>Метод жизненного цикла компонента. Служит для уничтожения компонента. Здесь откатывается все, что было сделано\nво время рендеринга компонента, т.е. в\nметодах <a href=\"#!/api/JW.UI.Component-method-beforeRender\" rel=\"JW.UI.Component-method-beforeRender\" class=\"docClass\">beforeRender</a>, <code>render&lt;ChildId&gt;</code>, <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a> и <a href=\"#!/api/JW.UI.Component-method-afterAppend\" rel=\"JW.UI.Component-method-afterAppend\" class=\"docClass\">afterAppend</a>.\nПри вызове этого метода все списки дочерних компонентов, добавленные через метод <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>, уже\nудалены, но еще не уничтожены. Уничтожать их надо явно. Напротив, дочерние компоненты, состоящие в <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>\nнужно удалить оттуда вручную, если вы не хотите, чтобы они были уничтожены. Это обосновано работой\nсинхронизаторов. Вызов <code>this._super()</code> осуществляется в конце метода.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-getElement' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-getElement' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-getElement' class='name expandable'>getElement</a>( <span class='pre'>jwid</span> ) : <a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a><span class=\"signature\"></span></div><div class='description'><div class='short'>Получить элемент по jwid. ...</div><div class='long'><p>Получить элемент по <code>jwid</code>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>jwid</span> : string<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a></span><div class='sub-desc'><p>Элемент.</p>\n</div></li></ul></div></div></div><div id='method-remove' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-remove' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-remove' class='name expandable'>remove</a>( <span class='pre'></span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Удалить компонент из DOM. ...</div><div class='long'><p>Удалить компонент из DOM. Предназначен только для удаления корневого компонента. Все дочерние компоненты\nудаляются по-своему: либо путем удаления компонента из словаря <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>, либо путем уничтожения объекта\n<a href=\"#!/api/JW.UI.Component.Array\" rel=\"JW.UI.Component.Array\" class=\"docClass\">JW.UI.Component.Array</a>.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-removeElement' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-removeElement' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-removeElement' class='name expandable'>removeElement</a>( <span class='pre'>jwid</span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Удалить элемент по jwid. ...</div><div class='long'><p>Удалить элемент по <code>jwid</code>. Элемент будет удален из DOM и больше его нельзя будет получить\nметодом <a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>jwid</span> : string<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-render' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-render' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-render' class='name expandable'>render</a>( <span class='pre'>[replacedEl]</span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Отрендерить компонент. ...</div><div class='long'><p>Отрендерить компонент. Вызовите этот метод после конструирования компонента, чтобы инициализировать все\nэлементы и поля компонента. Метод вызывается автоматически:</p>\n\n<ul>\n<li>В методах <a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>, <a href=\"#!/api/JW.UI.Component-method-renderAs\" rel=\"JW.UI.Component-method-renderAs\" class=\"docClass\">renderAs</a></li>\n<li>Если компонент добавлен внутрь другого компонента в качестве дочернего</li>\n</ul>\n\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>replacedEl</span> : <a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a> (optional)<div class='sub-desc'><p>Элемент, на место которого рендерится компонент (если определен).</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-renderAs' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-renderAs' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-renderAs' class='name expandable'>renderAs</a>( <span class='pre'>[el]</span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Отрендерить компонент на место указанного элемента. ...</div><div class='long'><p>Отрендерить компонент на место указанного элемента. Используется только для рендеринга корневого компонента:\nвсе остальные должны добавляться как дочерние компоненты\n(см. соответствующий раздел документации <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>).</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>el</span> : <a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a>/string (optional)<div class='sub-desc'><p>Элемент, на место которого отрендерить компонент, или его CSS-селектор.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-renderComponent' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-renderComponent' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-renderComponent' class='name expandable'>renderComponent</a>( <span class='pre'></span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Метод жизненного цикла компонента. ...</div><div class='long'><p>Метод жизненного цикла компонента. Вызывается в момент рендеринга компонента после вызова метода <a href=\"#!/api/JW.UI.Component-method-beforeRender\" rel=\"JW.UI.Component-method-beforeRender\" class=\"docClass\">beforeRender</a>\nи методов вида <code>render&lt;ChildId&gt;</code>. Здесь следует присваивать атрибуты элементов, создавать дочерние компоненты,\nподписываться на события и наделять компонент поведением. Вызов <code>this._super()</code> осуществляется\nв начале метода.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-renderTo' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-renderTo' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-renderTo' class='name expandable'>renderTo</a>( <span class='pre'>[el]</span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Отрендерить компонент внутрь указанного элемента. ...</div><div class='long'><p>Отрендерить компонент внутрь указанного элемента. Используется только для рендеринга корневого компонента: все\nостальные должны добавляться как дочерние компоненты (см. соответствующий раздел документации <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>).</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>el</span> : <a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a>/string (optional)<div class='sub-desc'><p>Элемент, внутрь которого отрендерить компонент, или его CSS-селектор.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-setElement' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JW.UI.Component'>JW.UI.Component</span><br/><a href='source/component2.html#JW-UI-Component-method-setElement' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JW.UI.Component-method-setElement' class='name expandable'>setElement</a>( <span class='pre'>el, jwid</span> ) : void<span class=\"signature\"></span></div><div class='description'><div class='short'>Заменить/добавить элемент с выбранным jwid. ...</div><div class='long'><p>Заменить/добавить элемент с выбранным <code>jwid</code>.</p>\n\n<p>Метод используется, если HTML-содержимое компонента нефиксировано, но нужно добавить элемент. Например, при\nнаследовании компонента. Добавленный элемент можно использовать для разных целей, в частности, для добавления\nдочерних компонентов.</p>\n\n<p><strong>Замечание:</strong> Метод лишь регистрирует элемент в компоненте. Создавать элемент и добавлять его\nвнутрь другого элемента нужно вручную через <a href=\"http://api.jquery.com/\">jQuery API</a>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>el</span> : <a href=\"#!/api/jQuery\" rel=\"jQuery\" class=\"docClass\">jQuery</a><div class='sub-desc'>\n</div></li><li><span class='pre'>jwid</span> : string<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>void</span><div class='sub-desc'>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});