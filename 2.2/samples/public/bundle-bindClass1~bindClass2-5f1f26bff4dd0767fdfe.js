(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["bindClass1~bindClass2"],{

/***/ "../../main/dist/bindClass.js":
/*!*********************************************!*\
  !*** C:/jwidget/git/main/dist/bindClass.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
MIT License

Copyright (c) 2020 Egor Nepomnyaschih

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Class_1 = __importDefault(__webpack_require__(/*! ./Class */ "../../main/dist/Class.js"));

var Switcher_1 = __importDefault(__webpack_require__(/*! ./Switcher */ "../../main/dist/Switcher.js"));

var ClassNameUpdater = /*#__PURE__*/function (_Class_1$default) {
  _inherits(ClassNameUpdater, _Class_1$default);

  var _super = _createSuper(ClassNameUpdater);

  function ClassNameUpdater(el, property) {
    var _this;

    _classCallCheck(this, ClassNameUpdater);

    _this = _super.call(this);
    _this.el = el;

    _this.own(new Switcher_1.default(property, {
      init: function init(value) {
        return _this.el.addClass(value);
      },
      done: function done(value) {
        return _this.el.removeClass(value);
      }
    }));

    return _this;
  }

  return ClassNameUpdater;
}(Class_1.default);

var ClassUpdater = /*#__PURE__*/function (_Class_1$default2) {
  _inherits(ClassUpdater, _Class_1$default2);

  var _super2 = _createSuper(ClassUpdater);

  function ClassUpdater(el, cls, property) {
    var _this2;

    _classCallCheck(this, ClassUpdater);

    _this2 = _super2.call(this);
    _this2.el = el;
    _this2.cls = cls;
    _this2.property = property;

    _this2._update();

    _this2.own(property.changeEvent.listen(_this2._update, _assertThisInitialized(_this2)));

    return _this2;
  }

  _createClass(ClassUpdater, [{
    key: "_update",
    value: function _update() {
      this.el.toggleClass(this.cls, !!this.property.get());
    }
  }]);

  return ClassUpdater;
}(Class_1.default);

function bindClass(el, a, b) {
  return b != null ? new ClassUpdater(el, a, b) : new ClassNameUpdater(el, a);
}

exports.default = bindClass;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9iaW5kQ2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxJQUFBLE9BQUEsR0FBQSxlQUFBLENBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQSxDQUFBOztBQUVBLElBQUEsVUFBQSxHQUFBLGVBQUEsQ0FBQSxPQUFBLENBQUEsWUFBQSxDQUFBLENBQUE7O0lBRU0sZ0I7Ozs7O0FBQ0wsNEJBQW9CLEVBQXBCLEVBQWdDLFFBQWhDLEVBQTBEO0FBQUE7O0FBQUE7O0FBQ3pEO0FBRG1CLFVBQUEsRUFBQSxHQUFBLEVBQUE7O0FBRW5CLFVBQUssR0FBTCxDQUFTLElBQUksVUFBQSxDQUFBLE9BQUosQ0FBYSxRQUFiLEVBQXVCO0FBQy9CLE1BQUEsSUFBSSxFQUFFLGNBQUEsS0FBSztBQUFBLGVBQUksTUFBSyxFQUFMLENBQVEsUUFBUixDQUFpQixLQUFqQixDQUFKO0FBQUEsT0FEb0I7QUFFL0IsTUFBQSxJQUFJLEVBQUUsY0FBQSxLQUFLO0FBQUEsZUFBSSxNQUFLLEVBQUwsQ0FBUSxXQUFSLENBQW9CLEtBQXBCLENBQUo7QUFBQTtBQUZvQixLQUF2QixDQUFUOztBQUZ5RDtBQU16RDs7O0VBUDZCLE9BQUEsQ0FBQSxPOztJQVV6QixZOzs7OztBQUNMLHdCQUFvQixFQUFwQixFQUF3QyxHQUF4QyxFQUE2RCxRQUE3RCxFQUFvRjtBQUFBOztBQUFBOztBQUNuRjtBQURtQixXQUFBLEVBQUEsR0FBQSxFQUFBO0FBQW9CLFdBQUEsR0FBQSxHQUFBLEdBQUE7QUFBcUIsV0FBQSxRQUFBLEdBQUEsUUFBQTs7QUFFNUQsV0FBSyxPQUFMOztBQUNBLFdBQUssR0FBTCxDQUFTLFFBQVEsQ0FBQyxXQUFULENBQXFCLE1BQXJCLENBQTRCLE9BQUssT0FBakMsaUNBQVQ7O0FBSG1GO0FBSW5GOzs7OzhCQUVjO0FBQ2QsV0FBSyxFQUFMLENBQVEsV0FBUixDQUFvQixLQUFLLEdBQXpCLEVBQThCLENBQUMsQ0FBQyxLQUFLLFFBQUwsQ0FBYyxHQUFkLEVBQWhDO0FBQ0E7Ozs7RUFUeUIsT0FBQSxDQUFBLE87O0FBNEIzQixTQUF3QixTQUF4QixDQUFrQyxFQUFsQyxFQUE4QyxDQUE5QyxFQUFzRCxDQUF0RCxFQUE2RDtBQUM1RCxTQUFRLENBQUMsSUFBSSxJQUFOLEdBQWMsSUFBSSxZQUFKLENBQWlCLEVBQWpCLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCLENBQWQsR0FBMkMsSUFBSSxnQkFBSixDQUFxQixFQUFyQixFQUF5QixDQUF6QixDQUFsRDtBQUNBOztBQUZELE9BQUEsQ0FBQSxPQUFBLEdBQUEsU0FBQSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMjAgRWdvciBOZXBvbW55YXNjaGloXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbmltcG9ydCBCaW5kYWJsZSBmcm9tICcuL0JpbmRhYmxlJztcbmltcG9ydCBDbGFzcyBmcm9tICcuL0NsYXNzJztcbmltcG9ydCBEZXN0cm95YWJsZSBmcm9tICcuL0Rlc3Ryb3lhYmxlJztcbmltcG9ydCBTd2l0Y2hlciBmcm9tICcuL1N3aXRjaGVyJztcblxuY2xhc3MgQ2xhc3NOYW1lVXBkYXRlciBleHRlbmRzIENsYXNzIHtcblx0Y29uc3RydWN0b3IocHJpdmF0ZSBlbDogSlF1ZXJ5LCBwcm9wZXJ0eTogQmluZGFibGU8c3RyaW5nPikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5vd24obmV3IFN3aXRjaGVyKHByb3BlcnR5LCB7XG5cdFx0XHRpbml0OiB2YWx1ZSA9PiB0aGlzLmVsLmFkZENsYXNzKHZhbHVlKSxcblx0XHRcdGRvbmU6IHZhbHVlID0+IHRoaXMuZWwucmVtb3ZlQ2xhc3ModmFsdWUpXG5cdFx0fSkpO1xuXHR9XG59XG5cbmNsYXNzIENsYXNzVXBkYXRlciBleHRlbmRzIENsYXNzIHtcblx0Y29uc3RydWN0b3IocHJpdmF0ZSBlbDogSlF1ZXJ5LCBwcml2YXRlIGNsczogc3RyaW5nLCBwcml2YXRlIHByb3BlcnR5OiBCaW5kYWJsZTxhbnk+KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm93bihwcm9wZXJ0eS5jaGFuZ2VFdmVudC5saXN0ZW4odGhpcy5fdXBkYXRlLCB0aGlzKSk7XG5cdH1cblxuXHRwcml2YXRlIF91cGRhdGUoKSB7XG5cdFx0dGhpcy5lbC50b2dnbGVDbGFzcyh0aGlzLmNscywgISF0aGlzLnByb3BlcnR5LmdldCgpKTtcblx0fVxufVxuXG4vKipcbiAqIFdhdGNoZXMgYm9vbGVhbiBwcm9wZXJ0eSBtb2RpZmljYXRpb24gYW5kIHVwZGF0ZXMgdGhlIHNwZWNpZmllZCBDU1MgY2xhc3MgcHJlc2VuY2UgaW4gdGhlIERPTSBlbGVtZW50LlxuICogQHBhcmFtIGVsIERPTSBlbGVtZW50LlxuICogQHBhcmFtIGNscyBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwYXJhbSBwcm9wZXJ0eSBCb29sZWFuIHByb3BlcnR5IHRvIGJpbmQgQ1NTIGNsYXNzIHRvLlxuICogQHJldHVybnMgQmluZGluZyBvYmplY3QuIFlvdSBtdXN0IGRlc3Ryb3kgaXQgdG8gc3RvcCB0aGUgc3luY2hyb25pemF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQ2xhc3MoZWw6IEpRdWVyeSwgY2xzOiBzdHJpbmcsIHByb3BlcnR5OiBCaW5kYWJsZTxhbnk+KTogRGVzdHJveWFibGU7XG5cbi8qKlxuICogV2F0Y2hlcyBzdHJpbmcgcHJvcGVydHkgbW9kaWZpY2F0aW9uIGFuZCB1cGRhdGVzIENTUyBjbGFzcyBuYW1lIGluIHRoZSBET00gZWxlbWVudC5cbiAqIEBwYXJhbSBlbCBET00gZWxlbWVudC5cbiAqIEBwYXJhbSBjbHMgQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcmV0dXJucyBCaW5kaW5nIG9iamVjdC4gWW91IG11c3QgZGVzdHJveSBpdCB0byBzdG9wIHRoZSBzeW5jaHJvbml6YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRDbGFzcyhlbDogSlF1ZXJ5LCBjbHM6IEJpbmRhYmxlPHN0cmluZz4pOiBEZXN0cm95YWJsZTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRDbGFzcyhlbDogSlF1ZXJ5LCBhOiBhbnksIGI/OiBhbnkpOiBEZXN0cm95YWJsZSB7XG5cdHJldHVybiAoYiAhPSBudWxsKSA/IG5ldyBDbGFzc1VwZGF0ZXIoZWwsIGEsIGIpIDogbmV3IENsYXNzTmFtZVVwZGF0ZXIoZWwsIGEpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQzovandpZGdldC9naXQvbWFpbi9kaXN0L2JpbmRDbGFzcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4sdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDhCQUE4QixtQkFBTyxDQUFDLHlDQUFTOztBQUUvQyxpQ0FBaUMsbUJBQU8sQ0FBQywrQ0FBWTs7QUFFckQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxjQUFjLDJ1SyIsImZpbGUiOiJidW5kbGUtYmluZENsYXNzMX5iaW5kQ2xhc3MyLTVmMWYyNmJmZjRkZDA3NjdmZGZlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxyXG5NSVQgTGljZW5zZVxyXG5cclxuQ29weXJpZ2h0IChjKSAyMDIwIEVnb3IgTmVwb21ueWFzY2hpaFxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuU09GVFdBUkUuXHJcbiovXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIF9faW1wb3J0RGVmYXVsdCA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBDbGFzc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0NsYXNzXCIpKTtcblxudmFyIFN3aXRjaGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vU3dpdGNoZXJcIikpO1xuXG52YXIgQ2xhc3NOYW1lVXBkYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NsYXNzXzEkZGVmYXVsdCkge1xuICBfaW5oZXJpdHMoQ2xhc3NOYW1lVXBkYXRlciwgX0NsYXNzXzEkZGVmYXVsdCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDbGFzc05hbWVVcGRhdGVyKTtcblxuICBmdW5jdGlvbiBDbGFzc05hbWVVcGRhdGVyKGVsLCBwcm9wZXJ0eSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGFzc05hbWVVcGRhdGVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuZWwgPSBlbDtcblxuICAgIF90aGlzLm93bihuZXcgU3dpdGNoZXJfMS5kZWZhdWx0KHByb3BlcnR5LCB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5lbC5hZGRDbGFzcyh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZG9uZTogZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZWwucmVtb3ZlQ2xhc3ModmFsdWUpO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBDbGFzc05hbWVVcGRhdGVyO1xufShDbGFzc18xLmRlZmF1bHQpO1xuXG52YXIgQ2xhc3NVcGRhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2xhc3NfMSRkZWZhdWx0Mikge1xuICBfaW5oZXJpdHMoQ2xhc3NVcGRhdGVyLCBfQ2xhc3NfMSRkZWZhdWx0Mik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoQ2xhc3NVcGRhdGVyKTtcblxuICBmdW5jdGlvbiBDbGFzc1VwZGF0ZXIoZWwsIGNscywgcHJvcGVydHkpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsYXNzVXBkYXRlcik7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMyLmVsID0gZWw7XG4gICAgX3RoaXMyLmNscyA9IGNscztcbiAgICBfdGhpczIucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAgIF90aGlzMi5fdXBkYXRlKCk7XG5cbiAgICBfdGhpczIub3duKHByb3BlcnR5LmNoYW5nZUV2ZW50Lmxpc3RlbihfdGhpczIuX3VwZGF0ZSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpKSk7XG5cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENsYXNzVXBkYXRlciwgW3tcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuICAgICAgdGhpcy5lbC50b2dnbGVDbGFzcyh0aGlzLmNscywgISF0aGlzLnByb3BlcnR5LmdldCgpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xhc3NVcGRhdGVyO1xufShDbGFzc18xLmRlZmF1bHQpO1xuXG5mdW5jdGlvbiBiaW5kQ2xhc3MoZWwsIGEsIGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCA/IG5ldyBDbGFzc1VwZGF0ZXIoZWwsIGEsIGIpIDogbmV3IENsYXNzTmFtZVVwZGF0ZXIoZWwsIGEpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBiaW5kQ2xhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OWlhVzVrUTJ4aGMzTXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk96czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096dEJRWGxDUVN4SlFVRkJMRTlCUVVFc1IwRkJRU3hsUVVGQkxFTkJRVUVzVDBGQlFTeERRVUZCTEZOQlFVRXNRMEZCUVN4RFFVRkJPenRCUVVWQkxFbEJRVUVzVlVGQlFTeEhRVUZCTEdWQlFVRXNRMEZCUVN4UFFVRkJMRU5CUVVFc1dVRkJRU3hEUVVGQkxFTkJRVUU3TzBsQlJVMHNaMEk3T3pzN08wRkJRMHdzTkVKQlFXOUNMRVZCUVhCQ0xFVkJRV2RETEZGQlFXaERMRVZCUVRCRU8wRkJRVUU3TzBGQlFVRTdPMEZCUTNwRU8wRkJSRzFDTEZWQlFVRXNSVUZCUVN4SFFVRkJMRVZCUVVFN08wRkJSVzVDTEZWQlFVc3NSMEZCVEN4RFFVRlRMRWxCUVVrc1ZVRkJRU3hEUVVGQkxFOUJRVW9zUTBGQllTeFJRVUZpTEVWQlFYVkNPMEZCUXk5Q0xFMUJRVUVzU1VGQlNTeEZRVUZGTEdOQlFVRXNTMEZCU3p0QlFVRkJMR1ZCUVVrc1RVRkJTeXhGUVVGTUxFTkJRVkVzVVVGQlVpeERRVUZwUWl4TFFVRnFRaXhEUVVGS08wRkJRVUVzVDBGRWIwSTdRVUZGTDBJc1RVRkJRU3hKUVVGSkxFVkJRVVVzWTBGQlFTeExRVUZMTzBGQlFVRXNaVUZCU1N4TlFVRkxMRVZCUVV3c1EwRkJVU3hYUVVGU0xFTkJRVzlDTEV0QlFYQkNMRU5CUVVvN1FVRkJRVHRCUVVadlFpeExRVUYyUWl4RFFVRlVPenRCUVVaNVJEdEJRVTE2UkRzN08wVkJVRFpDTEU5QlFVRXNRMEZCUVN4UE96dEpRVlY2UWl4Wk96czdPenRCUVVOTUxIZENRVUZ2UWl4RlFVRndRaXhGUVVGM1F5eEhRVUY0UXl4RlFVRTJSQ3hSUVVFM1JDeEZRVUZ2Ump0QlFVRkJPenRCUVVGQk96dEJRVU51Ump0QlFVUnRRaXhYUVVGQkxFVkJRVUVzUjBGQlFTeEZRVUZCTzBGQlFXOUNMRmRCUVVFc1IwRkJRU3hIUVVGQkxFZEJRVUU3UVVGQmNVSXNWMEZCUVN4UlFVRkJMRWRCUVVFc1VVRkJRVHM3UVVGRk5VUXNWMEZCU3l4UFFVRk1PenRCUVVOQkxGZEJRVXNzUjBGQlRDeERRVUZUTEZGQlFWRXNRMEZCUXl4WFFVRlVMRU5CUVhGQ0xFMUJRWEpDTEVOQlFUUkNMRTlCUVVzc1QwRkJha01zYVVOQlFWUTdPMEZCU0cxR08wRkJTVzVHT3pzN096aENRVVZqTzBGQlEyUXNWMEZCU3l4RlFVRk1MRU5CUVZFc1YwRkJVaXhEUVVGdlFpeExRVUZMTEVkQlFYcENMRVZCUVRoQ0xFTkJRVU1zUTBGQlF5eExRVUZMTEZGQlFVd3NRMEZCWXl4SFFVRmtMRVZCUVdoRE8wRkJRMEU3T3pzN1JVRlVlVUlzVDBGQlFTeERRVUZCTEU4N08wRkJORUl6UWl4VFFVRjNRaXhUUVVGNFFpeERRVUZyUXl4RlFVRnNReXhGUVVFNFF5eERRVUU1UXl4RlFVRnpSQ3hEUVVGMFJDeEZRVUUyUkR0QlFVTTFSQ3hUUVVGUkxFTkJRVU1zU1VGQlNTeEpRVUZPTEVkQlFXTXNTVUZCU1N4WlFVRktMRU5CUVdsQ0xFVkJRV3BDTEVWQlFYRkNMRU5CUVhKQ0xFVkJRWGRDTEVOQlFYaENMRU5CUVdRc1IwRkJNa01zU1VGQlNTeG5Ra0ZCU2l4RFFVRnhRaXhGUVVGeVFpeEZRVUY1UWl4RFFVRjZRaXhEUVVGc1JEdEJRVU5CT3p0QlFVWkVMRTlCUVVFc1EwRkJRU3hQUVVGQkxFZEJRVUVzVTBGQlFTSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxWEc1TlNWUWdUR2xqWlc1elpWeHVYRzVEYjNCNWNtbG5hSFFnS0dNcElESXdNakFnUldkdmNpQk9aWEJ2Ylc1NVlYTmphR2xvWEc1Y2JsQmxjbTFwYzNOcGIyNGdhWE1nYUdWeVpXSjVJR2R5WVc1MFpXUXNJR1p5WldVZ2IyWWdZMmhoY21kbExDQjBieUJoYm5rZ2NHVnljMjl1SUc5aWRHRnBibWx1WnlCaElHTnZjSGxjYm05bUlIUm9hWE1nYzI5bWRIZGhjbVVnWVc1a0lHRnpjMjlqYVdGMFpXUWdaRzlqZFcxbGJuUmhkR2x2YmlCbWFXeGxjeUFvZEdobElGd2lVMjltZEhkaGNtVmNJaWtzSUhSdklHUmxZV3hjYm1sdUlIUm9aU0JUYjJaMGQyRnlaU0IzYVhSb2IzVjBJSEpsYzNSeWFXTjBhVzl1TENCcGJtTnNkV1JwYm1jZ2QybDBhRzkxZENCc2FXMXBkR0YwYVc5dUlIUm9aU0J5YVdkb2RITmNiblJ2SUhWelpTd2dZMjl3ZVN3Z2JXOWthV1o1TENCdFpYSm5aU3dnY0hWaWJHbHphQ3dnWkdsemRISnBZblYwWlN3Z2MzVmliR2xqWlc1elpTd2dZVzVrTDI5eUlITmxiR3hjYm1OdmNHbGxjeUJ2WmlCMGFHVWdVMjltZEhkaGNtVXNJR0Z1WkNCMGJ5QndaWEp0YVhRZ2NHVnljMjl1Y3lCMGJ5QjNhRzl0SUhSb1pTQlRiMlowZDJGeVpTQnBjMXh1Wm5WeWJtbHphR1ZrSUhSdklHUnZJSE52TENCemRXSnFaV04wSUhSdklIUm9aU0JtYjJ4c2IzZHBibWNnWTI5dVpHbDBhVzl1Y3pwY2JseHVWR2hsSUdGaWIzWmxJR052Y0hseWFXZG9kQ0J1YjNScFkyVWdZVzVrSUhSb2FYTWdjR1Z5YldsemMybHZiaUJ1YjNScFkyVWdjMmhoYkd3Z1ltVWdhVzVqYkhWa1pXUWdhVzRnWVd4c1hHNWpiM0JwWlhNZ2IzSWdjM1ZpYzNSaGJuUnBZV3dnY0c5eWRHbHZibk1nYjJZZ2RHaGxJRk52Wm5SM1lYSmxMbHh1WEc1VVNFVWdVMDlHVkZkQlVrVWdTVk1nVUZKUFZrbEVSVVFnWENKQlV5QkpVMXdpTENCWFNWUklUMVZVSUZkQlVsSkJUbFJaSUU5R0lFRk9XU0JMU1U1RUxDQkZXRkJTUlZOVElFOVNYRzVKVFZCTVNVVkVMQ0JKVGtOTVZVUkpUa2NnUWxWVUlFNVBWQ0JNU1UxSlZFVkVJRlJQSUZSSVJTQlhRVkpTUVU1VVNVVlRJRTlHSUUxRlVrTklRVTVVUVVKSlRFbFVXU3hjYmtaSlZFNUZVMU1nUms5U0lFRWdVRUZTVkVsRFZVeEJVaUJRVlZKUVQxTkZJRUZPUkNCT1QwNUpUa1pTU1U1SFJVMUZUbFF1SUVsT0lFNVBJRVZXUlU1VUlGTklRVXhNSUZSSVJWeHVRVlZVU0U5U1V5QlBVaUJEVDFCWlVrbEhTRlFnU0U5TVJFVlNVeUJDUlNCTVNVRkNURVVnUms5U0lFRk9XU0JEVEVGSlRTd2dSRUZOUVVkRlV5QlBVaUJQVkVoRlVseHVURWxCUWtsTVNWUlpMQ0JYU0VWVVNFVlNJRWxPSUVGT0lFRkRWRWxQVGlCUFJpQkRUMDVVVWtGRFZDd2dWRTlTVkNCUFVpQlBWRWhGVWxkSlUwVXNJRUZTU1ZOSlRrY2dSbEpQVFN4Y2JrOVZWQ0JQUmlCUFVpQkpUaUJEVDA1T1JVTlVTVTlPSUZkSlZFZ2dWRWhGSUZOUFJsUlhRVkpGSUU5U0lGUklSU0JWVTBVZ1QxSWdUMVJJUlZJZ1JFVkJURWxPUjFNZ1NVNGdWRWhGWEc1VFQwWlVWMEZTUlM1Y2Jpb3ZYRzVjYm1sdGNHOXlkQ0JDYVc1a1lXSnNaU0JtY205dElDY3VMMEpwYm1SaFlteGxKenRjYm1sdGNHOXlkQ0JEYkdGemN5Qm1jbTl0SUNjdUwwTnNZWE56Snp0Y2JtbHRjRzl5ZENCRVpYTjBjbTk1WVdKc1pTQm1jbTl0SUNjdUwwUmxjM1J5YjNsaFlteGxKenRjYm1sdGNHOXlkQ0JUZDJsMFkyaGxjaUJtY205dElDY3VMMU4zYVhSamFHVnlKenRjYmx4dVkyeGhjM01nUTJ4aGMzTk9ZVzFsVlhCa1lYUmxjaUJsZUhSbGJtUnpJRU5zWVhOeklIdGNibHgwWTI5dWMzUnlkV04wYjNJb2NISnBkbUYwWlNCbGJEb2dTbEYxWlhKNUxDQndjbTl3WlhKMGVUb2dRbWx1WkdGaWJHVThjM1J5YVc1blBpa2dlMXh1WEhSY2RITjFjR1Z5S0NrN1hHNWNkRngwZEdocGN5NXZkMjRvYm1WM0lGTjNhWFJqYUdWeUtIQnliM0JsY25SNUxDQjdYRzVjZEZ4MFhIUnBibWwwT2lCMllXeDFaU0E5UGlCMGFHbHpMbVZzTG1Ga1pFTnNZWE56S0haaGJIVmxLU3hjYmx4MFhIUmNkR1J2Ym1VNklIWmhiSFZsSUQwK0lIUm9hWE11Wld3dWNtVnRiM1psUTJ4aGMzTW9kbUZzZFdVcFhHNWNkRngwZlNrcE8xeHVYSFI5WEc1OVhHNWNibU5zWVhOeklFTnNZWE56VlhCa1lYUmxjaUJsZUhSbGJtUnpJRU5zWVhOeklIdGNibHgwWTI5dWMzUnlkV04wYjNJb2NISnBkbUYwWlNCbGJEb2dTbEYxWlhKNUxDQndjbWwyWVhSbElHTnNjem9nYzNSeWFXNW5MQ0J3Y21sMllYUmxJSEJ5YjNCbGNuUjVPaUJDYVc1a1lXSnNaVHhoYm5rK0tTQjdYRzVjZEZ4MGMzVndaWElvS1R0Y2JseDBYSFIwYUdsekxsOTFjR1JoZEdVb0tUdGNibHgwWEhSMGFHbHpMbTkzYmlod2NtOXdaWEowZVM1amFHRnVaMlZGZG1WdWRDNXNhWE4wWlc0b2RHaHBjeTVmZFhCa1lYUmxMQ0IwYUdsektTazdYRzVjZEgxY2JseHVYSFJ3Y21sMllYUmxJRjkxY0dSaGRHVW9LU0I3WEc1Y2RGeDBkR2hwY3k1bGJDNTBiMmRuYkdWRGJHRnpjeWgwYUdsekxtTnNjeXdnSVNGMGFHbHpMbkJ5YjNCbGNuUjVMbWRsZENncEtUdGNibHgwZlZ4dWZWeHVYRzR2S2lwY2JpQXFJRmRoZEdOb1pYTWdZbTl2YkdWaGJpQndjbTl3WlhKMGVTQnRiMlJwWm1sallYUnBiMjRnWVc1a0lIVndaR0YwWlhNZ2RHaGxJSE53WldOcFptbGxaQ0JEVTFNZ1kyeGhjM01nY0hKbGMyVnVZMlVnYVc0Z2RHaGxJRVJQVFNCbGJHVnRaVzUwTGx4dUlDb2dRSEJoY21GdElHVnNJRVJQVFNCbGJHVnRaVzUwTGx4dUlDb2dRSEJoY21GdElHTnNjeUJEVTFNZ1kyeGhjM01nYm1GdFpTNWNiaUFxSUVCd1lYSmhiU0J3Y205d1pYSjBlU0JDYjI5c1pXRnVJSEJ5YjNCbGNuUjVJSFJ2SUdKcGJtUWdRMU5USUdOc1lYTnpJSFJ2TGx4dUlDb2dRSEpsZEhWeWJuTWdRbWx1WkdsdVp5QnZZbXBsWTNRdUlGbHZkU0J0ZFhOMElHUmxjM1J5YjNrZ2FYUWdkRzhnYzNSdmNDQjBhR1VnYzNsdVkyaHliMjVwZW1GMGFXOXVMbHh1SUNvdlhHNWxlSEJ2Y25RZ1pHVm1ZWFZzZENCbWRXNWpkR2x2YmlCaWFXNWtRMnhoYzNNb1pXdzZJRXBSZFdWeWVTd2dZMnh6T2lCemRISnBibWNzSUhCeWIzQmxjblI1T2lCQ2FXNWtZV0pzWlR4aGJuaytLVG9nUkdWemRISnZlV0ZpYkdVN1hHNWNiaThxS2x4dUlDb2dWMkYwWTJobGN5QnpkSEpwYm1jZ2NISnZjR1Z5ZEhrZ2JXOWthV1pwWTJGMGFXOXVJR0Z1WkNCMWNHUmhkR1Z6SUVOVFV5QmpiR0Z6Y3lCdVlXMWxJR2x1SUhSb1pTQkVUMDBnWld4bGJXVnVkQzVjYmlBcUlFQndZWEpoYlNCbGJDQkVUMDBnWld4bGJXVnVkQzVjYmlBcUlFQndZWEpoYlNCamJITWdRMU5USUdOc1lYTnpJRzVoYldVdVhHNGdLaUJBY21WMGRYSnVjeUJDYVc1a2FXNW5JRzlpYW1WamRDNGdXVzkxSUcxMWMzUWdaR1Z6ZEhKdmVTQnBkQ0IwYnlCemRHOXdJSFJvWlNCemVXNWphSEp2Ym1sNllYUnBiMjR1WEc0Z0tpOWNibVY0Y0c5eWRDQmtaV1poZFd4MElHWjFibU4wYVc5dUlHSnBibVJEYkdGemN5aGxiRG9nU2xGMVpYSjVMQ0JqYkhNNklFSnBibVJoWW14bFBITjBjbWx1Wno0cE9pQkVaWE4wY205NVlXSnNaVHRjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR1oxYm1OMGFXOXVJR0pwYm1SRGJHRnpjeWhsYkRvZ1NsRjFaWEo1TENCaE9pQmhibmtzSUdJL09pQmhibmtwT2lCRVpYTjBjbTk1WVdKc1pTQjdYRzVjZEhKbGRIVnliaUFvWWlBaFBTQnVkV3hzS1NBL0lHNWxkeUJEYkdGemMxVndaR0YwWlhJb1pXd3NJR0VzSUdJcElEb2dibVYzSUVOc1lYTnpUbUZ0WlZWd1pHRjBaWElvWld3c0lHRXBPMXh1ZlZ4dUlsMHNJbk52ZFhKalpWSnZiM1FpT2lJaWZRPT0iXSwic291cmNlUm9vdCI6IiJ9