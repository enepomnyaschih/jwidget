Ext.data.JsonP.enphilosophy({"guide":"<h1 id='enphilosophy-section-jwidget-philosophy'>jWidget philosophy</h1>\n\n<p>Below, see common rules which jWidget framework philosophy is built on top of:</p>\n\n<p><strong>Model and view</strong></p>\n\n<ol>\n<li>All main application classes are classified to model and view.</li>\n<li>Model classes store the data. All data is stored in model. All model classes should be inherited from <a href=\"#!/api/JW.Class\" rel=\"JW.Class\" class=\"docClass\">JW.Class</a>.</li>\n<li>View classes (components) render data to the screen. All components should be inherited from <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>.</li>\n<li>Component has direct references to corresponding models. On user action, component calls corresponding\nmethod of model in order to modify it.</li>\n<li>Model doesn't have direct references to any views, but it triggers events about its modification.</li>\n<li>View listens model events to make neccessary updates on the screen in time.</li>\n</ol>\n\n\n<p><strong>Object destruction</strong></p>\n\n<ol>\n<li>All objects must be issued for destruction when you don't need them anymore. It is neccessary for resource\nreleasing and events unbinding.</li>\n<li>The one who issued an object creation must destroy it.</li>\n<li>It is optimal to destroy the objects using aggregation mechanism implemented by method <a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>, or\nusing the internal features of the classes:\n\n<ul>\n<li>Method <a href=\"#!/api/JW.Property-method-ownValue\" rel=\"JW.Property-method-ownValue\" class=\"docClass\">JW.Property.ownValue</a></li>\n<li>Method <a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">JW.AbstractCollection.ownItems</a></li>\n<li>Config options <a href=\"#!/api/JW.Switcher-cfg-done\" rel=\"JW.Switcher-cfg-done\" class=\"docClass\">JW.Switcher.done</a> and <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-destroyItem\" rel=\"JW.AbstractCollection.Mapper-cfg-destroyItem\" class=\"docClass\">JW.AbstractCollection.Mapper.destroyItem</a></li>\n</ul>\n</li>\n<li>Sometimes it is acceptable to destroy the objects explicitly using method <a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>.</li>\n</ol>\n\n\n<p><strong>Data binding</strong></p>\n\n<ol>\n<li>Objects and DOM-elements should never be recreated without a strong reason. Instead, they must be updated using\ndata binding.</li>\n<li>Data binding of single values is performed using <a href=\"#!/api/JW.Property\" rel=\"JW.Property\" class=\"docClass\">JW.Property</a> class and its helpers.</li>\n</ol>\n\n\n<p><strong>Data binding in collections</strong></p>\n\n<ol>\n<li>Data and components are structured based on three collection types: <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, <a href=\"#!/api/JW.AbstractMap\" rel=\"JW.AbstractMap\" class=\"docClass\">JW.AbstractMap</a> and\n<a href=\"#!/api/JW.AbstractSet\" rel=\"JW.AbstractSet\" class=\"docClass\">JW.AbstractSet</a>. All collections have common interfaces: <a href=\"#!/api/JW.AbstractCollection\" rel=\"JW.AbstractCollection\" class=\"docClass\">JW.AbstractCollection</a>, <a href=\"#!/api/JW.IndexedCollection\" rel=\"JW.IndexedCollection\" class=\"docClass\">JW.IndexedCollection</a>.\nRead common theory of algorithms and data structures to understand each collection type area of usage, pros and cons.</li>\n<li>Each collection has two implementations: simple (<a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>, <a href=\"#!/api/JW.Map\" rel=\"JW.Map\" class=\"docClass\">JW.Map</a>, <a href=\"#!/api/JW.Set\" rel=\"JW.Set\" class=\"docClass\">JW.Set</a>) and observable\n(<a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, <a href=\"#!/api/JW.ObservableMap\" rel=\"JW.ObservableMap\" class=\"docClass\">JW.ObservableMap</a>, <a href=\"#!/api/JW.ObservableSet\" rel=\"JW.ObservableSet\" class=\"docClass\">JW.ObservableSet</a>). Observable collections trigger events about their\nmodification.</li>\n<li>You don't need to listen all collection events manually. Instead, we recommend you to use standard jWidget\n<a href=\"#!/api/JW.AbstractCollection\" rel=\"JW.AbstractCollection\" class=\"docClass\">synchronizers</a>. Synchronizers provide a simple way to connect collections to each other.</li>\n<li>Collections are closed inside synchronizer methods. In other words, any modification of one collection triggers\nat most one modification of another collection, which is connected to the first one using standard synchronizer.</li>\n<li>Almost any user action can be handled by a single manual collection modification in model. All other collections\n(including component collections in the view) must be synchronized automatically via synchronizers.</li>\n<li>For proper and fast application running, it is enough to configure all synchronizers only once, similarly to\nindexes and foreign keys configuration in data bases.</li>\n</ol>\n\n","title":"jWidget philosophy"});