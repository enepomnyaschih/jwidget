Ext.data.JsonP.rusample2({"guide":"<h1 id='rusample2-section-%D0%A7%D0%B0%D1%81%D1%82%D1%8C-2.-%D0%94%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B%2C-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B'>Часть 2. Дочерние компоненты, массивы</h1>\n\n<p>Демонстрация доступна по адресу\n<a href=\"http://enepomnyaschih.github.io/mt/0.9.0-2/\">http://enepomnyaschih.github.io/mt/0.9.0-2/</a></p>\n\n<p>Исходный код <a href=\"https://github.com/enepomnyaschih/mt/tree/mt-0.9.0-2\">https://github.com/enepomnyaschih/mt/tree/mt-0.9.0-2</a> (ветка)</p>\n\n<p>Этот пример является продолжением предыдущей части.</p>\n\n<p>В этом примере мы познакомимся с <a href=\"#!/guide/rujwabstractcollection\">JW.AbstractArray</a>, воспользуемся его алгоритмами\n<a href=\"#!/api/JW.AbstractArray-method-map\" rel=\"JW.AbstractArray-method-map\" class=\"docClass\">map</a> и <a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>\nи научимся добавлять списки дочерних компонентов.</p>\n\n<p>Наша задача - отрендерить массив твитов, которые мы реализовали в предыдущей части.</p>\n\n<p><p><img src=\"guides/rusample2/tweet-feed.png\" alt=\"\" width=\"522\" height=\"247\"></p></p>\n\n<p>Как и в первый раз, начнем с модели. Твиты необходимо разместить в массиве. Для этого, определим класс mt.Data,\nкоторый будет содержать этот массив.</p>\n\n<p><strong>public/mt/data/data.js</strong></p>\n\n<pre><code>mt.Data = function() {\n    mt.Data.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.tweets = new <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>();\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.Data, <a href=\"#!/api/JW.Class\" rel=\"JW.Class\" class=\"docClass\">JW.Class</a>, {\n    /*\n    <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>&lt;mt.data.Tweet&gt; tweets;\n    */\n\n    // override\n    <a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>: function() {\n        this.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-clear\" rel=\"JW.AbstractArray-method-S-clear\" class=\"docClass\">$clear</a>().<a href=\"#!/api/JW.AbstractArray-method-each\" rel=\"JW.AbstractArray-method-each\" class=\"docClass\">each</a>(<a href=\"#!/api/JW-static-method-destroy\" rel=\"JW-static-method-destroy\" class=\"docClass\">JW.destroy</a>); // очищаем массив и уничтожаем элементы\n        this.tweets.<a href=\"#!/api/JW.AbstractArray-method-destroy\" rel=\"JW.AbstractArray-method-destroy\" class=\"docClass\">destroy</a>(); // уничтожаем массив\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n    }\n});\n\nmt.Data.createByJson = function(json) {\n    var data = new mt.Data();\n    data.tweets.<a href=\"#!/api/JW.AbstractArray-method-addAll\" rel=\"JW.AbstractArray-method-addAll\" class=\"docClass\">addAll</a>(<a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a>(json, mt.data.Tweet.createByJson));\n    return data;\n};\n\nmt.data = {};\n</code></pre>\n\n<p>Как вы видите, массив мы сконструировали как экземпляр <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>, но в списке полей объявили как <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>.\nЭто мы сделали для гибкости. Возможно, в будущем мы заменим реализацию массива на <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>.</p>\n\n<p>Десериализация осуществляется с помощью статического метода <a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a>.\nМетод принимает нативный массив (Array) в качестве первого аргумента и функцию-коллбек в качестве второго аргумента.\nФункция-коллбек mt.data.Tweet.createByJson превращает объект типа Object (JSON) в объект типа mt.data.Tweet,\nмы реализовали ее в предыдущей части.</p>\n\n<p>В результате вызова метода <a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a> мы получим нативный массив (Array)\nобъектов типа mt.data.Tweet. Передавая его в метод <a href=\"#!/api/JW.AbstractArray-method-addAll\" rel=\"JW.AbstractArray-method-addAll\" class=\"docClass\">addAll</a> массива data.tweets,\nмы заполняем этот массив:</p>\n\n<pre><code>    data.tweets.<a href=\"#!/api/JW.AbstractArray-method-addAll\" rel=\"JW.AbstractArray-method-addAll\" class=\"docClass\">addAll</a>(<a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a>(json, mt.data.Tweet.createByJson));\n</code></pre>\n\n<p>Поскольку мы конструируем объект this.tweets в конструкторе mt.Data, мы <strong>обязаны</strong> уничтожить его в деструкторе.\nЭто часть философии jWidget. Все объекты должен уничтожать тот, кто их создает. Так, если мы уничтожим объект\nmt.Data методом destroy, все вложенные объекты также гарантированно будут уничтожены.</p>\n\n<pre><code>    // override\n    <a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>: function() {\n        this.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-clear\" rel=\"JW.AbstractArray-method-S-clear\" class=\"docClass\">$clear</a>().<a href=\"#!/api/JW.AbstractArray-method-each\" rel=\"JW.AbstractArray-method-each\" class=\"docClass\">each</a>(<a href=\"#!/api/JW-static-method-destroy\" rel=\"JW-static-method-destroy\" class=\"docClass\">JW.destroy</a>); // очищаем массив и уничтожаем элементы\n        this.tweets.<a href=\"#!/api/JW.AbstractArray-method-destroy\" rel=\"JW.AbstractArray-method-destroy\" class=\"docClass\">destroy</a>(); // уничтожаем массив\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n    }\n</code></pre>\n\n<p>Мы можем избавиться от метода \"destroy\", используя <strong>механизм агрегирования объектов</strong> в jWidget. Если объект A агрегирует\nобъект B, то объект B будет уничтожен автоматически при уничтожении объекта A. Мы можем агрегировать объект с помощью\nметода <a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">JW.Class.own</a>, и мы можем агрегировать элементы массива с помощью метода\n<a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">JW.AbstractCollection.ownItems</a>:</p>\n\n<p><strong>public/mt/data/data.js</strong></p>\n\n<pre><code>mt.Data = function() {\n    mt.Data.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.tweets = this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(new <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>()).<a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">ownItems</a>();\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.Data, <a href=\"#!/api/JW.Class\" rel=\"JW.Class\" class=\"docClass\">JW.Class</a>, {\n    /*\n    <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>&lt;mt.data.Tweet&gt; tweets;\n    */\n});\n\nmt.Data.createByJson = function(json) {\n    var data = new mt.Data();\n    data.tweets.<a href=\"#!/api/JW.AbstractArray-method-addAll\" rel=\"JW.AbstractArray-method-addAll\" class=\"docClass\">addAll</a>(<a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a>(json, mt.data.Tweet.createByJson));\n    return data;\n};\n\nmt.data = {};\n</code></pre>\n\n<p>Теперь перейдем к представлению. Определим класс mt.TweetFeed для представления ленты твитов.</p>\n\n<p><strong>public/mt/tweetfeed/tweetfeed.js</strong></p>\n\n<pre><code>mt.TweetFeed = function(data) {\n    mt.TweetFeed.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.data = data;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.TweetFeed, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    /*\n    mt.Data data;\n    */\n\n    renderTweets: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>(function(tweetData) {\n            return new mt.TweetView(tweetData);\n        }, this)).<a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">ownItems</a>();\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(mt.TweetFeed, {\n    main:\n        '&lt;div jwclass=\"mt-tweet-feed\"&gt;' +\n            '&lt;div jwid=\"header\"&gt;Tweets&lt;/div&gt;' +\n            '&lt;div jwid=\"tweets\"&gt;&lt;/div&gt;' +\n            '&lt;div jwid=\"footer\"&gt;...&lt;/div&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p>Остановимся подробнее на методе renderTweets. По аналогии с компонентом mt.TweetView, мы определили метод\n<code>render&lt;ChildId&gt;</code> для элемента с jwid=\"tweets\". Но теперь этот метод не просто наполняет элемент данными,\nа рендерит внутрь него массив дочерних компонентов.</p>\n\n<p>Этот массив создается из данных с помощью метода конвертирования элементов коллекции\n<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>. Мы уже рассматривали статический метод\n<a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a>. Рассмотрим их отличия:</p>\n\n<ul>\n<li>Во-первых, один из этих методов динамический (instance method), второй - статический (static method). <strong>Все\nколлекции jWidget имеют общий набор статических методов для нативных коллекций JavaScript (Array, Object) и\nдинамических методов для коллекций jWidget (<a href=\"#!/guide/rujwabstractarray\">JW.AbstractArray</a>,\n<a href=\"#!/guide/rujwabstractmap\">JW.AbstractMap</a>, <a href=\"#!/guide/rujwabstractset\">JW.AbstractSet</a>). Статические методы\nнаходятся в классах <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>, <a href=\"#!/api/JW.Map\" rel=\"JW.Map\" class=\"docClass\">JW.Map</a>, <a href=\"#!/api/JW.Set\" rel=\"JW.Set\" class=\"docClass\">JW.Set</a> и принимают нативную коллекцию в качестве первого аргумента.</strong></li>\n<li>Во-вторых, метод <a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a> возвращает нативный массив JavaScript (Array), а\nметод <a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a> возвращает массив jWidget (<a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>). <strong>Все методы, названия которых\nначинаются со знака доллара $, возвращают коллекции jWidget. Все остальные методы возвращают нативные коллекции\nJavaScript или другие значения.</strong></li>\n</ul>\n\n\n<p>Оба правила введены для удобства. Каждый алгоритм имеет множество реализаций, на которые наложены строгие стандарты\nименования методов. Используйте ту реализацию, которая удобнее в данной конкретной ситуации.</p>\n\n<p>В нашем примере метод <a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a> принимает функцию-коллбек в качестве первого аргумента,\nкоторая превращает объект типа mt.data.Tweet в объект типа mt.TweetView:</p>\n\n<pre><code>    renderTweets: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>(function(tweetData) {\n            return new mt.TweetView(tweetData);\n        }, this)).<a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">ownItems</a>();\n    }\n</code></pre>\n\n<p>Вторым аргументом метод принимает контекст вызова функции-коллбека (this). Правило здесь простое:\n<strong>всегда, когда вы передаете функцию в качестве аргумента функции, следующим аргументом передается контекст\nвызова этой функции.</strong></p>\n\n<p>В результате мы получаем <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>, содержщащий объекты типа mt.TweetView, который мы возвращаем на выходе из\nметода renderTweets. Тем самым мы просим фреймворк отрендерить дочерние компоненты внутрь элемента с jwid=\"tweets\".</p>\n\n<p>Далее, добавим CSS-файл.</p>\n\n<p><strong>public/mt/tweetfeed/tweetfeed.css</strong></p>\n\n<pre><code>.mt-tweet-feed-header {\n  color: #333;\n  font-family: Arial, sans-serif;\n  font-size: 14px;\n  font-weight: bold;\n  text-shadow: 0 1px 0 #fff;\n}\n.mt-tweet-feed {\n  border: 1px solid rgba(0,0,0,0.45);\n  -webkit-border-radius: 6px;\n  -moz-border-radius: 6px;\n  border-radius: 6px;\n}\n.mt-tweet-feed {\n  background: #fff;\n  width: 522px;\n}\n.mt-tweet-feed-header {\n  font-size: 18px;\n  padding: 10px;\n}\n.mt-tweet-feed-footer {\n  border-top: 1px solid #e8e8e8;\n  padding: 8px;\n  text-align: center;\n}\n</code></pre>\n\n<p>Добавим новые файлы в index.html:</p>\n\n<pre><code>&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mt/tweetfeed/tweetfeed.css\" /&gt;\n&lt;script type=\"text/javascript\" charset=\"utf-8\" src=\"mt/tweetfeed/tweetfeed.js\"&gt;&lt;/script&gt;\n</code></pre>\n\n<p>Остается только подставить новые тестовые данные.</p>\n\n<p><strong>public/boot.js</strong></p>\n\n<pre><code>var data;\nvar tweetFeed;\n\n$(function() {\n    data = mt.Data.createByJson([\n        {\n            \"fullName\": \"Road Runner\",\n            \"shortName\": \"roadrunner\",\n            \"avatarUrl48\": \"backend/avatar-48.png\",\n            \"contentHtml\": \"jWidget documentation is here &lt;a href=\\\"https://enepomnyaschih.github.com/jwidget\\\" target=\\\"_blank\\\"&gt;enepomnyaschih.github.com/jwidget&lt;/a&gt;\",\n            \"timeAgo\": 215000,\n            \"like\": false,\n            \"retweet\": true\n        }, {\n            \"fullName\": \"Road Runner\",\n            \"shortName\": \"roadrunner\",\n            \"avatarUrl48\": \"backend/avatar-48.png\",\n            \"contentHtml\": \"Tweet feed is growing\",\n            \"timeAgo\": 515000,\n            \"like\": false,\n            \"retweet\": false\n        }\n    ]);\n    tweetFeed = new mt.TweetFeed(data);\n    tweetFeed.<a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>(\"#container\");\n});\n</code></pre>\n\n<p>Запустив приложение в браузере, мы увидим то, что от нас и требовалось.</p>\n\n<p>Рассмотрим еще один способ добавления списка дочерних компонентов, без использования метода <code>render&lt;ChildId&gt;</code>.\nУдалим метод renderTweets и перегрузим метод <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>:</p>\n\n<pre><code>    // override\n    <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>: function() {\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n        var tweetViews = this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>(function(tweetData) {\n            return new mt.TweetView(tweetData);\n        }, this).<a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">ownItems</a>();\n        this.<a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>(tweetViews, \"tweets\");\n    },\n</code></pre>\n\n<p>Этот код эквивалентен предыдущему, только список дочерних компонентов добавляется методом\n<a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>. Вторым аргументом этот метод принимает jwid элемента, внутрь которого\nотрендерить массив компонентов, переданный первым аргументом. Если второй аргумент не передать, массив отрендерится\nвнутрь корневого элемента. Используйте тот вариант, который вам больше нравится.</p>\n\n<p>Недостаток всего примера заключается в том, что массив твитов фиксирован. Мы не сможем добавлять и удалять твиты\nдинамически. Мы научимся этому в следующих примерах.</p>\n","title":"Часть 2. Дочерние компоненты, массивы"});