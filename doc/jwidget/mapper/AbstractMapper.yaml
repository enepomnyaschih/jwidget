description: |
  <p><b>Mapper</b> is one of collection synchronizers. <b>Mapper</b> builds a new collection of the same type,
  consisting of results of callback function call for each collection item.</p>
  <pre>
  const source = new %List([1, 2]);
  const mapper = new %ListMapper(source, x => 2 * x);
  const target = mapper.%target;

  expect(target.%get(0)).toBe(2);
  expect(target.%get(1)).toBe(4);

  // Target collection is automatically synchronized with the original collection
  source.%add(3);
  expect(target.%get(2)).toBe(6);

  // Destroy the mapper to stop synchronization
  mapper.%destroy();
  </pre>

  <h3>Mapper modules</h3>

  <p><b>Mapper</b> has one common abstract class with one implementation per collection type. Every implementation is
  supplied with a shorthand function that returns target collection directly. There is also a module that merges all
  implementations together and allows you to map a collection of any (i.e. unknown) type.</p>
  <p>Module dependencies and exports are represented at the following diagram:</p>
  <table class="table table-sm text-center">
    <tbody>
      <tr>
        <td colspan="3">
          <h5>jwidget/mapper/AbstractMapper</h5>
          <p>%AbstractMapper</p>
          <p class="text-secondary">All other modules depend on it</p>
        </td>
      </tr>
      <tr>
        <td>
          <h5>jwidget/mapper/list</h5>
          <p>%ListMapper, %mapList</p>
        </td>
        <td>
          <h5>jwidget/mapper/map</h5>
          <p>%MapMapper, %mapMap</p>
        </td>
        <td>
          <h5>jwidget/mapper/set</h5>
          <p>%SetMapper, %mapSet</p>
        </td>
      </tr>
      <tr>
        <td colspan="3">
          <h5>jwidget/mapper/collection</h5>
          <p>%createMapper, %mapCollection</p>
          <p class="text-danger">Depends on all other modules</p>
        </td>
      </tr>
    </tbody>
  </table>
  <p>Knowledge of this diagram may help you to optimize WebPack bundling. Avoid using modules you don't need to.</p>

  <h3>Features and examples</h3>

  <p>You can pass target collection in config option:</p>
  <pre>
  const source = new %List([1, 2]);
  const target = new %List<number>();
  const mapper = new %ListMapper(source, x => 2 * x, {%targetOfConfig});
  </pre>
  <p>If you want to map the values into a new collection, use shorthand functions %mapList, %mapMap, %mapSet and
  %mapCollection instead:</p>
  <pre>
  const source = new %List([1, 2]);
  const target = %mapList(source, x => 2 * x);

  // Destroy the target collection to stop synchronization
  target.%destroy();
  </pre>
  <p>Mapper can be used to convert data collection to view collection.</p>
  <pre>
  const viewCollection = %mapList(dataCollection, data => new View(data), {%destroyOfConfig});
  </pre>

  <h3>Synchronizer rules</h3>

  </pre>
  <p>Synchronizer rules:</p>
  <ul>
    <li>All items of source collection get mapped and added to %target immediately on synchronizer initialization.</li>
    <li>All items get removed from %target and destroyed via %destroyOfConfig callback on synchronizer destruction.</li>
    <li>You can pass target map in <b>target</b> config option. In this case, you are responsible for its
    destruction (though items get removed and destroyed automatically on synchronizer destruction anyway).</li>
    <li>If <b>target</b> is not passed, it gets created automatically. In this
    case, %target gets destroyed automatically on synchronizer destruction.</li>
    <li>The items do not get recreated in target collection on source collection reordering/reindexing,
    but they get reordered/reindexed according to source collection modification.</li>
  </ul>

  <h3>Additional rules for different collection types</h3>

  <p>%List:</p>
  <ul>
    <li>Target collection must be empty before initialization.</li>
    <li>You can't modify target collection manually and/or create other synchronizers with the same target collection.</li>
  </ul>
  <p>%Map:</p>
  <ul>
    <li>Target collection can be synchronized with multiple source collections, as long as keys of all items are different.</li>
    <li>You can add items to target collection manually, as long as their keys differ from other collection keys.</li>
  </ul>
  <p>%Set:</p>
  <ul>
    <li>Target collection can be synchronized with multiple source collections, as long as all items are different.</li>
    <li>You can add items to target collection manually, as long as they differ from other collection items.</li>
  </ul>

symbols:
  default:
    kind: abstract class
    typevars:
      T: Source collection item type.
      U: Target collection item type.
    extends:
      - file: jwidget/Class
    description: |
      <p>Abstract collection item mapper. Builds new collection of the same type, consisting of results of callback function
      call for each collection item, and starts continuous synchronization.</p>

    properties:
      target:
        modifiers: readonly
        type: '%ReadonlyCollection<%U>'
        description: Target collection.

  AbstractMapper.Config:
    kind: interface
    simple: true
    typevars:
      T: Source collection item type.
      U: Target collection item type.
    properties:
      destroy:
        modifiers: readonly
        optional: true
        type: '%AbstractMapper.%DestroyCallback<%T, %U>'
        description: |
          <p>Item destructor. Destroys an item when it leaves the target collection.</p>
          <p>Signature: <code>(targetValue: %U, sourceValue: %T): any</code></p>
          <p>It is usually convenient to pass %destroyFunction core function as this callback into a collection:</p>
          <pre>
          import {%destroyFunction} from "jwidget";

          // ...
          const viewCollection = %mapList(dataCollection, data => new View(data), {%destroy});
          </pre>

      scope:
        modifiers: readonly
        optional: true
        type: any
        description: |
          <p>Call scope of mapper's <b>create</b> and %destroy callbacks. Defaults to synchronizer itself.</p>

    references:
      DestroyCallback: {}

references:
  target:
    symbol: default
    member: target

  get:
    file: jwidget/ReadonlyList
    member: get

  add:
    file: jwidget/IList
    member: add

  destroyOfConfig:
    symbol: AbstractMapper.Config
    member: destroy
    label: destroy

  targetOfConfig:
    label: target
