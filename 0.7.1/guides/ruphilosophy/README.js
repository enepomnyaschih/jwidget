Ext.data.JsonP.ruphilosophy({"guide":"<h1 id='ruphilosophy-section-%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F-jwidget'>Философия jWidget</h1>\n\n<p>Фреймворк jWidget сильно отличается от всех известных автору библиотеки UI-фреймворков на всех языках программирования\nсвоей философией. Ниже приведены общие правила для всех Model-View фреймворков, которые верны и для jWidget:</p>\n\n<ol>\n<li>Все основные классы приложения делятся на модель (model) и представление (view).</li>\n<li>Классы модели хранят данные. Все данные хранятся в модели. Все классы модели нужно наследовать от <a href=\"#!/api/JW.Class\" rel=\"JW.Class\" class=\"docClass\">JW.Class</a>.</li>\n<li>Классы представления (компоненты) выводят информацию на экран. Все компоненты нужно наследовать от\n<a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>.</li>\n<li>Компонент имеет прямую ссылку на соответствующую модель. При действии пользователя компонент вызывает\nсоответствующий метод модели, чтобы изменить ее.</li>\n<li>Модель не имеет прямых ссылок на представление, но выбрасывает события о своем изменении.</li>\n<li>Представление прослушивает события модели для того, чтобы вовремя обновляться.</li>\n</ol>\n\n\n<p>Но самый изюм фреймворка jWidget - это подход к работе с коллекциями. Это очень похоже на основы теории баз данных,\nно только на уровне UI. Ниже приведены правила работы с коллекциями jWidget:</p>\n\n<ol>\n<li>Данные и компоненты структурированы на базе трех классов коллекций: массивов (<a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>),\nсловарей (<a href=\"#!/api/JW.AbstractMap\" rel=\"JW.AbstractMap\" class=\"docClass\">JW.AbstractMap</a>) и множеств (<a href=\"#!/api/JW.AbstractSet\" rel=\"JW.AbstractSet\" class=\"docClass\">JW.AbstractSet</a>). Все коллекции имеют общие интерфейсы\n(<a href=\"#!/api/JW.AbstractCollection\" rel=\"JW.AbstractCollection\" class=\"docClass\">JW.AbstractCollection</a>, <a href=\"#!/api/JW.IndexedCollection\" rel=\"JW.IndexedCollection\" class=\"docClass\">JW.IndexedCollection</a>). О сфере использования, преимуществах и недостатках каждой\nколлекции читайте общую теорию алгоритмов и структур данных.</li>\n<li>Каждая коллекция имеет две реализации: простая (<a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>, <a href=\"#!/api/JW.Map\" rel=\"JW.Map\" class=\"docClass\">JW.Map</a>, <a href=\"#!/api/JW.Set\" rel=\"JW.Set\" class=\"docClass\">JW.Set</a>) и оповещающая\n(<a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, <a href=\"#!/api/JW.ObservableMap\" rel=\"JW.ObservableMap\" class=\"docClass\">JW.ObservableMap</a>, <a href=\"#!/api/JW.ObservableSet\" rel=\"JW.ObservableSet\" class=\"docClass\">JW.ObservableSet</a>). Оповещающие коллекции выбрасывают события о своем изменении.</li>\n<li>Не нужно прослушивать все события оповещающих коллекций вручную. Вместо этого предлагается использовать\nстандартные синхронизаторы jWidget. Синхронизаторы позволяют наладить связь между коллекциями:\n\n<ul>\n<li>Конвертер элементов: <a href=\"#!/api/JW.AbstractCollection.Mapper\" rel=\"JW.AbstractCollection.Mapper\" class=\"docClass\">JW.AbstractCollection.Mapper</a></li>\n<li>Фильтровщик: <a href=\"#!/api/JW.AbstractCollection.Filterer\" rel=\"JW.AbstractCollection.Filterer\" class=\"docClass\">JW.AbstractCollection.Filterer</a></li>\n<li>Конвертер в множество: <a href=\"#!/api/JW.AbstractCollection.Lister\" rel=\"JW.AbstractCollection.Lister\" class=\"docClass\">JW.AbstractCollection.Lister</a></li>\n<li>Конвертер в словарь (индексатор): <a href=\"#!/api/JW.AbstractCollection.Indexer\" rel=\"JW.AbstractCollection.Indexer\" class=\"docClass\">JW.AbstractCollection.Indexer</a></li>\n<li>Конвертер в массив (упорядочитель): <a href=\"#!/api/JW.AbstractCollection.Orderer\" rel=\"JW.AbstractCollection.Orderer\" class=\"docClass\">JW.AbstractCollection.Orderer</a></li>\n<li>Конвертер в массив (сортировщик по компаратору): <a href=\"#!/api/JW.AbstractCollection.SorterComparing\" rel=\"JW.AbstractCollection.SorterComparing\" class=\"docClass\">JW.AbstractCollection.SorterComparing</a></li>\n<li>Наблюдатель: <a href=\"#!/api/JW.AbstractCollection.Observer\" rel=\"JW.AbstractCollection.Observer\" class=\"docClass\">JW.AbstractCollection.Observer</a></li>\n<li>Синхронизаторы представления: <a href=\"#!/api/JW.AbstractArray.Inserter\" rel=\"JW.AbstractArray.Inserter\" class=\"docClass\">JW.AbstractArray.Inserter</a>, <a href=\"#!/api/JW.AbstractMap.Inserter\" rel=\"JW.AbstractMap.Inserter\" class=\"docClass\">JW.AbstractMap.Inserter</a></li>\n<li>Объединитель массивов: <a href=\"#!/api/JW.AbstractArray.Merger\" rel=\"JW.AbstractArray.Merger\" class=\"docClass\">JW.AbstractArray.Merger</a></li>\n<li>Обратитель массива: <a href=\"#!/api/JW.AbstractArray.Reverser\" rel=\"JW.AbstractArray.Reverser\" class=\"docClass\">JW.AbstractArray.Reverser</a></li>\n</ul>\n</li>\n<li>Коллекции замкнуты относительно синхронизаторов. Всякое изменение одной коллекции влечет не более одного\nизменения  другой коллекции, связанной с первой с помощью стандартного синхронизатора.</li>\n<li>Почти на всякое действие пользователя должно производиться одно ручное изменение некоторой коллекции.\nВсе остальные коллекции (включая коллекции компонентов представления) должны синхронизироваться автоматически\nс помощью синхронизаторов.</li>\n<li>Для правильной и быстрой работы приложения достаточно один раз правильно сконфигурировать синхронизаторы по\nаналогии с тем, как конфигурируются индексы и внешние ключи таблиц баз данных.</li>\n<li>Не должно быть разницы в подходах между простой и оповещающей коллекцией. Несмотря на то, что для\nкорректного преобразования простых коллекций друг в друга достаточно просто запустить некоторый алгоритм\n(<a href=\"#!/api/JW.AbstractCollection-method-index\" rel=\"JW.AbstractCollection-method-index\" class=\"docClass\">index</a>,\n<a href=\"#!/api/JW.AbstractCollection-method-toSortedComparing\" rel=\"JW.AbstractCollection-method-toSortedComparing\" class=\"docClass\">toSortedComparing</a>,\n<a href=\"#!/api/JW.AbstractCollection-method-toSet\" rel=\"JW.AbstractCollection-method-toSet\" class=\"docClass\">toSet</a> и т.п.), все равно рекомендуется вместо этого создать синхронизатор\n(<a href=\"#!/api/JW.AbstractCollection-method-createIndexer\" rel=\"JW.AbstractCollection-method-createIndexer\" class=\"docClass\">createIndexer</a>,\n<a href=\"#!/api/JW.AbstractCollection-method-createSorterComparing\" rel=\"JW.AbstractCollection-method-createSorterComparing\" class=\"docClass\">createSorterComparing</a>,\n<a href=\"#!/api/JW.AbstractCollection-method-createLister\" rel=\"JW.AbstractCollection-method-createLister\" class=\"docClass\">createLister</a> соответственно). Качество, скорость и размер кода\nпри этом пострадают не сильно. Зато взамен вы получаете возможность простой сменой базового класса коллекции начать\nпрослушивать изменения в этой коллекции. (Хотя в некоторых запутанных случаях конфигурация синхронизаторов может\nобойтись слишком дорого: соблюдайте баланс)</li>\n<li>Объекты и DOM-элементы никогда не пересоздаются, а только обновляются</li>\n<li>Уничтожает объект тот, кто его создал. Единственное исключение: элементы <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">JW.UI.Component.children</a> (для удобства\nуничтожаются автоматически).</li>\n</ol>\n\n","title":"Философия jWidget"});