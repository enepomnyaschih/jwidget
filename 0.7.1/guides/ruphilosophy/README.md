# Философия jWidget

Фреймворк jWidget сильно отличается от всех известных автору библиотеки UI-фреймворков на всех языках программирования
своей философией. Ниже приведены общие правила для всех Model-View фреймворков, которые верны и для jWidget:

1. Все основные классы приложения делятся на модель (model) и представление (view).
1. Классы модели хранят данные. Все данные хранятся в модели. Все классы модели нужно наследовать от JW.Class.
1. Классы представления (компоненты) выводят информацию на экран. Все компоненты нужно наследовать от
JW.UI.Component.
1. Компонент имеет прямую ссылку на соответствующую модель. При действии пользователя компонент вызывает
соответствующий метод модели, чтобы изменить ее.
1. Модель не имеет прямых ссылок на представление, но выбрасывает события о своем изменении.
1. Представление прослушивает события модели для того, чтобы вовремя обновляться.

Но самый изюм фреймворка jWidget - это подход к работе с коллекциями. Это очень похоже на основы теории баз данных,
но только на уровне UI. Ниже приведены правила работы с коллекциями jWidget:

1. Данные и компоненты структурированы на базе трех классов коллекций: массивов (JW.AbstractArray),
словарей (JW.AbstractMap) и множеств (JW.AbstractSet). Все коллекции имеют общие интерфейсы
(JW.AbstractCollection, JW.IndexedCollection). О сфере использования, преимуществах и недостатках каждой
коллекции читайте общую теорию алгоритмов и структур данных.
1. Каждая коллекция имеет две реализации: простая (JW.Array, JW.Map, JW.Set) и оповещающая
(JW.ObservableArray, JW.ObservableMap, JW.ObservableSet). Оповещающие коллекции выбрасывают события о своем изменении.
1. Не нужно прослушивать все события оповещающих коллекций вручную. Вместо этого предлагается использовать
стандартные синхронизаторы jWidget. Синхронизаторы позволяют наладить связь между коллекциями:
    - Конвертер элементов: JW.AbstractCollection.Mapper
    - Фильтровщик: JW.AbstractCollection.Filterer
    - Конвертер в множество: JW.AbstractCollection.Lister
    - Конвертер в словарь (индексатор): JW.AbstractCollection.Indexer
    - Конвертер в массив (упорядочитель): JW.AbstractCollection.Orderer
    - Конвертер в массив (сортировщик по компаратору): JW.AbstractCollection.SorterComparing
    - Наблюдатель: JW.AbstractCollection.Observer
    - Синхронизаторы представления: JW.AbstractArray.Inserter, JW.AbstractMap.Inserter
    - Объединитель массивов: JW.AbstractArray.Merger
    - Обратитель массива: JW.AbstractArray.Reverser
1. Коллекции замкнуты относительно синхронизаторов. Всякое изменение одной коллекции влечет не более одного
изменения  другой коллекции, связанной с первой с помощью стандартного синхронизатора.
1. Почти на всякое действие пользователя должно производиться одно ручное изменение некоторой коллекции.
Все остальные коллекции (включая коллекции компонентов представления) должны синхронизироваться автоматически
с помощью синхронизаторов.
1. Для правильной и быстрой работы приложения достаточно один раз правильно сконфигурировать синхронизаторы по
аналогии с тем, как конфигурируются индексы и внешние ключи таблиц баз данных.
1. Не должно быть разницы в подходах между простой и оповещающей коллекцией. Несмотря на то, что для
корректного преобразования простых коллекций друг в друга достаточно просто запустить некоторый алгоритм
({@link JW.AbstractCollection#method-index index},
{@link JW.AbstractCollection#method-toSortedComparing toSortedComparing},
{@link JW.AbstractCollection#method-toSet toSet} и т.п.), все равно рекомендуется вместо этого создать синхронизатор
({@link JW.AbstractCollection#method-createIndexer createIndexer},
{@link JW.AbstractCollection#method-createSorterComparing createSorterComparing},
{@link JW.AbstractCollection#method-createLister createLister} соответственно). Качество, скорость и размер кода
при этом пострадают не сильно. Зато взамен вы получаете возможность простой сменой базового класса коллекции начать
прослушивать изменения в этой коллекции. (Хотя в некоторых запутанных случаях конфигурация синхронизаторов может
обойтись слишком дорого: соблюдайте баланс)
1. Объекты и DOM-элементы никогда не пересоздаются, а только обновляются
1. Уничтожает объект тот, кто его создал. Единственное исключение: элементы JW.UI.Component.children (для удобства
уничтожаются автоматически).
