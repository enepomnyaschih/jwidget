Ext.data.JsonP.rusample4({"guide":"<h1 id='rusample4-section-%D0%A7%D0%B0%D1%81%D1%82%D1%8C-4.-%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F'>Часть 4. События</h1>\n\n<p>Демонстрация доступна по адресу\n<a href=\"http://enepomnyaschih.github.io/mt/1.0.0-4/\">http://enepomnyaschih.github.io/mt/1.0.0-4/</a></p>\n\n<p>Исходный код <a href=\"https://github.com/enepomnyaschih/mt/tree/mt-1.0.0-4\">https://github.com/enepomnyaschih/mt/tree/mt-1.0.0-4</a> (ветка)</p>\n\n<p>В этом примере мы научимся подписываться на события элементов jQuery в рамках фреймворка jWidget, а также\nнаучимся создавать события модели, прослушивать их и выбрасывать.</p>\n\n<p>Первая задача, которая перед нами стоит - активировать кнопки Like/Unlike и Retweet/Unretweet.</p>\n\n<p><p><img src=\"guides/rusample4/buttons.png\" alt=\"\" width=\"541\" height=\"178\"></p></p>\n\n<p>Что должно происходить при клике по кнопке Like?</p>\n\n<ol>\n<li>Представление перехватывает событие click с помощью jQuery</li>\n<li>Представление обращается к модели с помощью метода tweetData.setLike(value)</li>\n<li>Модель проверяет, изменилось ли значение поля like. Если значение совпадает, выходит без изменений</li>\n<li>Если значение like изменилось, модель его запоминает и выбрасывает событие likeChangeEvent</li>\n<li>Представление перехватывает событие likeChangeEvent и обновляется</li>\n</ol>\n\n\n<p>Заметим, что перед шагом 2 представление может обновиться самостоятельно, до вызова метода модели. Но это ни к чему,\nесли представление прослушивает событие likeChangeEvent, а прослушивать его оно обязано по архитектуре Model-View,\nведь кто знает, какому еще клиенту захочется менять значение свойства like в модели? Может быть, асинхронный\nподгрузчик данных с сервера захочет выполнить это действие, а может быть для некоторых твитов будет автоматически\nдобавляться like при некотором действии пользователя? В любом случае, наличие события нас обезопасивает:\nпредставление всегда в курсе событий и будет вовремя обновляться.</p>\n\n<p>Еще одно замечание: в других Model-View (а если точнее, MVC) фреймворках наподобие ExtJS ответственность за\nпрослушку событий и их обработку берет на себя контроллер (Controller). jWidget не предоставляет возможностей\nдля реализации подобного рода контроллеров, тем более, что реализация, предоставляемая ExtJS, страдает в плане\nпроизводительности ввиду необходимости частого выполнения CSS-запросов, а в jWidget это не требуется - все\nработает по прямым ссылкам.</p>\n\n<p>API для работы с событиями в jWidget максимально оптимизирован в плане производительности и реализован по\nвсем принципам ООП. Поэтому API для работы с событиями кардинально отличается в jWidget по сравнению с jQuery.\nСобытие в jWidget реализует класс <a href=\"#!/guide/rujwevent\">JW.Event</a>. Есть еще два смежных класса: параметры события <a href=\"#!/api/JW.EventParams\" rel=\"JW.EventParams\" class=\"docClass\">JW.EventParams</a> и\nподписка на событие <a href=\"#!/api/JW.EventAttachment\" rel=\"JW.EventAttachment\" class=\"docClass\">JW.EventAttachment</a>. Сейчас мы рассмотрим, как ими пользоваться.</p>\n\n<p>Итак, начнем обработку клика по Like или Retweet. Пойдем по шагам, описанным выше. Сначала подпишемся на событие\nклика с помощью jQuery в классе mt.TweetView:</p>\n\n<p><strong>public/mt/tweetview/tweetview.js</strong></p>\n\n<pre><code>    renderLike: function(el) {\n        el.toggleClass(\"active\", this.tweetData.like).text(this.tweetData.like ? \"Unlike\" : \"Like\");\n        el.click(this._onLikeClick);\n    },\n\n    renderRetweet: function(el) {\n        el.toggleClass(\"active\", this.tweetData.retweet).text(this.tweetData.retweet ? \"Unretweet\" : \"Retweet\");\n        el.click(this._onRetweetClick);\n    },\n\n    _onLikeClick: function(event) {\n        event.preventDefault();\n        this.tweetData.setLike(!this.tweetData.like);\n    },\n\n    _onRetweetClick: function(event) {\n        event.preventDefault();\n        this.tweetData.setRetweet(!this.tweetData.retweet);\n    },\n</code></pre>\n\n<p>Кому уже приходилось работать с классами в JavaScript, тот наверняка может сказать, что этот код работать не будет.\nСвязано это с тем, что у обработчика события не определен контекст вызова (this). Это особенность JavaScript,\nс которой мы вынуждены смириться. Чтобы заставить этот код работать, закрепим контекст вызова этих функций\nс помощью функции <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>. По стандарту, это следует делать в конструкторе, до вызова конструктора базового класса:</p>\n\n<p><strong>public/mt/tweetview/tweetview.js</strong></p>\n\n<pre><code>mt.TweetView = function(tweetData) {\n    this._onLikeClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onLikeClick, this);\n    this._onRetweetClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onRetweetClick, this);\n    mt.TweetView.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.tweetData = tweetData;\n};\n</code></pre>\n\n<p>Следующим шагом добавим методы setLike и setRetweet в модель. Для реализации методов необходимы события\nlikeChangeEvent и retweetChangeEvent, которые мы создадим и заагрегируем в конструкторе mt.data.Tweet:</p>\n\n<p><strong>public/mt/data/tweet.js</strong></p>\n\n<pre><code>mt.data.Tweet = function(config) {\n    mt.data.Tweet.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.fullName = config.fullName;\n    this.shortName = config.shortName;\n    this.avatarUrl48 = config.avatarUrl48;\n    this.contentHtml = config.contentHtml;\n    this.time = config.time;\n    this.like = config.like;\n    this.retweet = config.retweet;\n    this.likeChangeEvent = this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(new <a href=\"#!/api/JW.Event\" rel=\"JW.Event\" class=\"docClass\">JW.Event</a>());\n    this.retweetChangeEvent = this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(new <a href=\"#!/api/JW.Event\" rel=\"JW.Event\" class=\"docClass\">JW.Event</a>());\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.data.Tweet, <a href=\"#!/api/JW.Class\" rel=\"JW.Class\" class=\"docClass\">JW.Class</a>, {\n    /*\n    string fullName;\n    string shortName;\n    string contentHtml;\n    string avatarUrl48;\n    number time;\n    boolean like;\n    boolean retweet;\n    <a href=\"#!/api/JW.Event\" rel=\"JW.Event\" class=\"docClass\">JW.Event</a>&lt;<a href=\"#!/api/JW.ValueEventParams\" rel=\"JW.ValueEventParams\" class=\"docClass\">JW.ValueEventParams</a>&lt;boolean&gt;&gt; likeChangeEvent;\n    <a href=\"#!/api/JW.Event\" rel=\"JW.Event\" class=\"docClass\">JW.Event</a>&lt;<a href=\"#!/api/JW.ValueEventParams\" rel=\"JW.ValueEventParams\" class=\"docClass\">JW.ValueEventParams</a>&lt;boolean&gt;&gt; retweetChangeEvent;\n    */\n\n    setLike: function(value) {\n        if (this.like === value) {\n            return;\n        }\n        this.like = value;\n        this.likeChangeEvent.<a href=\"#!/api/JW.Event-method-trigger\" rel=\"JW.Event-method-trigger\" class=\"docClass\">trigger</a>(new <a href=\"#!/api/JW.ValueEventParams\" rel=\"JW.ValueEventParams\" class=\"docClass\">JW.ValueEventParams</a>(this, value));\n    },\n\n    setRetweet: function(value) {\n        if (this.retweet === value) {\n            return;\n        }\n        this.retweet = value;\n        this.retweetChangeEvent.<a href=\"#!/api/JW.Event-method-trigger\" rel=\"JW.Event-method-trigger\" class=\"docClass\">trigger</a>(new <a href=\"#!/api/JW.ValueEventParams\" rel=\"JW.ValueEventParams\" class=\"docClass\">JW.ValueEventParams</a>(this, value));\n    }\n});\n\nmt.data.Tweet.createByJson = function(json) {\n    return new mt.data.Tweet(<a href=\"#!/api/JW-static-method-apply\" rel=\"JW-static-method-apply\" class=\"docClass\">JW.apply</a>({}, json, {\n        time: new Date().getTime() - json.timeAgo\n    }));\n};\n</code></pre>\n\n<p>Событие выбрасывается методом <a href=\"#!/api/JW.Event-method-trigger\" rel=\"JW.Event-method-trigger\" class=\"docClass\">trigger</a>, в который передается новый экземпляр\n<a href=\"#!/api/JW.EventParams\" rel=\"JW.EventParams\" class=\"docClass\">JW.EventParams</a>, в данном случае - его потомок <a href=\"#!/api/JW.ValueEventParams\" rel=\"JW.ValueEventParams\" class=\"docClass\">JW.ValueEventParams</a>, который принимает 2 параметра:\nотправитель события (this) и некоторое значение (value). Для своих собственных событий вы можете разрабатывать\nсвои собственные потомки класса <a href=\"#!/api/JW.EventParams\" rel=\"JW.EventParams\" class=\"docClass\">JW.EventParams</a>, но стандартных <a href=\"#!/api/JW.ValueEventParams\" rel=\"JW.ValueEventParams\" class=\"docClass\">JW.ValueEventParams</a>, <a href=\"#!/api/JW.ItemEventParams\" rel=\"JW.ItemEventParams\" class=\"docClass\">JW.ItemEventParams</a> и\n<a href=\"#!/api/JW.ItemValueEventParams\" rel=\"JW.ItemValueEventParams\" class=\"docClass\">JW.ItemValueEventParams</a> в большинстве случаев вполне достаточно.</p>\n\n<p>Событие jWidget крайне просто: циклом перебираются и вызываются все обработчики, которые на него подписаны.\nНет никаких возможностей типа bubbling, preventDefault или stopPropagation. Если хотите наворотить что-то\nподобное - напишите сами или найдите где-нибудь в другом месте. jWidget в этом плане очень скромен, зато быстр.</p>\n\n<p>Следующим шагом мы должны подписаться на эти события и обновлять представление. Чтобы не дублировать код, вынесем\nреализацию обновления элементов mt.TweetView в отдельные методы updateLike и updateRetweet:</p>\n\n<p><strong>public/mt/tweetview/tweetview.js</strong></p>\n\n<pre><code>    renderLike: function(el) {\n        this._updateLike();\n        el.click(this._onLikeClick);\n    },\n\n    renderRetweet: function(el) {\n        this._updateRetweet();\n        el.click(this._onRetweetClick);\n    },\n\n    _updateLike: function() {\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"like\").\n            toggleClass(\"active\", this.tweetData.like).\n            text(this.tweetData.like ? \"Unlike\" : \"Like\");\n    },\n\n    _updateRetweet: function() {\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"retweet\").\n            toggleClass(\"active\", this.tweetData.retweet).\n            text(this.tweetData.retweet ? \"Unretweet\" : \"Retweet\");\n    },\n</code></pre>\n\n<p>Подпишемся на события likeChangeEvent и retweetChangeEvent. На выходе мы получим объекты подписки, которые\nнеобходимо заагрегировать:</p>\n\n<p><strong>public/mt/tweetview/tweetview.js</strong></p>\n\n<pre><code>mt.TweetView = function(tweetData) {\n    this._onLikeClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onLikeClick, this);\n    this._onRetweetClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onRetweetClick, this);\n    mt.TweetView.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.tweetData = tweetData;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.TweetView, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    /*\n    mt.data.Tweet tweetData;\n    */\n\n    // ... какой-то код\n\n    renderLike: function(el) {\n        this._updateLike();\n        this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.tweetData.likeChangeEvent.<a href=\"#!/api/JW.Event-method-bind\" rel=\"JW.Event-method-bind\" class=\"docClass\">bind</a>(this._updateLike, this));\n        el.click(this._onLikeClick);\n    },\n\n    renderRetweet: function(el) {\n        this._updateRetweet();\n        this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.tweetData.retweetChangeEvent.<a href=\"#!/api/JW.Event-method-bind\" rel=\"JW.Event-method-bind\" class=\"docClass\">bind</a>(this._updateRetweet, this));\n        el.click(this._onRetweetClick);\n    },\n\n    // ...\n</code></pre>\n\n<p>Наш код должен работать! Попробуйте запустить его в браузере или откройте ссылку\n<a href=\"http://enepomnyaschih.github.io/mt/1.0.0-4/\">http://enepomnyaschih.github.io/mt/1.0.0-4/</a>\nи покликайте по кнопкам Like/Unlike и Retweet/Unretweet. Более того, вы можете открыть консоль браузера и\nзапустить такую команду:</p>\n\n<pre><code>data.tweets.<a href=\"#!/api/JW.AbstractArray-method-get\" rel=\"JW.AbstractArray-method-get\" class=\"docClass\">get</a>(0).setLike(true)\n</code></pre>\n\n<p>Ваше приложение послушно обновится. Возможно, на таком простом примере еще не ощущаются все преимущества, которые\nвы получаете с архитектурой Model-View, но в более крупных приложениях эта тонна вспомогательного кода\nпо работе с событиями действительно окупает себя.</p>\n\n<p>Еще в этом примере хотелось бы завершить обновление представления mt.TweetView. Мы не учли, что время создания\nтвита со временем возрастает:</p>\n\n<p><p><img src=\"guides/rusample4/time.png\" alt=\"\" width=\"425\" height=\"238\"></p></p>\n\n<p>Сейчас мы сделаем так, чтобы эта метка обновлялась по таймеру.</p>\n\n<p>Менять модель не нужно, изменения затронут только представление mt.TweetView:</p>\n\n<pre><code>mt.TweetView = function(tweetData) {\n    this._updateTime = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._updateTime, this);\n    this._onLikeClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onLikeClick, this);\n    this._onRetweetClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onRetweetClick, this);\n    mt.TweetView.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.tweetData = tweetData;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.TweetView, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    /*\n    mt.data.Tweet tweetData;\n    */\n\n    // ... код\n\n    renderTime: function() {\n        this._updateTime();\n        this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(new <a href=\"#!/api/JW.Interval\" rel=\"JW.Interval\" class=\"docClass\">JW.Interval</a>(this._updateTime, 30000));\n    },\n\n    _updateTime: function() {\n        var timeAgo = new Date().getTime() - this.tweetData.time;\n        var text = this._getTimeString(timeAgo);\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"time\").text(text);\n    },\n\n    // ... код\n</code></pre>\n\n<p>Теперь время публикации твита будет обновляться каждые 30 секунд.</p>\n","title":"Часть 4. События"});