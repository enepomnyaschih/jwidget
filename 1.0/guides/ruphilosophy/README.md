# Философия jWidget

Ниже приведены общие правила, из которых складывается философия фреймворка jWidget.

**Модель и представление**

1. Все основные классы приложения делятся на модель (model) и представление (view).
1. Классы модели хранят данные. Все данные хранятся в модели. Классы модели наследуются от [JW.Class](#!/guide/rujwclass).
1. Классы представления (компоненты) выводят информацию на экран. Классы представления наследуются от [JW.UI.Component](#!/guide/rujwuicomponent).
1. Компонент имеет прямую ссылку на соответствующие модели. При действии пользователя компонент вызывает
соответствующий метод модели, чтобы изменить ее.
1. Модель не имеет прямых ссылок на представление, но выбрасывает события о своем изменении.
1. Представление прослушивает события модели для того, чтобы вовремя обновляться.

**Уничтожение объектов**

1. Все объекты нужно уничтожать, когда они больше не нужны, чтобы освободить ресурсы и отписаться от событий.
1. Уничтожает объект тот, кто спровоцировал его создание.
1. Уничтожать объекты желательно с помощью механизма агрегации, реализуемого методом {@link JW.Class#own own}, или с помощью
встроенных возможностей классов:
    - Метод JW.Property#ownValue
    - Метод JW.AbstractCollection#ownItems
    - Конфигурационные опции JW.Switcher#done и JW.AbstractCollection.Mapper#destroyItem
1. В некоторых случаях объект можно уничтожать явно методом {@link JW.Class#destroy destroy}.

**Data binding**

1. Объекты и DOM-элементы никогда не пересоздаются без причины, а только обновляются путем data binding'а.
1. Data binding одиночных значений осуществляется с помощью класса [JW.Property](#!/guide/rujwproperty) и его хелперов.

**Data binding коллекций**

1. Данные и компоненты структурированы на базе трех классов коллекций:
массивов ([JW.AbstractArray](#!/guide/rujwabstractarray)),
словарей ([JW.AbstractMap](#!/guide/rujwabstractmap)) и
множеств ([JW.AbstractSet](#!/guide/rujwabstractset)). Все коллекции имеют общие интерфейсы
([JW.AbstractCollection](#!/guide/rujwabstractcollection),
[JW.IndexedCollection](#!/guide/rujwindexedcollection)). О сфере использования, преимуществах и недостатках каждой
коллекции читайте общую теорию алгоритмов и структур данных.
1. Каждая коллекция имеет две реализации: простая (JW.Array, JW.Map, JW.Set) и оповещающая
(JW.ObservableArray, JW.ObservableMap, JW.ObservableSet). Оповещающие коллекции выбрасывают события о своем изменении.
1. Не нужно прослушивать все события оповещающих коллекций вручную. Вместо этого предлагается использовать
стандартные [синхронизаторы jWidget](#!/guide/rujwabstractcollection). Синхронизаторы позволяют наладить связь между коллекциями.
1. Коллекции замкнуты относительно синхронизаторов. Всякое изменение одной коллекции влечет не более одного
изменения другой коллекции, связанной с первой с помощью стандартного синхронизатора.
1. Почти на всякое действие пользователя должно производиться одно ручное изменение некоторой коллекции.
Все остальные коллекции (включая коллекции компонентов представления) должны синхронизироваться автоматически
с помощью синхронизаторов.
1. Для правильной и быстрой работы приложения достаточно один раз правильно сконфигурировать синхронизаторы по
аналогии с тем, как конфигурируются индексы и внешние ключи таблиц баз данных.
