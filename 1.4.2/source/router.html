<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*!
	jWidget Router plugin

	http://enepomnyaschih.github.io/jwidget/#!/api/JW.Plugins.Router

	Copyright (C) 2015 Egor Nepomnyaschih

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public License
	along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

JW.Plugins = JW.Plugins || {};

<span id='JW-Plugins-Router-method-constructor'><span id='JW-Plugins-Router'>/**
</span></span> * @class
 *
 * URL router. Converts incoming URL part (hash or pathname) to a target object and passes tail string to it
 * for further routing.
 *
 * ## How it works
 *
 * Router takes an incoming string JW.Property (for example, JW.UI.hash), parses it and provides an outcoming
 * JW.Property. Outcoming property may contain any object you want. If it implements JW.Plugins.Router.Routable
 * interface (i.e. has {@link JW.Plugins.Router.Routable#setPath setPath} method), path tail is passed to it
 * for further routing. It is convenient to use a nested router object to process path tail as well.
 *
 * Example:
 *
 * &lt;iframe style=&quot;border: 1px solid green; padding: 10px;&quot; width=&quot;700&quot; height=&quot;300&quot; src=&quot;http://enepomnyaschih.github.io/mt/1.4.1/router.html&quot;&gt;&lt;/iframe&gt;
 *
 * Source code of the example is not minified so you can review it using &quot;View source code of the frame&quot; context
 * menu item in your browser.
 *
 * In this example, JW.UI.hash is passed to Application's router object, and it builds a target property containing
 * a child component to render:
 *
 * - &quot;inbox/*&quot; URL is mapped to Inbox component
 * - &quot;compose/*&quot; URL is mapped to Compose component
 * - &quot;settings/*&quot; URL is mapped to Settings component
 * - blank URL is automatically redirected to inbox
 * - any other URL is mapped to NotFound component
 *
 * Code:
 *
 *     {@link JW.UI.Component#beforeRender beforeRender}: function(el) {
 *         this.{@link JW.Class#method-_super _super}();
 *         this.router = this.{@link JW.Class#own own}(new JW.Plugins.Router({
 *             {@link JW.Plugins.Router#cfg-path path}: JW.UI.hash,
 *             {@link JW.Plugins.Router#cfg-handler handler}: {
 *                 {@link JW.Plugins.Router.Handler#cfg-routes routes}: {
 *                     // passing path to inbox constructor lets us avoid an unneccessary redirection
 *                     &quot;inbox&quot;   : function(path) { return new Inbox(path); },
 *                     &quot;compose&quot; : function() { return new Compose(); },
 *                     &quot;settings&quot;: function() { return new Settings(); },
 *                     &quot;&quot;        : function() { return new JW.Plugins.Router.Redirector(&quot;inbox&quot;); }
 *                 },
 *                 {@link JW.Plugins.Router.Handler#cfg-notFound notFound}: function(route) { return new NotFound(route); }
 *             },
 *             {@link JW.Plugins.Router#cfg-scope scope}: this
 *         }));
 *         this.router.{@link JW.Plugins.Router#update update}();
 *     },
 *
 *     renderPage: function() {
 *         return this.router.target;
 *     },
 *
 * Notice that {@link JW.Plugins.Router#update update} method is called separately, after router construction.
 * It is implemented so to make sure that this.router field is assigned before routing. Sometimes it is crucial
 * (in an example below, this.router is used in {@link JW.Plugins.Router#cfg-handler handler}).
 *
 * Inbox implements JW.Plugins.Router.Routable interface, and therefore provides further routing for all
 * &quot;inbox/*&quot; URL's. Applacation router passes URL tail string to
 * Inbox constructor and {@link JW.Plugins.Router.Routable#setPath setPath} method to do that.
 *
 * - &quot;inbox&quot; URL is mapped to EmailList component
 * - &quot;inbox/&amp;lt;id&amp;gt;&quot; URL is mapped to Email component if an email with such ID exists
 * - &quot;inbox/&amp;lt;id&amp;gt;&quot; URL is mapped to EmailNotFound component if there's no email with such ID
 *
 * Code:
 *
 *     renderContent: function() {
 *         this.router = this.{@link JW.Class#own own}(new JW.Plugins.Router({
 *             {@link JW.Plugins.Router#cfg-path path}: this.path,
 *             {@link JW.Plugins.Router#cfg-handler handler}: function(id) {
 *                 if (!id) {
 *                     return new EmailList(this.emails);
 *                 }
 *                 var email = this.emails.search(JW.byValue(&quot;id&quot;, id));
 *                 return (email != null) ? new Email(email, this.router) : new EmailNotFound(id);
 *             },
 *             {@link JW.Plugins.Router#cfg-scope scope}: this
 *         }));
 *         this.router.update();
 *         return this.router.{@link JW.Plugins.Router#property-target target}
 *     },
 *
 *     {@link JW.Plugins.Router.Routable#setPath setPath}: function(path) {
 *         this.path.{@link JW.Property#set set}(path);
 *     }
 *
 * ## Routing flow
 *
 * Routing is performed in three steps:
 *
 * - Incoming path string is parsed using {@link JW.Plugins.Router#cfg-separator separator} callback into two tokens:
 * route and argument. Route will be used to process this single routing step, and argument will be passed to a
 * {@link JW.Plugins.Router#property-target target} for further routing. Make sure that separator never returns two
 * routes which have the same target. For example, if both &quot;&quot; and &quot;inbox&quot;
 * lead to Inbox component, make sure that separator function returns the same route for them, for example, &quot;&quot;.
 * Otherwise, expect your target component to be recreated when user switches back and forth between &quot;&quot; and &quot;inbox&quot;.
 * If separator function returns null or undefined route, it is automatically mapped to blank string.
 * Separator can be specified as a string. In this case, it is passed to JW.Plugins.Router#makeSeparator
 * method - see it for more details. Separator defaults to &quot;/&quot;.
 * - The route returned by separator is assigned to {@link JW.Plugins.Router#property-route route} property. If it
 * is changed, the next steps are following:&lt;ul&gt;
 * &lt;li&gt;Null is assigned to {@link JW.Plugins.Router#property-target target} property&lt;/li&gt;
 * &lt;li&gt;Previous target is being destroyed&lt;/li&gt;
 * &lt;li&gt;{@link JW.Plugins.Router#cfg-handler handler} function is called to build a new target&lt;/li&gt;
 * &lt;li&gt;Result is assigned to {@link JW.Plugins.Router#property-target target} property&lt;/li&gt;&lt;/ul&gt;
 * - If target implements JW.Plugins.Router.Routable interface, its {@link JW.Plugins.Router.Routable#setPath setPath}
 * method is called with an argument string provided by separator callback
 *
 * ## Redirection
 *
 * As of jWidget 1.4.1, router supports redirection logic. You can perform redirections manually, whenever you need,
 * or automatically when some route is entered.
 *
 * For manual redirection, use router.{@link JW.Plugins.Router#method-redirect redirect} instance method or
 * JW.Plugins.Router.{@link JW.Plugins.Router#static-method-redirect redirect} static method. The instance method performs redirection inside
 * this router. The static method performs redirection in a current top router - it is easier to use, because you
 * are not obligated to pass the router into child components explicitly, however, it is suitable only if you know
 * exactly which router sits on top of router stack at any moment.
 *
 *     this.router.{@link JW.Plugins.Router#method-redirect redirect}(&quot;inbox&quot;); // redirection in this router
 *     JW.Plugins.Router.{@link JW.Plugins.Router#static-method-redirect redirect}(&quot;inbox&quot;); // redirection in top router
 *
 * You may modify the redirection scope by passing a second argument. Passing 0 changes absolute path.
 * This is useful for global navigation.
 *
 *     JW.Plugins.Router.{@link JW.Plugins.Router#static-method-redirect redirect}(&quot;inbox&quot;, 0); // absolute redirection
 *
 * Passing positive number performs redirection in N'th router up from the bottom of router stack. Assume that current
 * full path is &quot;inbox/123/reply&quot; or &quot;all-emails/123/reply&quot; and you want to get back to &quot;inbox&quot; or &quot;all-emails&quot;,
 * depending on what is currently opened - here's the easiest way to do that:
 *
 *     JW.Plugins.Router.{@link JW.Plugins.Router#static-method-redirect redirect}(&quot;&quot;, 1); // absolute redirection shifted by 1
 *
 * Passing negative number performs redirection in -N'th router down from the top of router stack. For example,
 * passing -1 gets you back to a parent router and changes its subpath to a specified one. Assume that your
 * Inbox component needs to have a link to settings page. Considering that you don't know how many routers
 * are active above inbox at the moment, it is a smart choice to use instance redirection with -1 shift.
 *
 *     this.router.{@link JW.Plugins.Router#method-redirect redirect}(&quot;settings&quot;, -1); // redirection in parent router
 *
 * Redirections should not occur inside router's update cycle, otherwise an error is thrown. That's why you can
 * not call redirection methods inside a handler function. Use JW.Plugins.Router.Redirector instead - this is a
 * UI component which waits for current isolate to complete and performs a redirection after that.
 *
 *     this.router = this.{@link JW.Class#own own}(new JW.Plugins.Router({
 *         {@link JW.Plugins.Router#cfg-path path}: JW.UI.hash,
 *         {@link JW.Plugins.Router#cfg-handler handler}: {
 *             {@link JW.Plugins.Router.Handler#cfg-routes routes}: {
 *                 &quot;inbox&quot; : function(path) { return new Inbox(path); },
 *                 &quot;&quot;      : function() { return new JW.Plugins.Router.Redirector(&quot;inbox&quot;); }
 *             }
 *         }
 *         {@link JW.Plugins.Router#cfg-scope scope}: this
 *     }));
 *
 * **IMPORTANT:** If you define custom {@link JW.Plugins.Router#cfg-separator separator} function, you must also define
 * an opposite {@link JW.Plugins.Router#cfg-joiner joiner} function for redirections to work properly.
 *
 * @extends JW.Class
 *
 * @constructor
 * @param {Object} config Configuration (see Config options).
 */
JW.Plugins.Router = function(config) {
	JW.Plugins.Router._super.call(this);
	config = config || {};
	this.separator = config.separator || /^\/*([^?\/]+)(?:\/(.*)|(\?.*))?$/;
	if (JW.isRegExp(this.separator)) {
		this.separator = JW.Plugins.Router.makeSeparator(this.separator);
	}
	this.joiner = config.joiner || &quot;/&quot;;
	if (typeof this.joiner === &quot;string&quot;) {
		this.joiner = JW.Plugins.Router.makeJoiner(this.joiner);
	}
	this.handler = config.handler || {};
	if (typeof this.handler === &quot;object&quot;) {
		this.handler = JW.Plugins.Router.makeHandler(this.handler);
	}
	this.scope = config.scope || this;
	this._pathCreated = config.path == null;
	this.path = this._pathCreated ? new JW.Property() : config.path;
	this._targetCreated = config.target == null;
	this.target = this._targetCreated ? new JW.Property() : config.target;
	this.route = new JW.Property();
	this.own(new JW.Switcher([this.route], {
		init: function(route) {
			this.target.set(this.handler.call(this.scope, route, this.arg) || null);
		},
		done: function(route) {
			var target = this.target.get();
			this.target.set(null);
			if (target != null) {
				target.destroy();
			}
		},
		scope: this
	}));
	this.arg = null;
	JW.Plugins.Router._routerStack.push(this);
	this._active = false;
	this.own(this.path.changeEvent.bind(this.update, this));
};

JW.extend(JW.Plugins.Router, JW.Class, {
<span id='JW-Plugins-Router-cfg-path'>	/**
</span>	 * @cfg {JW.Property} path `&lt;string&gt;` Source path string. If omitted, router creates and aggregates this property
	 * automatically.
	 */
<span id='JW-Plugins-Router-cfg-target'>	/**
</span>	 * @cfg {JW.Property} target `&lt;JW.Plugins.Router.Routable&gt;` Target routable object. If omitted, router creates and
	 * aggregates this property automatically.
	 */
<span id='JW-Plugins-Router-cfg-separator'>	/**
</span>	 * @cfg {Function|RegExp} separator
	 *
	 * `separator(path: string): string|Array&lt;string&gt;`
	 *
	 * Path separator. Parses incoming path to two tokens: route and argument. Route will be used to process this
	 * single routing step, and argument will be passed to a {@link #property-target} for further routing.
	 *
	 * Make sure that separator never returns two routes which have the same target. For example, if both &quot;&quot; and &quot;inbox&quot;
	 * lead to Inbox component, make sure that separator function returns the same route for them, for example, &quot;&quot;.
	 * Otherwise, expect your target component to be recreated when user switches back and forth between &quot;&quot; and &quot;inbox&quot;.
	 *
	 * If separator function returns null or undefined route, it is automatically mapped to blank string.
	 *
	 * **IMPORTANT:** If you define custom {@link JW.Plugins.Router#cfg-separator separator} function, you must also define
	 * an opposite {@link JW.Plugins.Router#cfg-joiner joiner} function for redirections to work properly.
	 *
	 * Separator function can be specified as a regular expression.
	 * In this case, it is built with JW.Plugins.Router#makeSeparator method - see it for more details.
	 *
	 * Defaults to `/^\/*([^?\/]+)(?:\/(.*)|(\?.*))?$/`, which:
	 *
	 * - Trims leading /
	 * - Looks for the first / or ?
	 * - Uses first part as route
	 * - Uses second part as argument. Questionmark ? is included to the argument, slash / is not
	 *
	 * Examples:
	 *
	 * &lt;table&gt;
	 *   &lt;tr&gt;&lt;td&gt;Incoming path&lt;/td&gt;&lt;td&gt;Resulting route&lt;/td&gt;&lt;td&gt;Resulting argument&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;&quot; or null&lt;/td&gt;&lt;td&gt;&quot;&quot;&lt;/td&gt;&lt;td&gt;null&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;null&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox/&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox/1&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;1&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox/1/edit&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;1/edit&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;/inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;null&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;/inbox/&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;///inbox///&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;//&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox?id=1&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;?id=1&quot;&lt;/td&gt;&lt;/tr&gt;
	 * &lt;/table&gt;
	 */
<span id='JW-Plugins-Router-cfg-joiner'>	/**
</span>	 * @cfg {Function|string} joiner
	 *
	 * `joiner(route: string, arg: string): string`
	 *
	 * Path joiner. Opposite to #separator. Used for redirections. Joins incoming route and argument to a full pass.
	 *
	 * Joiner can be specified as a string. In this case, it is built with JW.Plugins.Router#makeJoiner
	 * method - see it for more details.
	 *
	 * Defaults to &quot;/&quot;.
	 */
<span id='JW-Plugins-Router-cfg-handler'>	/**
</span>	 * @cfg {Function|JW.Plugins.Router.Handler} handler
	 *
	 * `handler(route: string, arg: string): JW.Plugins.Router.Routable`
	 *
	 * Route handler. Creates a routable object by route string.
	 *
	 * Example:
	 *
	 *     handler: function(route, arg) {
	 *         var doc = this.docs.get(route);
	 *         return doc ? doc.createView(this.data, arg) : new Page404(route);
	 *     },
	 *     scope: this
	 *
	 * Handler can be specified as an object matching JW.Plugins.Router.Handler interface.
	 * In this case, it is built with JW.Plugins.Router#makeHandler method - see it for more details.
	 *
	 * Default handler function returns null no matter what which makes no sense. Please specify always.
	 */
<span id='JW-Plugins-Router-cfg-scope'>	/**
</span>	 * @cfg {Object} scope Call scope for {@link #cfg-separator} and {@link #cfg-handler}.
	 */
<span id='JW-Plugins-Router-property-target'>	/**
</span>	 * @property {JW.Property} target `&lt;JW.Plugins.Router.Routable&gt;` Target routable object.
	 */
<span id='JW-Plugins-Router-property-route'>	/**
</span>	 * @property {JW.Property} route `&lt;string&gt;` Current route. Read-only.
	 */
<span id='JW-Plugins-Router-property-arg'>	/**
</span>	 * @property {string} arg Current path argument. Assigned right before #route modification. Read-only.
	 */

	destroyObject: function() {
		if (this._active) {
			throw new Error(&quot;Router can not be destroyed during its update cycle.&quot;);
		}
		if (JW.Array.getLast(JW.Plugins.Router._routerStack) !== this) {
			throw new Error(&quot;Router can not be destroyed because it is not on top of router stack. &quot; +
				&quot;Make sure that you don't create two subrouters in parallel. &quot; +
				&quot;Make sure that you destroy all routers correctly.&quot;);
		}
		JW.Plugins.Router._routerStack.pop();
		if (this._targetCreated) {
			this.target.destroy();
		}
		if (this._pathCreated) {
			this.path.destroy();
		}
		this.route.destroy();
		this.separator = null;
		this.handler = null;
		this.scope = null;
		this.path = null;
		this.target = null;
		this.route = null;
		this._super();
	},

<span id='JW-Plugins-Router-method-update'>	/**
</span>	 * Updates route focibly.
	 */
	update: function() {
		if (this._active) {
			throw new Error(&quot;Can't update router because its update cycle is already active. &quot; +
				&quot;Suggest using JW.Plugins.Router.Redirector or moving URL redirection to an asyncronous callback.&quot;);
		}
		this._active = true;
		var path = this.path.get();
		var pair = (path == null) ? null : this.separator.call(this.scope, path);
		var route = pair;
		this.arg = null;
		if (pair != null &amp;&amp; (typeof pair !== &quot;string&quot;)) {
			route = pair[0];
			if (pair.length &gt; 1) {
				this.arg = pair[1];
			}
		}
		this.route.set(route || &quot;&quot;);
		var target = this.target.get();
		if (target != null &amp;&amp; (typeof target.setPath === &quot;function&quot;)) {
			target.setPath(this.arg);
		}
		this._active = false;
	},

<span id='JW-Plugins-Router-method-join'>	/**
</span>	 * Calls #joiner function with specified arguments.
	 *
	 * @param {string} route The route.
	 * @param {string} arg=null The path argument.
	 * @returns {string} Path string.
	 */
	join: function(route, arg) {
		return this.joiner.call(this.scope, route, arg);
	},

<span id='JW-Plugins-Router-method-getFullPath'>	/**
</span>	 * Returns full redirection path pretending this router being on top of router stack.
	 * See **Redirection** topic in class description for more details.
	 *
	 * @param {string} path Redirection path.
	 * @param {number} [scope] Redirection scope. Defaults to current scope.
	 * @returns {string} Full path string.
	 */
	getFullPath: function(path, scope) {
		return JW.Plugins.Router.getFullPath(path, this, scope);
	},

<span id='JW-Plugins-Router-method-redirect'>	/**
</span>	 * Performs redirection to result of {@link #method-getFullPath} method.
	 *
	 * @param {string} path Redirection path.
	 * @param {number} [scope] Redirection scope. Defaults to current scope.
	 */
	redirect: function(path, scope) {
		JW.Plugins.Router.redirect(path, this, scope);
	}
});

JW.apply(JW.Plugins.Router, {
	_routerStack: [],

<span id='JW-Plugins-Router-static-method-getFullPath'>	/**
</span>	 * Returns full redirection path pretending the specified router being on top of router stack.
	 * See **Redirection** topic in class description for more details.
	 *
	 * @static
	 * @param {string} path Redirection path.
	 * @param {JW.Plugins.Router} [router] Top router to pretend. Defaults to top router in current router stack.
	 * @param {number} [scope] Redirection scope. Defaults to current scope.
	 * @returns {string} Full path string.
	 */
	getFullPath: function(path, router, scope) {
		if (typeof router === &quot;number&quot;) {
			scope = router;
			router = null;
		}
		var routers = JW.Plugins.Router._routerStack;
		if (routers.length == 0) {
			throw new Error(&quot;No routers exist in the system.&quot;);
		}
		var routerIndex = router ? JW.Array.indexOf(routers, router) : (routers.length - 1);
		if (routerIndex === -1) {
			throw new Error(&quot;Current router stack doesn't contain the specified router.&quot;);
		}
		var index = (scope == null) ? routerIndex :
			(scope &gt;= 0) ? scope : (routerIndex + scope);
		if (index &lt; 0 || index &gt; routerIndex) {
			throw new Error(router ?
				(&quot;The specified router has index &quot; + routerIndex + &quot; in current router stack&quot;) :
				(&quot;Current router stack contains only &quot; + routers.length + &quot; routers.&quot;));
		}
		for (var i = index - 1; i &gt;= 0; --i) {
			path = routers[i].join(routers[i].route.get(), path);
		}
		return path;
	},

<span id='JW-Plugins-Router-static-method-redirect'>	/**
</span>	 * Performs redirection to result of {@link #static-method-getFullPath} method.
	 *
	 * @static
	 * @param {string} path Redirection path.
	 * @param {JW.Plugins.Router} [router] Top router to pretend. Defaults to top router in current router stack.
	 * @param {number} [scope] Redirection scope. Defaults to current scope.
	 */
	redirect: function(path, router, scope) {
		if (typeof router === &quot;number&quot;) {
			scope = router;
			router = null;
		}
		var fullPath;
		try {
			fullPath = JW.Plugins.Router.getFullPath(path, router, scope);
			if (JW.Plugins.Router._routerStack[0]._active) {
				throw new Error(&quot;Update cycle is already active. &quot; +
					&quot;Suggest using JW.Plugins.Router.Redirector or moving URL redirection to an asyncronous callback.&quot;);
			}
		} catch (e) {
			throw new Error(&quot;Can not perform URL redirection to &quot; + path + &quot; in scope &quot; +
				((scope == null) ? &quot;CURRENT&quot; : scope) + &quot;: &quot; + e.message);
		}
		JW.Plugins.Router._routerStack[0].path.set(fullPath);
	},

<span id='JW-Plugins-Router-static-method-makeSeparator'>	/**
</span>	 * @method makeSeparator
	 *
	 * Converts RegExp to separator function. The first token ($1) of path is used as a
	 * route, and second on ($2) is used as an argument. If path is null, it is assumed to be &quot;&quot;.
	 *
	 * @static
	 * @param {RegExp} regexp Regular expression.
	 * @returns {Function} Separator function.
	 */
	makeSeparator: function(regexp) {
		return function(path) {
			var result = regexp.exec(path || &quot;&quot;);
			return result ? result.slice(1) : &quot;&quot;;
		};
	},

<span id='JW-Plugins-Router-static-method-makeJoiner'>	/**
</span>	 * @method makeJoiner
	 *
	 * Converts joiner symbol/string to joiner function. Joins incoming route/argument pair via the specified string.
	 * Leading joiner symbols in argument are trimmed. If argument is null or blank, returns route.
	 *
	 * Examples:
	 *
	 * &lt;table&gt;
	 *   &lt;tr&gt;&lt;td&gt;Incoming route&lt;/td&gt;&lt;td&gt;Incoming argument&lt;/td&gt;&lt;td&gt;Separator&lt;/td&gt;&lt;td&gt;Resulting path&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;&quot;&lt;/td&gt;&lt;td&gt;&quot;&quot;&lt;/td&gt;&lt;td&gt;&quot;/&quot;&lt;/td&gt;&lt;td&gt;&quot;&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;&quot;&lt;/td&gt;&lt;td&gt;&quot;/&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;1&quot;&lt;/td&gt;&lt;td&gt;&quot;/&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox/1&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;1/reply&quot;&lt;/td&gt;&lt;td&gt;&quot;/&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox/1/reply&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;/1/reply&quot;&lt;/td&gt;&lt;td&gt;&quot;/&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox/1/reply&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;/1/reply/&quot;&lt;/td&gt;&lt;td&gt;&quot;/&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox/1/reply/&quot;&lt;/td&gt;&lt;/tr&gt;
	 *   &lt;tr&gt;&lt;td&gt;&quot;inbox&quot;&lt;/td&gt;&lt;td&gt;&quot;///1/reply///&quot;&lt;/td&gt;&lt;td&gt;&quot;/&quot;&lt;/td&gt;&lt;td&gt;&quot;inbox/1/reply///&quot;&lt;/td&gt;&lt;/tr&gt;
	 * &lt;/table&gt;
	 *
	 * @static
	 * @param {string} joiner Joiner symbol/string.
	 * @returns {Function} Joiner function.
	 */
	makeJoiner: function(joiner) {
		var trimmer = new RegExp(&quot;^(?:&quot; + joiner.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&amp;') + &quot;)*&quot;);
		return function(route, arg) {
			return arg ? (route + joiner + arg.replace(trimmer, &quot;&quot;)) : route;
		};
	},

<span id='JW-Plugins-Router-static-method-makeHandler'>	/**
</span>	 * @method makeHandler
	 *
	 * Converts handler configuration object to handler function. Configuration has two optional fields:
	 *
	 * - {@link JW.Plugins.Router.Handler#cfg-routes routes} is a mapping from route string to a handler function for
	 * this specific route. The function takes the path argument as an argument.
	 * - {@link JW.Plugins.Router.Handler#cfg-notFound notFound} is a handler function for all routes which don't
	 * match {@link JW.Plugins.Router.Handler#cfg-routes routes} mapping. The function takes route and path argument as
	 * arguments.
	 *
	 * Example:
	 *
	 *     this.router = this.{@link JW.Class#own own}(new JW.Plugins.Router({
	 *         {@link JW.Plugins.Router#cfg-path path}: JW.UI.hash,
	 *         {@link JW.Plugins.Router#cfg-handler handler}: {
	 *             {@link JW.Plugins.Router.Handler#cfg-routes routes}: {
	 *                 &quot;inbox&quot;   : function(arg) { return new Inbox(arg);        },
	 *                 &quot;&quot;        : function(arg) { return new JW.UI.Component(); }
	 *             },
	 *             {@link JW.Plugins.Router.Handler#cfg-notFound notFound}: function(route, arg) { return new NotFound(route, arg); }
	 *         },
	 *         {@link JW.Plugins.Router#cfg-scope scope}: this
	 *     }));
	 *
	 * @static
	 * @param {JW.Plugins.Router.Handler} configuration Handler configuration object.
	 * @returns {Function} Handler function.
	 */
	makeHandler: function(config) {
		return function(route, arg) {
			return config.routes[route] ? config.routes[route].call(this, arg) :
				config.notFound ? config.notFound.call(this, route, arg) : null;
		};
	}
});

<span id='JW-Plugins-Router-Handler'>/**
</span> * @class JW.Plugins.Router.Handler
 *
 * Interface for router {@link JW.Plugins.Router#cfg-handler handler} configuration object.
 * Converted to a function by JW.Plugins.Router#makeHandler method.
 */
<span id='JW-Plugins-Router-Handler-cfg-routes'>/**
</span> * @cfg {Object} routes
 *
 * Mapping from route string to a handler function for this specific route.
 * The function is determined as:
 *
 * `route(arg: string): JW.Plugins.Router.Routable`
 */
<span id='JW-Plugins-Router-Handler-cfg-notFound'>/**
</span> * @cfg {Function} notFound
 *
 * Function for all routes which don't match {@link JW.Plugins.Router.Handler#cfg-routes routes} mapping.
 * The function is determined as:
 *
 * `notFound(route: string, arg: string): JW.Plugins.Router.Routable`
 */

<span id='JW-Plugins-Router-Routable'>/**
</span> * @class JW.Plugins.Router.Routable
 *
 * Interface for routable {@link JW.Plugins.Router#cfg-target target} object.
 */
<span id='JW-Plugins-Router-Routable-method-setPath'>/**
</span> * @method setPath
 *
 * Accepts a new path argument from parent router for further routing. This method is optional.
 *
 * @param {string} path Path argument.
 */

<span id='JW-Plugins-Router-Redirector-method-constructor'><span id='JW-Plugins-Router-Redirector'>/**
</span></span> * @class JW.Plugins.Router.Redirector
 *
 * UI component which performs router redirection once current isolate is complete (asyncronously).
 * See **Redirection** topic in JW.Plugins.Router class description for details.
 *
 * You may destroy redirector to cancel redirection before it occurs.
 *
 * @extends JW.UI.Component
 * @constructor
 * @param {string} path Redirection path.
 * @param {JW.Plugins.Router} [router] Top router to pretend. Defaults to top router in current router stack.
 * @param {number} [scope] Redirection scope. Defaults to current scope.
 */
JW.Plugins.Router.Redirector = function() {
	JW.Plugins.Router.Redirector._super.call(this);
	this.args = JW.args(arguments);
	this.own(new JW.Timeout(this.redirect, this));
};

JW.extend(JW.Plugins.Router.Redirector, JW.UI.Component, {
	redirect: function() {
		JW.Plugins.Router.redirect.apply(JW.Plugins.Router, this.args);
	}
});
</pre>
</body>
</html>
