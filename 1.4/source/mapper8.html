<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
MIT License

Copyright (c) 2020 Egor Nepomnyaschih

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

<span id='JW-Mapper-method-constructor'><span id='JW-Mapper'>/**
</span></span> * @class
 * `&lt;T&gt;` Watches source {@link JW.Property properties} modification and recreates
 * a target property using specified functions. Unlike JW.Functor,
 * lets you destroy a previously created value. Also, mapper resets the target
 * property value to null on destruction.
 *
 *     var count = new JW.Property(1);
 *     var units = new JW.Property(&quot;apples&quot;);
 *     var target = new JW.Property();
 *     // Next command prints &quot;Init 1 apples&quot; to console
 *     var mapper = new JW.Mapper([ count, units ], {
 *         {@link #cfg-target target}: target,
 *         {@link JW.Mapper#createValue createValue}: function(value, units) {
 *             var result = value + &quot; &quot; + units;
 *             console.log(&quot;Init &quot; + result);
 *             return result;
 *         },
 *         {@link JW.Mapper#destroyValue destroyValue}: function(result, value, units) {
 *             console.log(&quot;Done &quot; + result);
 *         },
 *         {@link JW.Mapper#scope scope}: this
 *     });
 *     assert(&quot;1 apples&quot;, target.{@link JW.Property#get get}());
 *
 *     // Next command prints &quot;Done 1 apples&quot; and &quot;Init 2 apples&quot;
 *     count.{@link JW.Property#set set}(2);
 *     assert(&quot;2 apples&quot;, target.{@link JW.Property#get get}());
 *
 *     // Next command prints &quot;Done 2 apples&quot;
 *     mapper.{@link JW.Mapper#destroy destroy}();
 *     assert(null, target.{@link JW.Property#get get}());
 *
 * If target is omitted in constructor, it is created automatically. Notice
 * that mapper owns it in this case.
 *
 *     var source = new JW.Property(1);
 *     var mapper = new JW.Mapper([ source ], {
 *         {@link JW.Mapper#createValue createValue}: function(value) {
 *             return value + &quot; apples&quot;;
 *         },
 *         {@link JW.Mapper#scope scope}: this
 *     });
 *     var target = mapper.{@link JW.Mapper#property-target target};
 *     assert(&quot;1 apples&quot;, target.{@link JW.Property#get get}());
 *     mapper.{@link JW.Mapper#destroy destroy}();
 *
 * In simple cases, JW.Property#$$mapValue and JW.Property#$$mapObject shorthand methods
 * can be used instead. They return the target property right away:
 *
 *     var source = new JW.Property(1);
 *     var target = source.{@link JW.Property#$$mapValue $$mapValue}(function(value) { return value + &quot; apples&quot;; });
 *     assert(&quot;1 apples&quot;, target.{@link JW.Property#get get}());
 *     target.{@link JW.Property#destroy destroy}();
 *
 * On source property change, next flow will take a place:
 *
 * 1. New value is created
 * 1. Target property is set to new value
 * 1. Old value is destroyed
 *
 * In contrast, JW.Switcher's flow is opposite:
 *
 * 1. {@link JW.Switcher#done done} method is called
 * 1. {@link JW.Switcher#init init} method is called
 *
 * Common use case for mapper is replaceable child component creation by data:
 *
 *     var MyComponent = function(document) {
 *         MyComponent.{@link JW.Class#static-property-_super _super}.call(this);
 *         this.document = document;
 *     };
 *     
 *     JW.extend(MyComponent, JW.UI.Component, {
 *         // JW.Property&lt;Document&gt; document;
 *         
 *         renderDocument: function() {
 *             return this.{@link JW.Class#own own}(this.document.{@link JW.Property#$$mapObject $$mapObject}(function(document) {
 *                 return new DocumentView(document);
 *             }, this);
 *         }
 *     });
 *     
 *     JW.UI.template(MyComponent, {
 *         main:
 *             '&lt;div jwclass=&quot;my-component&quot;&gt;' +
 *                 '&lt;div jwid=&quot;document&quot;&gt;&lt;/div&gt;' +
 *             '&lt;/div&gt;'
 *     });
 *
 * Also, mapper allows you to chain property calculations. Assume that you have several folders and
 * several documents in each folder. One folder is selected, and each folder has a selected document there. You
 * want to create a document view by a currently selected folder and a currently selected document there. Do this:
 *
 *     var Folder = function() {
 *         Folder.{@link JW.Class#_super _super}.call(this);
 *         this.selectedDocument = this.{@link JW.Class#own own}(new JW.Property());
 *     };
 *     
 *     JW.extend(Folder, JW.Class);
 *     
 *     var App = function() {
 *         App.{@link JW.Class#_super _super}.call(this);
 *         this.selectedFolder = this.{@link JW.Class#own own}(new JW.Property());
 *         this.documentView = this.{@link JW.Class#own own}(new JW.Property());
 *         this.{@link JW.Class#own own}(new JW.Mapper([this.selectedFolder], {
 *             {@link JW.Mapper#cfg-createValue createValue}: function(folder) {
 *                 return new JW.Mapper([folder.selectedDocument], {
 *                     {@link JW.Mapper#cfg-target target}: this.documentView,
 *                     {@link JW.Mapper#cfg-createValue createValue}: function(document) {
 *                         return new DocumentView(folder, document);
 *                     },
 *                     {@link JW.Mapper#cfg-destroyValue destroyValue}: JW.destroy,
 *                     {@link JW.Mapper#cfg-scope scope}: this
 *                 });
 *             },
 *             {@link JW.Mapper#cfg-destroyValue destroyValue}: JW.destroy,
 *             {@link JW.Mapper#cfg-scope scope}: this
 *         }));
 *     };
 *     
 *     JW.extend(App, JW.Class);
 *
 * By default, mapper doesn't calls the callbacks if at least one of the source values is null. You can change it
 * via {@link JW.Mapper#acceptNull acceptNull} option.
 *
 * @extends JW.Class
 *
 * @constructor
 * @param {Array} source `&lt;JW.Property&gt;` Source properties.
 * @param {Object} config Configuration (see Config options).
 */
JW.Mapper = function(sources, config) {
	JW.Mapper._super.call(this);
	this.sources = sources;
	this.createValue = config.createValue;
	this.destroyValue = config.destroyValue;
	this.scope = config.scope || this;
	this._targetCreated = config.target == null;
	this.target = this._targetCreated ? new JW.Property() : config.target;
	this.acceptNull = config.acceptNull || false;
	this._sourceValues = null;
	this._targetValue = null;
	this.update();
	JW.Array.every(sources, this.watch, this);
};

JW.extend(JW.Mapper, JW.Class, {
<span id='JW-Mapper-cfg-target'>	/**
</span>	 * @cfg {JW.Property} target
	 * `&lt;T&gt;` Target property. By default, created automatically.
	 */
<span id='JW-Mapper-cfg-createValue'>	/**
</span>	 * @cfg {Function} createValue
	 *
	 * `createValue(... sourceValues): T`
	 *
	 * Calculates target property value based on source property values.
	 */
<span id='JW-Mapper-cfg-destroyValue'>	/**
</span>	 * @cfg {Function} [destroyValue]
	 *
	 * `destroyValue(targetValue: T, ... sourceValues)`
	 *
	 * Optional. Destroys target property value.
	 */
<span id='JW-Mapper-cfg-scope'>	/**
</span>	 * @cfg {Object} scope
	 * Optional. Call scope of #createValue and #destroyValue.
	 */
<span id='JW-Mapper-cfg-acceptNull'>	/**
</span>	 * @cfg {Boolean} [acceptNull=false]
	 * Optional. If false, functions won't be called if at least one of the source values is null. Target value
	 * is resetted to null in this case.
	 */
<span id='JW-Mapper-property-sources'>	/**
</span>	 * @property {Array} sources `&lt;JW.Property&gt;` Source properties.
	 */
<span id='JW-Mapper-property-target'>	/**
</span>	 * @property {JW.Property} target `&lt;T&gt;` Target property.
	 */
	
	// override
	destroyObject: function() {
		var oldValue = this.target.get();
		if (oldValue === this._targetValue) {
			this.target.set(null);
		}
		this._done();
		if (this._targetCreated) {
			this.target.destroy();
		}
		this.sources = null;
		this.createValue = null;
		this.destroyValue = null;
		this.scope = null;
		this.target = null;
		this._sourceValues = null;
		this._targetValue = null;
		this._super();
	},
	
<span id='JW-Mapper-method-bind'>	/**
</span>	 * Watches specified event and triggers target value recalculation on
	 * the event triggering.
	 * @param {JW.Event} event Event.
	 * @returns {JW.Functor} this
	 */
	bind: function(event) {
		this.own(event.bind(this.update, this));
		return this;
	},
	
<span id='JW-Mapper-method-watch'>	/**
</span>	 * Watches specified property and triggers target value recalculation on
	 * the property change.
	 * @param {JW.Property} property Property.
	 * @returns {JW.Functor} this
	 */
	watch: function(property) {
		this.bind(property.changeEvent);
		return this;
	},
	
<span id='JW-Mapper-method-update'>	/**
</span>	 * Updates target property focibly.
	 */
	update: function() {
		var values = JW.Array.map(this.sources, JW.byMethod(&quot;get&quot;));
		var newValue;
		if (this.acceptNull || JW.Array.every(values, JW.isSet)) {
			newValue = this.createValue.apply(this.scope, values);
		} else {
			newValue = null;
			values = null;
		}
		this.target.set(newValue);
		this._done();
		this._targetValue = newValue;
		this._sourceValues = values;
	},
	
	_done: function() {
		if (this.destroyValue &amp;&amp; this._sourceValues) {
			this.destroyValue.apply(this.scope, [this._targetValue].concat(this._sourceValues));
		}
	}
});
</pre>
</body>
</html>
