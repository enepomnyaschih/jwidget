Ext.data.JsonP.ensample2({"guide":"<h1 id='ensample2-section-part-2.-arrays-of-child-components'>Part 2. Arrays of child components</h1>\n\n<p>Demo: <a href=\"http://enepomnyaschih.github.io/mt/2/\">http://enepomnyaschih.github.io/mt/2/</a></p>\n\n<p>Source: <a href=\"https://github.com/enepomnyaschih/mt/tree/mt-2\">https://github.com/enepomnyaschih/mt/tree/mt-2</a> (Git branch)</p>\n\n<p>In this part, we'll meet <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, will try its algorithms\n<a href=\"#!/api/JW.AbstractArray-method-map\" rel=\"JW.AbstractArray-method-map\" class=\"docClass\">map</a> and <a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>\nand will learn how to add child UI component arrays.</p>\n\n<p>Our goal is to render an array of tweets, which we've developed in previous part.</p>\n\n<p><p><img src=\"guides/ensample2/tweet-feed.png\" alt=\"\" width=\"522\" height=\"247\"></p></p>\n\n<p>Like in the first sample, let's start with model. We must put several tweets into array. Let's define class mt.Data\nfor this. It will contain an array of tweets.</p>\n\n<p><strong>public/mt/data/data.js</strong></p>\n\n<pre><code>mt.Data = function() {\n    mt.Data.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.tweets = new <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>();\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.Data, <a href=\"#!/api/JW.Class\" rel=\"JW.Class\" class=\"docClass\">JW.Class</a>, {\n    /*\n    <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>&lt;mt.data.Tweet&gt; tweets;\n    */\n\n    // override\n    <a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>: function() {\n        this.tweets.<a href=\"#!/api/JW.AbstractArray-method-destroy\" rel=\"JW.AbstractArray-method-destroy\" class=\"docClass\">destroy</a>();\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n    }\n});\n\nmt.Data.createByJson = function(json) {\n    var data = new mt.Data();\n    data.tweets.<a href=\"#!/api/JW.AbstractArray-method-addAll\" rel=\"JW.AbstractArray-method-addAll\" class=\"docClass\">addAll</a>(<a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a>(json, mt.data.Tweet.createByJson));\n    return data;\n};\n\nmt.data = {};\n</code></pre>\n\n<p>You can see that we've defined <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, but instantiated it as <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>. It is done for flexibility.\nProbably in future we'll replace the implementation of array with <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>.</p>\n\n<p>Deserialization is performed via static method <a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a>.\nMethod takes native Array as first argument and callback function as second argument.\nCallback function mt.data.Tweet.createByJson converts Object (JSON) into mt.data.Tweet instance,\nand we've implemented it in previous part:</p>\n\n<pre><code>mt.data.Tweet.createByJson = function(json) {\n    return new mt.data.Tweet(<a href=\"#!/api/JW-static-method-apply\" rel=\"JW-static-method-apply\" class=\"docClass\">JW.apply</a>({}, json, {\n        time: new Date().getTime() - json.timeAgo\n    }));\n};\n</code></pre>\n\n<p>As result of <a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a> method call we've got a native JS Array of mt.data.Tweet\ninstances. We pass it into <a href=\"#!/api/JW.AbstractArray-method-addAll\" rel=\"JW.AbstractArray-method-addAll\" class=\"docClass\">addAll</a> method of data.tweets array in order to fill it in:</p>\n\n<pre><code>    data.tweets.<a href=\"#!/api/JW.AbstractArray-method-addAll\" rel=\"JW.AbstractArray-method-addAll\" class=\"docClass\">addAll</a>(<a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a>(json, mt.data.Tweet.createByJson));\n</code></pre>\n\n<p>Since we construct this.tweets object in constructor of mt.Data, we <strong>must</strong> destroy it in destructor.\nThis is a part of jWidget philosophy. Object creator must destroy it. So, if we'll destroy mt.Data instance by\n<a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a> method, all included objects will be destroyed as well.</p>\n\n<pre><code>    // override\n    <a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>: function() {\n        this.tweets.<a href=\"#!/api/JW.AbstractArray-method-destroy\" rel=\"JW.AbstractArray-method-destroy\" class=\"docClass\">destroy</a>();\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n    }\n</code></pre>\n\n<p>Let's continue with view. Define class mt.TweetFeed for tweet feed view.</p>\n\n<p><strong>public/mt/tweetfeed/tweetfeed.js</strong></p>\n\n<pre><code>mt.TweetFeed = function(data) {\n    mt.TweetFeed.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.data = data;\n    this.tweetViews = null;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.TweetFeed, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    /*\n    mt.Data data;\n    <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>&lt;mt.TweetView&gt; tweetViews;\n    */\n\n    renderTweets: function() {\n        this.tweetViews = this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>(function(tweetData) {\n            return new mt.TweetView(tweetData);\n        }, this);\n        return this.tweetViews;\n    },\n\n    // override\n    <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a>: function() {\n        this.tweetViews.<a href=\"#!/api/JW.AbstractArray-method-each\" rel=\"JW.AbstractArray-method-each\" class=\"docClass\">each</a>(<a href=\"#!/api/JW-static-method-destroy\" rel=\"JW-static-method-destroy\" class=\"docClass\">JW.destroy</a>);\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(mt.TweetFeed, {\n    main:\n        '&lt;div jwclass=\"mt-tweet-feed\"&gt;' +\n            '&lt;div jwid=\"header\"&gt;Tweets&lt;/div&gt;' +\n            '&lt;div jwid=\"tweets\"&gt;&lt;/div&gt;' +\n            '&lt;div jwid=\"footer\"&gt;...&lt;/div&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p>Let's review renderTweets method in details. Similarly to mt.TweetView component, we've defined method\n<code>render&lt;ChildId&gt;</code> for element with jwid=\"tweets\". But now this method not just fills the element with data,\nbut renders an array of child components into it.</p>\n\n<p>This array is created from data via collection item convertion method\n<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>. We already used\n<a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a> before. Let's review their difference:</p>\n\n<ul>\n<li>First, one method is instance method, second one is static method. <strong>All collection of jWidget have common\nset of static methods for native JavaScript collections (Array, Object) and instance methods for jWidget\ncollections (<a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, <a href=\"#!/api/JW.AbstractMap\" rel=\"JW.AbstractMap\" class=\"docClass\">JW.AbstractMap</a>, <a href=\"#!/api/JW.AbstractSet\" rel=\"JW.AbstractSet\" class=\"docClass\">JW.AbstractSet</a>). Static methods are defined in\n<a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>, <a href=\"#!/api/JW.Map\" rel=\"JW.Map\" class=\"docClass\">JW.Map</a>, <a href=\"#!/api/JW.Set\" rel=\"JW.Set\" class=\"docClass\">JW.Set</a> and take native collection as first argument.</strong></li>\n<li>Second, <a href=\"#!/api/JW.Array-static-method-map\" rel=\"JW.Array-static-method-map\" class=\"docClass\">JW.Array.map</a> method returns a native JavaScript Array, when\n<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a> method returns <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>. <strong>All methods which names start from $ symbol\nreturn jWidget collections. All other methods return native JavaScript collections or other values.</strong></li>\n</ul>\n\n\n<p>Both rules are introduced for convenience. Each algorithm has multiple implementations, which are constrained by\nfixed naming convention. Use one implementation which is more convenient in this particular situation.</p>\n\n<p>In our sample, <a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a> method takes callback function as first argument,\nand this function converts mt.data.Tweet instance into mt.TweetView instance:</p>\n\n<pre><code>        this.tweetViews = this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>(function(tweetData) {\n            return new mt.TweetView(tweetData);\n        }, this);\n</code></pre>\n\n<p>In second argument, method takes callback function call context (this). The rule is simple:\n<strong>whenever you pass a function as function argument, you can optionally pass its call context as next argument.</strong></p>\n\n<p>As result we'll get <a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a> instance, which contains mt.TweetView instances. We return this array as\nrenderTweets method result:</p>\n\n<pre><code>        return this.tweetViews;\n</code></pre>\n\n<p>As result, we ask the framework to render this.tweetViews components into element with jwid=\"tweets\".</p>\n\n<p>Next, let's create CSS file.</p>\n\n<p><strong>public/mt/tweetfeed/tweetfeed.css</strong></p>\n\n<pre><code>.mt-tweet-feed-header {\n  color: #333;\n  font-family: Arial, sans-serif;\n  font-size: 14px;\n  font-weight: bold;\n  text-shadow: 0 1px 0 #fff;\n}\n.mt-tweet-feed {\n  border: 1px solid rgba(0,0,0,0.45);\n  -webkit-border-radius: 6px;\n  -moz-border-radius: 6px;\n  border-radius: 6px;\n}\n.mt-tweet-feed {\n  background: #fff;\n  width: 522px;\n}\n.mt-tweet-feed-header {\n  font-size: 18px;\n  padding: 10px;\n}\n.mt-tweet-feed-footer {\n  border-top: 1px solid #e8e8e8;\n  padding: 8px;\n  text-align: center;\n}\n</code></pre>\n\n<p>Add new files into index.html:</p>\n\n<pre><code>&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mt/tweetfeed/tweetfeed.css\" /&gt;\n&lt;script type=\"text/javascript\" charset=\"utf-8\" src=\"mt/tweetfeed/tweetfeed.js\"&gt;&lt;/script&gt;\n</code></pre>\n\n<p>And prepare new test data.</p>\n\n<p><strong>public/boot.js</strong></p>\n\n<pre><code>var data;\nvar tweetFeed;\n\n$(function() {\n    data = mt.Data.createByJson([\n        {\n            \"fullName\": \"Road Runner\",\n            \"shortName\": \"roadrunner\",\n            \"avatarUrl48\": \"backend/avatar-48.png\",\n            \"contentHtml\": \"jWidget documentation is here &lt;a href=\\\"https://enepomnyaschih.github.com/jwidget\\\" target=\\\"_blank\\\"&gt;enepomnyaschih.github.com/jwidget&lt;/a&gt;\",\n            \"timeAgo\": 215000,\n            \"like\": false,\n            \"retweet\": true\n        }, {\n            \"fullName\": \"Road Runner\",\n            \"shortName\": \"roadrunner\",\n            \"avatarUrl48\": \"backend/avatar-48.png\",\n            \"contentHtml\": \"Tweet feed is growing\",\n            \"timeAgo\": 515000,\n            \"like\": false,\n            \"retweet\": false\n        }\n    ]);\n    tweetFeed = new mt.TweetFeed(data);\n    tweetFeed.<a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>(\"#container\");\n});\n</code></pre>\n\n<p>If we'll execute the application in browser, we'll see what was required.</p>\n\n<p>Let's review one more way of child components adding, without <code>render&lt;ChildId&gt;</code> method definition.\nlet's remove renderTweets method and override <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a> method instead:</p>\n\n<pre><code>    // override\n    <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>: function() {\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n        this.tweetViews = this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>(function(tweetData) {\n            return new mt.TweetView(tweetData);\n        }, this);\n        this.<a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>(this.tweetViews, \"tweets\");\n    },\n</code></pre>\n\n<p>This code is equivalent to previous one, but child component list is added dynamically by\n<a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a> method. This method takes element \"jwid\" as second argument, which should be\nused as container for child components, passed in first argument. If we won't pass second argument, the array will be\nrendered into root element. Use the way you like more. I'll stick to first way, using <code>render&lt;ChildId&gt;</code> method.</p>\n\n<p>Disadvantage of this entire sample is that tweet array is fixed. We are unable to add or remove specific tweets\ndynamically. We'll learn it in future.</p>\n","title":"Part 2. Arrays of child components"});