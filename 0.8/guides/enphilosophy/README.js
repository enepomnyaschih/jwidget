Ext.data.JsonP.enphilosophy({"guide":"<h1 id='enphilosophy-section-jwidget-philosophy'>jWidget philosophy</h1>\n\n<p>jWidget framework differs from other well-known UI-frameworks (regardless of programming language) by its philosophy.\nHere are common rules for all Model-View frameworks:</p>\n\n<ol>\n<li>All main application classes are classified to model and view.</li>\n<li>Model classes store the data. All data is stored in model. All model classes should be inherited from <a href=\"#!/api/JW.Class\" rel=\"JW.Class\" class=\"docClass\">JW.Class</a>.</li>\n<li>View classes (components) render data to the screen. All components should be inherited from <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>.</li>\n<li>Component has a direct reference to corresponding model. On user action, component calls corresponding\nmethod of model in order to modify it.</li>\n<li>Model doesn't have direct references to any views, but it triggers events about its modification.</li>\n<li>View listens model events to make neccessary updates on the screen in time.</li>\n</ol>\n\n\n<p>But the difference of jWidget compared to other frameworks is the approach to collection manupulations.\nIt is very similar to database theory generals, but at the UI level. Collection manipulation rules in jWidget\nare listed below:</p>\n\n<ol>\n<li>Data and components are structured based on three collection types: <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, <a href=\"#!/api/JW.AbstractMap\" rel=\"JW.AbstractMap\" class=\"docClass\">JW.AbstractMap</a> and\n<a href=\"#!/api/JW.AbstractSet\" rel=\"JW.AbstractSet\" class=\"docClass\">JW.AbstractSet</a>. All collections have common interfaces: <a href=\"#!/api/JW.AbstractCollection\" rel=\"JW.AbstractCollection\" class=\"docClass\">JW.AbstractCollection</a>, <a href=\"#!/api/JW.IndexedCollection\" rel=\"JW.IndexedCollection\" class=\"docClass\">JW.IndexedCollection</a>.\nRead common theory of algorithms and data structures to understand each collection type area of usage, pros and cons.</li>\n<li>Each collection has two implementations: simple (<a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>, <a href=\"#!/api/JW.Map\" rel=\"JW.Map\" class=\"docClass\">JW.Map</a>, <a href=\"#!/api/JW.Set\" rel=\"JW.Set\" class=\"docClass\">JW.Set</a>) and observable\n(<a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, <a href=\"#!/api/JW.ObservableMap\" rel=\"JW.ObservableMap\" class=\"docClass\">JW.ObservableMap</a>, <a href=\"#!/api/JW.ObservableSet\" rel=\"JW.ObservableSet\" class=\"docClass\">JW.ObservableSet</a>). Observable collections trigger events about their\nmodification.</li>\n<li>You don't need to listen all collection events manually. Instead, we recommend you to use standard jWidget\nsynchronizers. Synchronizers provide a simple way to connect collections to each other:\n\n<ul>\n<li>Item mapper: <a href=\"#!/api/JW.AbstractCollection.Mapper\" rel=\"JW.AbstractCollection.Mapper\" class=\"docClass\">JW.AbstractCollection.Mapper</a></li>\n<li>Filterer: <a href=\"#!/api/JW.AbstractCollection.Filterer\" rel=\"JW.AbstractCollection.Filterer\" class=\"docClass\">JW.AbstractCollection.Filterer</a></li>\n<li>Converter to set: <a href=\"#!/api/JW.AbstractCollection.Lister\" rel=\"JW.AbstractCollection.Lister\" class=\"docClass\">JW.AbstractCollection.Lister</a></li>\n<li>Converter to map (indexer): <a href=\"#!/api/JW.AbstractCollection.Indexer\" rel=\"JW.AbstractCollection.Indexer\" class=\"docClass\">JW.AbstractCollection.Indexer</a></li>\n<li>Converter to array (orderer): <a href=\"#!/api/JW.AbstractCollection.Orderer\" rel=\"JW.AbstractCollection.Orderer\" class=\"docClass\">JW.AbstractCollection.Orderer</a></li>\n<li>Converter to array (sorter by comparer): <a href=\"#!/api/JW.AbstractCollection.SorterComparing\" rel=\"JW.AbstractCollection.SorterComparing\" class=\"docClass\">JW.AbstractCollection.SorterComparing</a></li>\n<li>Observer: <a href=\"#!/api/JW.AbstractCollection.Observer\" rel=\"JW.AbstractCollection.Observer\" class=\"docClass\">JW.AbstractCollection.Observer</a></li>\n<li>View synchronizers: <a href=\"#!/api/JW.AbstractArray.Inserter\" rel=\"JW.AbstractArray.Inserter\" class=\"docClass\">JW.AbstractArray.Inserter</a>, <a href=\"#!/api/JW.AbstractMap.Inserter\" rel=\"JW.AbstractMap.Inserter\" class=\"docClass\">JW.AbstractMap.Inserter</a></li>\n<li>Arrays merger: <a href=\"#!/api/JW.AbstractArray.Merger\" rel=\"JW.AbstractArray.Merger\" class=\"docClass\">JW.AbstractArray.Merger</a></li>\n<li>Array reverser: <a href=\"#!/api/JW.AbstractArray.Reverser\" rel=\"JW.AbstractArray.Reverser\" class=\"docClass\">JW.AbstractArray.Reverser</a></li>\n</ul>\n</li>\n<li>Collections are closed inside synchronizer methods. In other words, any modification of one collection triggers\nat most one modification of another collection, which is connected to the first one using standard synchronizer.</li>\n<li>Almost any user action can be handled by a single manual collection modification in model. All other collections\n(including component collections in the view) must be synchronized automatically via synchronizers.</li>\n<li>For proper and fast application running, it is enough to configure all synchronizers only once, similarly to\nindexes and foreign keys configuration in data bases.</li>\n<li>There should be no difference between simple and observable collection manipulations. Although it is enough to\ncall some algorithm to convert one simple collection to another\n(<a href=\"#!/api/JW.AbstractCollection-method-index\" rel=\"JW.AbstractCollection-method-index\" class=\"docClass\">index</a>,\n<a href=\"#!/api/JW.AbstractCollection-method-toSortedComparing\" rel=\"JW.AbstractCollection-method-toSortedComparing\" class=\"docClass\">toSortedComparing</a>,\n<a href=\"#!/api/JW.AbstractCollection-method-toSet\" rel=\"JW.AbstractCollection-method-toSet\" class=\"docClass\">toSet</a> etc.), it is recommended to instantiate a synchronizer instead\n(<a href=\"#!/api/JW.AbstractCollection-method-createIndexer\" rel=\"JW.AbstractCollection-method-createIndexer\" class=\"docClass\">createIndexer</a>,\n<a href=\"#!/api/JW.AbstractCollection-method-createSorterComparing\" rel=\"JW.AbstractCollection-method-createSorterComparing\" class=\"docClass\">createSorterComparing</a>,\n<a href=\"#!/api/JW.AbstractCollection-method-createLister\" rel=\"JW.AbstractCollection-method-createLister\" class=\"docClass\">createLister</a> correspondingly). Code quality, performance and size\nwon't be damaged too much. But the bonus is you'll be able to replace simple implementation with\nobservable one by a simple base class change. But in some complicated cases sycnhronizers configuration can be way too\nexpensive: keep the balance.</li>\n<li>Objects and DOM-elements should be never recreated: only updated.</li>\n<li>The one who has created an object must destroy it. The only exception is <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">JW.UI.Component.children</a>, which contents\nare destroyed automatically for convenience.</li>\n</ol>\n\n","title":"jWidget philosophy"});