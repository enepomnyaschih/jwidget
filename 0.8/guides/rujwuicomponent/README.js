Ext.data.JsonP.rujwuicomponent({"guide":"<h1 id='rujwuicomponent-section-jw.ui.component'>JW.UI.Component</h1>\n\n<p>Это краткое описание класса на русском языке.</p>\n\n<p>Полная документация на английском: <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a></p>\n\n<p>Базовый класс UI компонента.</p>\n\n<p>Возможности:</p>\n\n<ul>\n<li>Рендеринг по HTML шаблону</li>\n<li>Прямой доступ к элементам компонента</li>\n<li><a href=\"http://api.jquery.com/\">jQuery-интерфейс</a> для работы с элементами</li>\n<li>Удобный API для работы с дочерними компонентами</li>\n</ul>\n\n\n<p>У jWidget очень простой интерфейс, но весьма необычная философия, которая гарантирует соответствие архитектуре\nModel-View без больших усилий. Начнем с примеров.</p>\n\n<h3 id='rujwuicomponent-section-%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80-ui-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0-jwidget'>Пример UI компонента jWidget</h3>\n\n<pre><code>// Объявляем пространство имен\nvar MyApp = {};\n\n// Объявляем конструктор компонента\nMyApp.Component = function(message, link) {\n    MyApp.Component.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.message = message;\n    this.link = link;\n};\n\n// Наследуемся от <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyApp.Component, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // String message;\n    // String link;\n\n    // override\n    <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>: function() {\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"hello-message\").text(message);\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"link\").attr(\"href\", this.link);\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyApp.Component, {\n    main:\n        '&lt;div jwclass=\"myapp-component\"&gt;' +\n            '&lt;div jwid=\"hello-message\" /&gt;' +\n            '&lt;a href=\"#\" jwid=\"link\"&gt;Click me!&lt;/a&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p>Рассмотрим, как это работает. У каждого компонента есть главный шаблон, который передается в функцию\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a> с именем <code>main</code> и по умолчанию равен\n<code>&lt;div /&gt;</code>. Вы можете добавить и другие шаблоны, они будут доступны в поле компонента\n<code><a href=\"#!/api/JW.UI.Component-property-templates\" rel=\"JW.UI.Component-property-templates\" class=\"docClass\">this.templates</a>.&lt;template_name&gt;</code> (но они используются очень редко).\nПодкласс наследует шаблоны базового класса.</p>\n\n<p>Обратите внимание на специальные атрибуты <code>jwclass</code> и <code>jwid</code>. <code>jwclass</code> - это корневой CSS-класс компонента,\n<code>jwid</code> - это суффикс к <code>jwclass</code> в данном элементе. Так, в результате рендеринга этого компонента мы получим\nследующий фрагмент HTML:</p>\n\n<pre><code>&lt;div class=\"myapp-component\"&gt;\n    &lt;div class=\"myapp-component-hello-message\" /&gt;\n    &lt;a href=\"#\" class=\"myapp-component-link\"&gt;Click me!&lt;/a&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Вы можете получить элемент по его <code>jwid</code>, используя метод <a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>. В результате вызова этого метода вы получите\n<a href=\"http://api.jquery.com/\">jQuery-обертку</a> над этим элементом. Кроме того, у компонента есть поле <a href=\"#!/api/JW.UI.Component-property-el\" rel=\"JW.UI.Component-property-el\" class=\"docClass\">el</a>, которое\nссылается на корневой jQuery-элемент компонента.</p>\n\n<h3 id='rujwuicomponent-section-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0-%D0%B2-%D0%BA%D0%BE%D0%B4%D0%B5'>Создание компонента в коде</h3>\n\n<p>Компонент может быть создан простым конструированием. После этого, вы можете использовать метод <a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>\nили <a href=\"#!/api/JW.UI.Component-method-renderAs\" rel=\"JW.UI.Component-method-renderAs\" class=\"docClass\">renderAs</a>, чтобы вставить этот компонент в DOM.</p>\n\n<pre><code>var component;\n\njQuery(function() {\n    component = new MyApp.Component(\"Hello world!\", \"http://google.com\");\n    component.<a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>(\"body\");\n});\n</code></pre>\n\n<h3 id='rujwuicomponent-section-%D0%94%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B'>Дочерние компоненты</h3>\n\n<p>Есть 3 способа добавить дочерний компонент:</p>\n\n<ul>\n<li>Добавить компонент в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> с ключом, равным <code>jwid</code> элемента, который вы хотите заменить дочерним\nкомпонентом. Обычно, это делается в методе <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>.</li>\n<li>Добавить массив дочерних компонентов в один из элементов с помощью метода <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>. Если переданный массив\nявляется <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, то фреймворк обеспечит непрерывную синхронизацию с этим массивом во время\nработы приложения.</li>\n<li>Определить метод <code>render&lt;ChildId&gt;</code>, где <code>&lt;ChildId&gt;</code> - это <code>jwid</code> элемента,\nзаписанный в CamelCase с заглавной буквы. Пример: <code>renderArticle</code> (рендерит элемент <code>jwid=\"article\"</code>).\nЕсли метод возвращает <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a> или <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, то результат будет трактоваться как дочерний компонент\nили массив дочерних компонентов соответственно. Смотрите параграф\n<strong>Подробнее о методе render&lt;ChildId&gt;</strong> для деталей.</li>\n</ul>\n\n\n<p>Такой интерфейс с одной стороны прост, с другой стороны гибок в плане следования архитектуре Model-View.</p>\n\n<p><a href=\"#!/guide/rusample1\">Учебник. Часть 1. Модель и представление</a></p>\n\n<h3 id='rujwuicomponent-section-%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5-%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D1%85-%D0%B4%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D1%85-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2'>Подробнее о массивах дочерних компонентов</h3>\n\n<p>Для создания массивов UI компонентов на основе массивов данных удобно использовать <a href=\"#!/api/JW.AbstractCollection.Mapper\" rel=\"JW.AbstractCollection.Mapper\" class=\"docClass\">JW.AbstractCollection.Mapper</a>.\nБлагодаря ему, представление будет автоматически обновляться при изменении данных.</p>\n\n<p>По этой же причине рекомендуем использовать <a href=\"#!/api/JW.AbstractCollection\" rel=\"JW.AbstractCollection\" class=\"docClass\">JW.AbstractCollection</a> в реализации классов модели вместо нативных\nJavaScript Array и Object: у наших коллекций есть Observable-реализации и они могут синхронизироваться друг с другом.</p>\n\n<p><a href=\"#!/guide/rusample6\">Учебник. Часть 6. Синхронизаторы коллекций</a></p>\n\n<h3 id='rujwuicomponent-section-%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5-%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B5-render%26lt%3Bchildid%26gt%3B'>Подробнее о методе render&lt;ChildId&gt;</h3>\n\n<p>Вы можете определить метод <code>render&lt;ChildId&gt;</code> для всех элементов HTML шаблона, у которых есть атрибут <code>jwid</code>.\n<code>&lt;ChildId&gt;</code> равен этому <code>jwid</code>, записанному в CamelCase с большой буквы. Сигнатура метода:</p>\n\n<p><code>renderChildId(el: <a href=\"http://api.jquery.com/\">jQuery</a>): Mixed</code></p>\n\n<p><code>el</code> - элемент с соответствующим <code>jwid</code>.</p>\n\n<p>В зависимости от того, какой результат возвращает этот метод, есть следующие варианты:</p>\n\n<ul>\n<li>Если метод возвращает <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, то он будет добавлен в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> и станет дочерним компонентом.</li>\n<li>Если метод возвращает <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>, то он будет добавлен как массив дочерних компонентов методом <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>.</li>\n<li>Если метод возвращает <code>false</code> (===), то элемент будет удален из HTML компонента.</li>\n<li>В противном случае, фреймворк не выполнит никаких дополнительных действий по инициализации элемента.</li>\n</ul>\n\n\n<h3 id='rujwuicomponent-section-%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2'>Удаление и уничтожение компонентов</h3>\n\n<p>Вы можете уничтожить компонент методом <a href=\"#!/api/JW.UI.Component-method-destroy\" rel=\"JW.UI.Component-method-destroy\" class=\"docClass\">destroy</a>. Но вы не сможете уничтожить компонент, который добавлен в другой\nкомпонент в качестве дочернего (если попробуете, фреймворк выбросит исключение). Сначала вы должны удалить\nдочерний компонент из родителя. Чтобы это сделать, нужно выполнить операцию, обратную операции добавления.\nТак, чтобы удалить компонент с <code>jwid=\"comments\"</code> вы должны вызвать метод <a href=\"#!/api/JW.AbstractMap-method-remove\" rel=\"JW.AbstractMap-method-remove\" class=\"docClass\">remove</a>\nобъекта <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>. Сразу же после этого вы можете уничтожить его:</p>\n\n<pre><code>this.<a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>.<a href=\"#!/api/JW.AbstractMap-method-remove\" rel=\"JW.AbstractMap-method-remove\" class=\"docClass\">remove</a>(\"comments\").<a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>();\n</code></pre>\n\n<p>В таком случае, элемент HTML шаблона с таким <code>jwid</code> вернется в свое изначальное состояние.</p>\n\n<p>Вы можете свободно уничтожать дочерние компоненты в методе <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a> родительского компонента.\nВ этом методе, дочерние компоненты уже удалены из родителя фреймворком и готовы к уничтожению.</p>\n\n<p>Кроме того, вы можете использовать метод агрегации <a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a> для уничтожения дочерних компонентов.</p>\n\n<p>С массивами дочерних компонентов все немного сложнее. Первый способ удалить дочерний компонент, который добавлен в\nродителя через массив - это удалить этот компонент из массива (если это <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>). Второй способ:\nметод <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a> возвращает экземпляр <a href=\"#!/api/JW.UI.Component.Array\" rel=\"JW.UI.Component.Array\" class=\"docClass\">JW.UI.Component.Array</a>. Если вы его уничтожите, то массив будет\nудален из родительского компонента:</p>\n\n<pre><code>    // override\n    <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>: function() {\n        this._labelMapper = this.labels.<a href=\"#!/api/JW.AbstractArray-method-createMapper\" rel=\"JW.AbstractArray-method-createMapper\" class=\"docClass\">createMapper</a>({\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-createItem\" rel=\"JW.AbstractCollection.Mapper-cfg-createItem\" class=\"docClass\">createItem</a>: function(label) { return new LabelView(label); },\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-destroyItem\" rel=\"JW.AbstractCollection.Mapper-cfg-destroyItem\" class=\"docClass\">destroyItem</a>: <a href=\"#!/api/JW-static-method-destroy\" rel=\"JW-static-method-destroy\" class=\"docClass\">JW.destroy</a>,\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-scope\" rel=\"JW.AbstractCollection.Mapper-cfg-scope\" class=\"docClass\">scope</a>: this\n        });\n        // Добавляем метки в элемент с jwid=\"labels\"\n        this._labelArray = this.<a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>(this._labelMapper.<a href=\"#!/api/JW.AbstractCollection.Mapper-property-target\" rel=\"JW.AbstractCollection.Mapper-property-target\" class=\"docClass\">target</a>, \"labels\");\n    },\n\n    clearLabels: function() {\n        this._labelArray.<a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>();\n    }\n</code></pre>\n\n<p><strong>Замечение:</strong> Все массивы уже уничтожены перед вызовом метода <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a>, т.е. такие дочерние компоненты\nуже удалены из родителя. Но сами компоненты еще не уничтожены. Обычно это делается путем уничтожения соответствующего\nсинхронизатора:</p>\n\n<pre><code>    <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a>: function() {\n        this._labelMapper.<a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>(); // уничтожаем представления всех меток\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n    }\n</code></pre>\n\n<p>Правила, описанные в этом параграфе, могут показаться вам слишком сложными, но их первопричины станут яснее\nв следующем параграфе.</p>\n\n<h3 id='rujwuicomponent-section-%D0%9E%D0%B1%D1%89%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-%D0%B4%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D0%BC%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8'>Общие практики работы с дочерними компонентами</h3>\n\n<p><strong>Внутренние именованные дочерние компоненты</strong></p>\n\n<p>Этот пример описывает, как создается и уничтожается дочерний компонент с <code>jwid=\"title-box\"</code>.</p>\n\n<pre><code>var MyComponent = function() {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    renderTitleBox: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(new TitleBox());\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"title-box\" /&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p><strong>Внешние именованные дочерние компоненты</strong></p>\n\n<p>Этот пример описывает, как добавить дочерний компонент, который был сконструирован кем-то другим, и, следовательно,\nне должен быть уничтожен здесь автоматически.</p>\n\n<pre><code>var MyComponent = function(titleBox) {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.titleBox = titleBox;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a> titleBox;\n\n    renderTitleBox: function() {\n        return this.titleBox;\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"title-box\" /&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p><strong>Внутренние неизменяемые массивы дочерних компонентов</strong></p>\n\n<p>Этот пример описывает, как дочерние компоненты создаются и уничтожаются на основе массива данных, и\nкак они добавляются внутрь элемента с <code>jwid=\"labels\"</code>.</p>\n\n<pre><code>var MyComponent = function(labels) {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.labels = labels;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>&lt;Label&gt; labels;\n\n    renderLabels: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.labels.<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>(function(label) {\n            return new LabelView(label);\n        }, this)).<a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">ownItems</a>();\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"labels\" /&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p><strong>Внутренний изменяемый массив дочерних компонентов</strong></p>\n\n<p>Этот пример описывает, как дочерние компоненты создаются и уничтожаются на основе массива данных, и\nкак они добавляются внутрь элемента с <code>jwid=\"labels\"</code>. Массив дочерних компонентов будет автоматически\nсинхронизироваться с данными налету.</p>\n\n<pre><code>var MyComponent = function(labels) {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.labels = labels;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>&lt;Label&gt; labels;\n\n    renderLabels: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.labels.<a href=\"#!/api/JW.AbstractArray-method-createMapper\" rel=\"JW.AbstractArray-method-createMapper\" class=\"docClass\">createMapper</a>({\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-createItem\" rel=\"JW.AbstractCollection.Mapper-cfg-createItem\" class=\"docClass\">createItem</a>: function(label) { return new LabelView(label); },\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-destroyItem\" rel=\"JW.AbstractCollection.Mapper-cfg-destroyItem\" class=\"docClass\">destroyItem</a>: <a href=\"#!/api/JW-static-method-destroy\" rel=\"JW-static-method-destroy\" class=\"docClass\">JW.destroy</a>,\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-scope\" rel=\"JW.AbstractCollection.Mapper-cfg-scope\" class=\"docClass\">scope</a>: this\n        })).<a href=\"#!/api/JW.AbstractCollection.Mapper-property-target\" rel=\"JW.AbstractCollection.Mapper-property-target\" class=\"docClass\">target</a>;\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"labels\" /&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p><strong>Внешний массив дочерних компонентов</strong></p>\n\n<p>Этот пример описывает, как массив дочерних компонентов добавить внутрь элемента с <code>jwid=\"labels\"</code>.\nМассив дочерних компонентов будет автоматически синхронизироваться с данными налету.\nКомпоненты создаются кем-то другим, и, следовательно, не должны быть уничтожены здесь автоматически.</p>\n\n<pre><code>var MyComponent = function(labelViews) {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.labelViews = labelViews;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>&lt;LabelView&gt; labelViews;\n\n    renderLabels: function() {\n        return this.labelViews;\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"labels\" /&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<h3 id='rujwuicomponent-section-%D0%AD%D1%82%D0%B0%D0%BF%D1%8B-%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0'>Этапы жизни компонента</h3>\n\n<p>Каждый компонент проходит несколько этапов жизненного цикла.</p>\n\n<ol>\n<li>Как и у всех остальных классов, сначала вызывается <strong>конструктор</strong>. Обычно здесь объявляются все поля и присваиваются\nих изначальные значения, создаются события и т.д. Здесь затрагивается только модель компонента, представление\nполностью игнорируется. Обратите внимание, что компонент после конструирования еще не отрендерен, так что у него\nеще нет полей <a href=\"#!/api/JW.UI.Component-property-el\" rel=\"JW.UI.Component-property-el\" class=\"docClass\">el</a> и <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>, а\nметод <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a> не будет работать. Смысл этого в том, чтобы дать вам возможность\nсделать что-то еще между конструированием и рендерингом компонента, например, изменить значения каких-то полей и\nвызвать какие-то методы. Вторая причина: вообще, во всех объектно-ориентированных языках программирования не\nрекомендуется вызывать виртуальные методы внутри конструктора. Вы можете отрендерить компонент напрямую вызовом\nметода <a href=\"#!/api/JW.UI.Component-method-render\" rel=\"JW.UI.Component-method-render\" class=\"docClass\">render</a>, <a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>,\n<a href=\"#!/api/JW.UI.Component-method-renderAs\" rel=\"JW.UI.Component-method-renderAs\" class=\"docClass\">renderAs</a>, или неявно путем добавления этого компонента в другой компонент в качестве\nдочернего. Например, компонент будет сразу же отрендерен, если его добавить в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>. Вы можете\nинициировать рендеринг компонента несколько раз, но отрендерен он будет лишь при первой попытке.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-beforeRender\" rel=\"JW.UI.Component-method-beforeRender\" class=\"docClass\">beforeRender</a> вызывается во время рендеринга компонента, после чтения HTML шаблона и инициализации всех ссылок\nна элементы шаблона. Здесь удобно выполнять какие-либо предварительные действия перед созданием дочерних компонентов.\nНо вы уже имеете право создавать здесь дочерние компоненты. Вызов <code>this._super()</code> выполняется в первой\nстроке метода.</li>\n<li>Методы <code>render&lt;ChildId&gt;</code> вызываются для всех элементов HTML шаблона, т.е. выполняется\nсоздание дочерних компонентов.</li>\n<li>Вызывается метод <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>. Здесь следует присваивать атрибуты элементов, создавать дочерние компоненты,\nподписываться на события и наполнять компонент поведением, если вы не захотели этого делать на предыдущем шаге.\nВызов <code>this._super()</code> выполняется в первой строке метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-afterAppend\" rel=\"JW.UI.Component-method-afterAppend\" class=\"docClass\">afterAppend</a> вызывается после первого появления компонента в HTML DOM и дереве UI компонентов.\nЗдесь следует выполнять лайаутинг компонента (вычислять размеры элементов). Здесь заканчивается рендеринг компонента.\nВызов <code>this._super()</code> выполняется в первой строке метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-destroyComponent\" rel=\"JW.UI.Component-method-destroyComponent\" class=\"docClass\">destroyComponent</a> вызывается при уничтожении компонента. Здесь откатывается все, что было сделано во\nвремя рендеринга компонента, т.е. на шагах 2-5. Фреймворк уже удалил все дочерние компоненты перед вызовом этого\nметода, но сами компоненты еще не уничтожены. Вы должны уничтожить их явно, если вы не заагрегировали их\nметодом <a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>.\nВызов <code>this._super()</code> выполняется в последней строке метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-destroyObject\" rel=\"JW.UI.Component-method-destroyObject\" class=\"docClass\">destroyObject</a> вызывается при уничтожении компонента. Здесь откатывается все, что было сделано в\nконструкторе компонента, т.е. на первом шаге.\nВызов <code>this._super()</code> выполняется в последней строке метода.</li>\n</ol>\n\n\n<h3 id='rujwuicomponent-section-%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%81-jwidget-sdk'>Интеграция с jWidget SDK</h3>\n\n<p>Библиотека jWidget UI идеально интегрирована с <a href=\"https://github.com/enepomnyaschih/jwsdk/wiki/ru\">jWidget SDK</a>, что\nдает вам хорошую оптимизацию JS-кода прямо из коробки, а также возможность выносить HTML шаблоны в отдельные файлы.\nНапример, вы можете упростить самый первый пример, разбив его на 2 файла:</p>\n\n<p><strong>component.js</strong></p>\n\n<pre><code>// Объявляем пространство имен\nvar MyApp = {};\n\n// Объявляем конструктор компонента\nMyApp.Component = function(message, link) {\n    MyApp.Component.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.message = message;\n    this.link = link;\n};\n\n// Наследуемся от <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyApp.Component, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // String message;\n    // String link;\n\n    // override\n    <a href=\"#!/api/JW.UI.Component-method-renderComponent\" rel=\"JW.UI.Component-method-renderComponent\" class=\"docClass\">renderComponent</a>: function() {\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"hello-message\").text(message);\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"link\").attr(\"href\", this.link);\n    }\n});\n</code></pre>\n\n<p><strong>component.jw.html</strong></p>\n\n<pre><code>&lt;div jwclass=\"myapp-component\"&gt;\n    &lt;div jwid=\"hello-message\" /&gt;\n    &lt;a href=\"#\" jwid=\"link\"&gt;Click me!&lt;/a&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Чтобы это работало, вам нужно просто зарегистрировать следующие ресурсы в соответствующем пакете jWidget SDK:</p>\n\n<pre><code>{\n    \"resources\" : [\n        \"component.js\",\n        \"component.jw.html : MyApp.Component\",\n        ...\n    ]\n}\n</code></pre>\n\n<p>Конечно, вы можете использовать jWidget и без jWidget SDK, но в таком случае вам потребуется либо загружать\nHTML шаблоны динамически, либо объявлять их явно прямо в JavaScript коде, используя функцию <a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>.</p>\n\n<p>Ищите более дополнительные примеры по использованию jWidget SDK в учебнике:</p>\n\n<p><a href=\"#!/guide/rusample7\">Учебник. Часть 7. Инфраструктура проекта</a></p>\n","title":"JW.UI.Component"});