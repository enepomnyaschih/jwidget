Ext.data.JsonP.rusample6({"guide":"<h1 id='rusample6-section-%D0%A7%D0%B0%D1%81%D1%82%D1%8C-6.-%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9'>Часть 6. Синхронизаторы коллекций</h1>\n\n<p>Демонстрация доступна по адресу\n<a href=\"http://enepomnyaschih.github.io/mt/0.8-6/\">http://enepomnyaschih.github.io/mt/0.8-6/</a></p>\n\n<p>Исходный код <a href=\"https://github.com/enepomnyaschih/mt/tree/mt-0.8-6\">https://github.com/enepomnyaschih/mt/tree/mt-0.8-6</a> (ветка)</p>\n\n<p>Этот пример является продолжением предыдущей части.</p>\n\n<p>Теперь переходим к самому интересному и самому важному, ради чего только одного стоит использовать фреймворк jWidget -\nк синхронизаторам коллекций.</p>\n\n<p>В данном примере мы добавим возможность постить новые твиты и удалять существующие.</p>\n\n<p>Для начала проведем небольшой рефакторинг. Сейчас у нас есть следующий код в классе mt.TweetFeed:</p>\n\n<p><strong>public/mt/tweetfeed/tweetfeed.js</strong></p>\n\n<pre><code>    renderTweets: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>(function(tweetData) {\n            return new mt.TweetView(tweetData);\n        }, this)).<a href=\"#!/api/JW.AbstractCollection-method-ownItems\" rel=\"JW.AbstractCollection-method-ownItems\" class=\"docClass\">ownItems</a>();\n    }\n</code></pre>\n\n<p>Напомню, что этот код конвертирует массив данных mt.data.Tweet в массив представлений mt.TweetView и\nрендерит их внутрь элемента с jwid=\"tweets\".</p>\n\n<p>Надо понимать, что такой код не позволит нам легко наладить постоянную синхронизацию массива представлений с\nмассивом данных: конвертирование данных в представления осуществляется только один раз, в момент рендеринга\nленты твитов. Можно, конечно, вручную подписаться на все события <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a> и вручную их обрабатывать\n(в других фреймворках вам так и пришлось бы поступить), но jWidget предлагает более легкое решение -\nвоспользоваться синхронизатором.</p>\n\n<p>Более того, философия jWidget гласит, что\n<strong>не должно быть разницы в подходах между простой и оповещающей коллекцией. Несмотря на то, что для\nкорректного преобразования простых коллекций друг в друга достаточно просто запустить некоторый алгоритм\n(здесь: <a href=\"#!/api/JW.AbstractArray-method-S-map\" rel=\"JW.AbstractArray-method-S-map\" class=\"docClass\">$map</a>), все равно рекомендуется вместо этого создать синхронизатор.</strong></p>\n\n<p>Итак, перейдем к делу. Заменим код mt.TweetFeed следующим.</p>\n\n<p><strong>public/mt/tweetfeed/tweetfeed.js</strong></p>\n\n<pre><code>    renderTweets: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-createMapper\" rel=\"JW.AbstractArray-method-createMapper\" class=\"docClass\">createMapper</a>({\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-createItem\" rel=\"JW.AbstractCollection.Mapper-cfg-createItem\" class=\"docClass\">createItem</a>: function(tweetData) {\n                return new mt.TweetView(tweetData);\n            },\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-destroyItem\" rel=\"JW.AbstractCollection.Mapper-cfg-destroyItem\" class=\"docClass\">destroyItem</a>: <a href=\"#!/api/JW-static-method-destroy\" rel=\"JW-static-method-destroy\" class=\"docClass\">JW.destroy</a>,\n            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-scope\" rel=\"JW.AbstractCollection.Mapper-cfg-scope\" class=\"docClass\">scope</a>: this\n        })).<a href=\"#!/api/JW.AbstractArray.Mapper-property-target\" rel=\"JW.AbstractArray.Mapper-property-target\" class=\"docClass\">target</a>;\n    }\n</code></pre>\n\n<p>Поскольку наш массив this.data.tweets пока простой (<a href=\"#!/api/JW.Array\" rel=\"JW.Array\" class=\"docClass\">JW.Array</a>), этот код эквивалентен предыдущему - запустите\nприложение в браузере, и вы не заметите разницы. Зато теперь мы получили возможность заменить реализацию массива\nв mt.Data на <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, и, не меняя кода представления, синхронизировать его с моделью:</p>\n\n<p><strong>public/mt/data/data.js</strong></p>\n\n<pre><code>mt.Data = function() {\n    mt.Data.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.profile = null;\n    this.tweets = new <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>();\n};\n</code></pre>\n\n<p>Попробуйте открыть приложение в браузере и выполнить следующую команду в консоли:</p>\n\n<pre><code>data.tweets.<a href=\"#!/api/JW.AbstractArray-method-add\" rel=\"JW.AbstractArray-method-add\" class=\"docClass\">add</a>(new mt.data.Tweet({\n    fullName: \"Road Runner\",\n    shortName: \"roadrunner\",\n    avatarUrl48: \"backend/avatar-48.png\",\n    contentHtml: \"This is a new tweet!\",\n    time: new Date().getTime(),\n    like: false,\n    retweet: false\n}));\n</code></pre>\n\n<p>Вы увидите, как в конце ленты твитов появится новый твит:</p>\n\n<p><p><img src=\"guides/rusample6/result-1.png\" alt=\"\" width=\"944\" height=\"575\"></p></p>\n\n<p>Заметьте, что своей командой мы никак не затронули\nпредставление: мы просто добавили объект в массив данных, но представление все равно корректно обновилось.</p>\n\n<p>Остается только добавить код, который будет добавлять новый объект в data.tweets по сабмиту формы\nCompose tweet. Подпишемся на событие jQuery.submit в mt.ProfileBox:</p>\n\n<p><strong>public/mt/profilebox/profilebox.js</strong></p>\n\n<pre><code>mt.ProfileBox = function(data) {\n    this._onComposeSubmit = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onComposeSubmit, this);\n    mt.ProfileBox.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.data = data;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.ProfileBox, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // ... код\n\n    renderComposeForm: function(el) {\n        el.submit(this._onComposeSubmit);\n    },\n\n    _onComposeSubmit: function(event) {\n        event.preventDefault();\n        var text = <a href=\"#!/api/JW.String-static-method-trim\" rel=\"JW.String-static-method-trim\" class=\"docClass\">JW.String.trim</a>(this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"compose-input\").val());\n        if (!text) {\n            return;\n        }\n        this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-add\" rel=\"JW.AbstractArray-method-add\" class=\"docClass\">add</a>(new mt.data.Tweet({\n            fullName: this.data.profile.fullName,\n            shortName: this.data.profile.shortName,\n            avatarUrl48: this.data.profile.avatarUrl48,\n            contentHtml: text,\n            time: new Date().getTime(),\n            like: false,\n            retweet: false\n        }), 0);\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"compose-input\").val(\"\")\n    }\n});\n</code></pre>\n\n<p>И запустим наше приложение. После ввода текста и нажатия кнопки \"Tweet\" мы увидим новый твит в начале ленты твитов:</p>\n\n<p><p><img src=\"guides/rusample6/result-2.png\" alt=\"\" width=\"942\" height=\"298\"></p></p>\n\n<p><p><img src=\"guides/rusample6/result-3.png\" alt=\"\" width=\"942\" height=\"375\"></p></p>\n\n<p>Наша следующая задача - активировать кнопки Remove у твитов, чтобы корректно удалять их из ленты. Подпишемся на клик\nпо кнопке. Для удаления твита нам понадобится доступ к объекту mt.Data:</p>\n\n<p><strong>public/mt/tweetview/tweetview.js</strong></p>\n\n<pre><code>mt.TweetView = function(data, tweetData) {\n    this._updateTime = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._updateTime, this);\n    this._onLikeClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onLikeClick, this);\n    this._onRetweetClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onRetweetClick, this);\n    this._onRemoveClick = <a href=\"#!/api/JW-static-method-inScope\" rel=\"JW-static-method-inScope\" class=\"docClass\">JW.inScope</a>(this._onRemoveClick, this);\n    mt.TweetView.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.data = data;\n    this.tweetData = tweetData;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(mt.TweetView, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    /*\n    mt.Data data;\n    mt.data.Tweet tweetData;\n    */\n\n    renderRemove: function(el) {\n        el.click(this._onRemoveClick);\n    },\n\n    // ...\n\n    _onRemoveClick: function(event) {\n        event.preventDefault();\n        this.data.tweets.<a href=\"#!/api/JW.AbstractArray-method-removeItem\" rel=\"JW.AbstractArray-method-removeItem\" class=\"docClass\">removeItem</a>(this.tweetData);\n    },\n\n    // ...\n});\n</code></pre>\n\n<p>Обновите аргументы конструирования объекта mt.TweetView в mt.TweetFeed:</p>\n\n<p><strong>public/mt/tweetfeed/tweetfeed.js</strong></p>\n\n<pre><code>            <a href=\"#!/api/JW.AbstractCollection.Mapper-cfg-createItem\" rel=\"JW.AbstractCollection.Mapper-cfg-createItem\" class=\"docClass\">createItem</a>: function(tweetData) {\n                return new mt.TweetView(this.data, tweetData);\n            },\n</code></pre>\n\n<p>Запустите приложение и попробуйте кликнуть по кнопке Remove у твита:</p>\n\n<p><p><img src=\"guides/rusample6/result-4.png\" alt=\"\" width=\"950\" height=\"266\"></p></p>\n\n<p>В данном примере мы рассмотрели типичный сценарий использования конвертера элементов <a href=\"#!/api/JW.AbstractCollection.Mapper\" rel=\"JW.AbstractCollection.Mapper\" class=\"docClass\">JW.AbstractCollection.Mapper</a>,\nно не стоит на этом останавливаться. Познакомьтесь с другими синхронизаторами самостоятельно, и, я уверен, вы\nнайдете разумное применение для большинства из них. Ищите их в описании класса <a href=\"#!/api/JW.AbstractCollection\" rel=\"JW.AbstractCollection\" class=\"docClass\">JW.AbstractCollection</a>.</p>\n\n<p>Замечу, что использование синхронизаторов не ограничивается представлением. В моей практике, синхронизаторы чаще\nвсего, наоборот, используются в модели. Так, индексатор ускорит доступ к элементу массива по ключу. А сортировщик,\nнапример, сможет отсортировать множество твитов по дате публикации, и нам больше не надо будет думать, в какое место\nленты твитов вставить очередной твит. Сценариев использования множество, рекомендую вам опробовать их на практике.</p>\n\n<p>В следующей части мы улучшим инфраструктуру нашего проекта: вынесем HTML-шаблоны в отдельные HTML-файлы с\nпомощью <a href=\"https://github.com/enepomnyaschih/jwsdk/wiki/ru\">jWidget SDK</a> и научимся использовать CSS-препроцессор\n<a href=\"http://learnboost.github.io/stylus/\">Stylus</a>, чтобы сделать верстку более удобной и приятной.</p>\n","title":"Часть 6. Синхронизаторы коллекций"});