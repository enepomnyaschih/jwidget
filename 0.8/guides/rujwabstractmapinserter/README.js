Ext.data.JsonP.rujwabstractmapinserter({"guide":"<h1 id='rujwabstractmapinserter-section-jw.abstractmap.inserter'>JW.AbstractMap.Inserter</h1>\n\n<p>Это краткое описание класса на русском языке.</p>\n\n<p>Полная документация на английском: <a href=\"#!/api/JW.AbstractMap.Inserter\" rel=\"JW.AbstractMap.Inserter\" class=\"docClass\">JW.AbstractMap.Inserter</a></p>\n\n<p><code>&lt;T&gt;</code></p>\n\n<p>Синхронизатор представления словаря. Прослушивает все события словаря и сводит их к 2 элементарным функциям:\nэлемент добавлен с указанным ключом и элемент удален с указанным ключом. В целях оптимизации, можно определить\nтретью функцию: коллекция очищена (в случае, если есть более эффективный алгоритм очистки, чем удаление всех\nэлементов простым перебором). В отличие от <a href=\"#!/api/JW.AbstractCollection.Observer\" rel=\"JW.AbstractCollection.Observer\" class=\"docClass\">JW.AbstractCollection.Observer</a>, следит за ключами элементов.\nСинхронизатор используется, прежде всего, для синхронизации DOM-элемента со словарем дочерних элементов.</p>\n\n<p>Создавайте синхронизатор с помощью метода <a href=\"#!/api/JW.AbstractMap-method-createInserter\" rel=\"JW.AbstractMap-method-createInserter\" class=\"docClass\">JW.AbstractMap.createInserter</a>:</p>\n\n<pre><code>var inserter = map.<a href=\"#!/api/JW.AbstractMap-method-createInserter\" rel=\"JW.AbstractMap-method-createInserter\" class=\"docClass\">createInserter</a>({\n    <a href=\"#!/api/JW.AbstractMap.Inserter-cfg-addItem\" rel=\"JW.AbstractMap.Inserter-cfg-addItem\" class=\"docClass\">addItem</a>: function(el, key) { this.el.find(\"[elkey=\" + key + \"]\").append(el); },\n    <a href=\"#!/api/JW.AbstractMap.Inserter-cfg-removeItem\" rel=\"JW.AbstractMap.Inserter-cfg-removeItem\" class=\"docClass\">removeItem</a>: function(el, key) { el.detach(); },\n    <a href=\"#!/api/JW.AbstractMap.Inserter-cfg-scope\" rel=\"JW.AbstractMap.Inserter-cfg-scope\" class=\"docClass\">scope</a>: this\n});\n</code></pre>\n\n<p>Метод сам определит, какая реализация синхронизатора лучше подойдет (простая или observable).</p>\n\n<p>Правила работы синхронизатора:</p>\n\n<ul>\n<li>При конструировании синхронизатора для всех элементов исходной коллекции вызывается функция\n<a href=\"#!/api/JW.AbstractMap.Inserter-cfg-addItem\" rel=\"JW.AbstractMap.Inserter-cfg-addItem\" class=\"docClass\">addItem</a>.</li>\n<li>При уничтожении синхронизатора вызывается функция <a href=\"#!/api/JW.AbstractMap.Inserter-cfg-clearItems\" rel=\"JW.AbstractMap.Inserter-cfg-clearItems\" class=\"docClass\">clearItems</a>, либо для всех элементов\nвызывается функция <a href=\"#!/api/JW.AbstractMap.Inserter-cfg-removeItem\" rel=\"JW.AbstractMap.Inserter-cfg-removeItem\" class=\"docClass\">removeItem</a>.</li>\n<li>При изменении ключей/переиндексации элементов вызовами функций синхронизируется порядок элементов.</li>\n</ul>\n\n","title":"JW.AbstractMap.Inserter"});