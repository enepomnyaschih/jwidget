<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
	JW test case.
	
	Copyright (C) 2013 Egor Nepomnyaschih
	
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.
	
	You should have received a copy of the GNU Lesser General Public License
	along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

JW.Unit.TestCase = function(config) {
	JW.Unit.TestCase._super.call(this, config);
};

JW.extend(JW.Unit.TestCase, JW.Unit.TestGroup, {
	// override
	__build: function() {
		for (var name in this) {
			var test = JW.Unit.Test.getTest({
				__name        : name,
				__broadcaster : this.__broadcaster,
				__parent      : this
			});
			if (!test) {
				continue;
			}
			this.units.add(test);
		}
	},
	
	async: function(name, fn, timeout, callCount) {
		return JW.Unit._addHandler(name, fn, timeout, callCount);
	},
	
	forbid: function(name) {
		return JW.Unit._forbidHandler(name);
	},
	
	sleep: function(delay, fn, scope) {
		JW.Unit._sleep(delay, fn, scope);
	},
	
	addExpectedOutput: function(/* lines */) {
		this.addExpectedOutputArray(JW.toArray(arguments));
	},
	
	addExpectedOutputArray: function(lines) {
		JW.Unit._addExpectedOutput(lines);
	},
	
	setExpectedOutput: function(/* lines */) {
		this.setExpectedOutputArray(JW.toArray(arguments));
	},
	
	setExpectedOutputArray: function(lines) {
		JW.Unit._assertOutputFinish();
		JW.Unit._addExpectedOutput(lines);
	},
	
	assertOutputFinish: function() {
		JW.Unit._assertOutputFinish();
	},
	
	output: function(line) {
		JW.Unit._output(line);
	},
	
	fail: function(message) {
		throw new Error(message);
	},
	
	assert: function(value, message) {
		if (!value) {
			this.fail(message);
		}
	},
	
	assertTrue: function(value) {
		this.assert(value === true, &quot;true expected.&quot;);
	},
	
	assertFalse: function(value) {
		this.assert(value === false, &quot;false expected.&quot;);
	},
	
	assertEqual: function(expected, value) {
		if (expected != value) {
			this.fail(this._log(expected) + &quot; expected, &quot; + this._log(value) + &quot; got.&quot;);
		}
	},
	
	assertNotEqual: function(forbidden, value) {
		if (forbidden == value) {
			this.fail(this._log(forbidden) + &quot; is forbidden, but equal &quot; + this._log(value) + &quot; got.&quot;);
		}
	},
	
	assertStrictEqual: function(expected, value) {
		if (expected !== value) {
			this.fail(this._log(expected) + &quot; strictly expected, &quot; + this._log(value) + &quot; got.&quot;);
		}
	},
	
	assertStrictNotEqual: function(forbidden, value) {
		if (forbidden === value) {
			this.fail(this._log(forbidden) + &quot; is forbidden, but strict equal &quot; + this._log(value) + &quot; got.&quot;);
		}
	},
	
	assertDefined: function(value) {
		this.assert(JW.isDefined(value), &quot;defined value expected&quot;);
	},
	
	assertUndefined: function(value) {
		this.assert(!JW.isDefined(value), &quot;undefined value expected&quot;);
	},
	
	assertSet: function(value) {
		this.assert(JW.isSet(value), &quot;set value expected&quot;);
	},
	
	assertNotSet: function(value) {
		this.assert(!JW.isSet(value), &quot;not set value expected&quot;);
	},
	
	assertEpsEqual: function(expected, value, eps) {
		if (typeof value !== &quot;number&quot;) {
			this.fail(&quot;Number expected, &quot; + this._log(value) + &quot; (&quot; + (typeof value) + &quot;) got.&quot;);
		}
		if (expected - value &gt; eps) {
			this.fail(this._log(expected) + &quot; expected, &quot; + this._log(value) + &quot; got (eps = &quot; + this._log(eps) + &quot;).&quot;);
		}
	},
	
	load: function(url, dataType, callback, scope) {
		var onLoadSuccess = function(response) {
			return this._onLoadSuccess(response, callback, scope);
		};
		
		$.ajax({
			url      : url,
			data     : { _dc: new Date().getTime() },
			type     : &quot;GET&quot;,
			dataType : dataType,
			success  : this.async(&quot;_onLoadSuccess&quot;, onLoadSuccess),
			error    : this.forbid(&quot;_onLoadError&quot;),
			context  : this
		});
	},
	
	_onLoadSuccess: function(response, callback, scope) {
		callback.call(scope || this, response);
	},
	
	_log: function(value) {
		if ((typeof value === &quot;number&quot;) || (typeof value === &quot;boolean&quot;)) {
			return value.toString();
		}
		if (typeof value === &quot;string&quot;) {
			return JW.String.ellipsis(value, 60);
		}
		if (JW.isArray(value)) {
			return &quot;array&quot;;
		}
		return (typeof value);
	}
});

JW.Unit.TestCase.getCase = function(config) {
	if (config.__name.substr(config.__name.length - 8) != &quot;TestCase&quot;) {
		return null;
	}
	var cls = config.__parent.ns[config.__name];
	if (typeof cls !== &quot;function&quot;) {
		return null;
	}
	return new cls(config);
};
</pre>
</body>
</html>
