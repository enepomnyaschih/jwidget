<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*!
	jWidget Lib 0.6
	
	https://github.com/enepomnyaschih/jwidget/wiki
	
	Copyright (C) 2013 Egor Nepomnyaschih
	
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.
	
	You should have received a copy of the GNU Lesser General Public License
	along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

if (typeof JW !== &quot;undefined&quot;) {
	throw new Error(&quot;Can't initialize jWidget Lib: JW namespace already defined&quot;);
}

(typeof window === &quot;undefined&quot; ? global : window).JW = {};

<span id='JW'>/**
</span> * @class JW
 *
 * Основное пространство имен библиотеки jWidget.
 */

<span id='JW-static-property-global'>/**
</span> * @property {Object}
 *
 * Корневое пространство имен. Введено для обеспечения совместимости между JavaScript и NodeJS. Равно window в
 * браузерной среде и global в среде NodeJS.
 *
 * @static
 */
JW.global = (typeof window === &quot;undefined&quot; ? global : window);

<span id='JW-static-method-apply'>/**
</span> * По очереди перебирает объекты, переданные после первого аргумента, и копирует все их элементы (поля/методы) в объект
 * target, после чего возвращает объект target. Элементы объектов-источников, значения которых равны undefined, будут
 * проигнорированы. Пустые объекты-источники (undefined, null) будут проигнорированы.
 *
 * Функция меняет объект target!
 * 
 * Пример 1:
 * 
 *     var x = {         var y = {         // Результат = {
 *         a: 10,                          //     a: 10,
 *         b: 20,            b: 30,        //     b: 30,
 *         c: null,          c: 40,        //     c: 40,
 *         d: undefined,     d: 50,        //     d: 50,
 *         e: null                         //     e: null,
 *                           f: 60,        //     f: 60
 *                           g: undefined  // 
 *     };                };                // };
 *     
 *     JW.applyIf(x, y);
 * 
 * Пример 2 (построение данных формы):
 * 
 *     My.Form = JW.Class.extend({
 *         // Object data;
 *         
 *         composeData: function(extraData) {
 *             return JW.apply({}, this.getDefaultData(), this.data, extraData);
 *         },
 *         
 *         // virtual
 *         getDefaultData: function() {
 *             return null;
 *         }
 *     });
 *
 * @static
 *
 * @param {Object} target
 * Целевой объект.
 *
 * @param {Object} [sources]
 * Объекты-источники.
 *
 * @returns {Object}
 * Возвращает target.
 */
JW.apply = function(target /*, sources */) {
	for (var i = 1; i &lt; arguments.length; ++i) {
		var source = arguments[i];
		if (!source) {
			continue;
		}
		for (var key in source) {
			if (typeof source[key] !== &quot;undefined&quot;) {
				target[key] = source[key];
			}
		}
	}
	return target;
};

JW.apply(JW, {
<span id='JW-static-method-isUndefined'>	/**
</span>	 * Проверяет, является ли переменная undefined.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является undefined.
	 */
	isUndefined: function(v) {
		return v === undefined;
	},
	
<span id='JW-static-method-isDefined'>	/**
</span>	 * Проверяет, что переменная не undefined.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная не является undefined.
	 */
	isDefined: function(v) {
		return v !== undefined;
	},
	
<span id='JW-static-method-isNull'>	/**
</span>	 * Проверяет, является ли переменная null.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является null.
	 */
	isNull: function(v) {
		return v === null;
	},
	
<span id='JW-static-method-isNotNull'>	/**
</span>	 * Проверяет, что переменная не null.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная не является null.
	 */
	isNotNull: function(v) {
		return v !== null;
	},
	
<span id='JW-static-method-isSet'>	/**
</span>	 * Проверяет, что переменная не undefined и не null.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная не undefined и не null.
	 */
	isSet: function(v) {
		return (v !== undefined) &amp;&amp; (v !== null);
	},
	
<span id='JW-static-method-isNotSet'>	/**
</span>	 * Проверяет, что переменная undefined или null.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная undefined или null.
	 */
	isNotSet: function(v) {
		return (v === undefined) || (v === null);
	},
	
<span id='JW-static-method-isBlank'>	/**
</span>	 * Проверяет, что переменная пуста (`null`, `undefined`, `false`, 0 или пустая строка).
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная пуста.
	 */
	isBlank: function(v) {
		return !v;
	},
	
<span id='JW-static-method-isNotBlank'>	/**
</span>	 * Проверяет, что переменная не пуста (`null`, `undefined`, `false`, 0 или пустая строка).
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная не пуста.
	 */
	isNotBlank: function(v) {
		return Boolean(v);
	},
	
<span id='JW-static-method-isInt'>	/**
</span>	 * Проверяет, что переменная является целым числом.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является целым числом.
	 */
	isInt: function(v) {
		return (typeof v === &quot;number&quot;) &amp;&amp; Math.round(v) === v;
	},
	
<span id='JW-static-method-isNumber'>	/**
</span>	 * Проверяет, что переменная является числом.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является числом.
	 */
	isNumber: function(v) {
		return typeof v === &quot;number&quot;;
	},
	
<span id='JW-static-method-isString'>	/**
</span>	 * Проверяет, что переменная является строкой.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является строкой.
	 */
	isString: function(v) {
		return typeof v === &quot;string&quot;;
	},
	
<span id='JW-static-method-isBoolean'>	/**
</span>	 * Проверяет, что переменная булевая.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная булевая.
	 */
	isBoolean: function(v) {
		return typeof v === &quot;boolean&quot;;
	},
	
<span id='JW-static-method-isFunction'>	/**
</span>	 * Проверяет, что переменная является функцией.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является функцией.
	 */
	isFunction: function(v) {
		return typeof v === &quot;function&quot;;
	},
	
<span id='JW-static-method-isArray'>	/**
</span>	 * Проверяет, что переменная является нативным массивом (Array).
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является нативным массивом.
	 */
	isArray: function(v) {
		return Object.prototype.toString.apply(v) === '[object Array]';
	},
	
<span id='JW-static-method-isObject'>	/**
</span>	 * Проверяет, что переменная является объектом (Object или экземпляр пользовательского класса).
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является объектом.
	 */
	isObject: function(v) {
		return Object.prototype.toString.apply(v) === '[object Object]';
	},
	
<span id='JW-static-method-isRegExp'>	/**
</span>	 * Проверяет, что переменная является регулярным выражением.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является регулярным выражением.
	 */
	isRegExp: function(v) {
		return Object.prototype.toString.apply(v) === '[object RegExp]';
	},
	
<span id='JW-static-method-isDate'>	/**
</span>	 * Проверяет, что переменная является датой.
	 * @static
	 * @param {Mixed} x Переменная.
	 * @returns {boolean} Переменная является датой.
	 */
	isDate: function(v) {
		return Object.prototype.toString.apply(v) === '[object Date]';
	},
	
<span id='JW-static-method-def'>	/**
</span>	 * Задает значение по умолчанию. Возвращает value, если оно не undefined, в противном случае возвращает default.
	 * @static
	 * @param {Mixed} value Значение.
	 * @param {Mixed} default Значение по умолчанию.
	 * @returns {Mixed} Результат.
	 */
	def: function(v, d) {
		return JW.isDefined(v) ? v : d;
	},
	
<span id='JW-static-method-defn'>	/**
</span>	 * Задает значение по умолчанию. Возвращает value, если оно не undefined и не null, в противном случае возвращает
	 * default.
	 * @static
	 * @param {Mixed} value Значение.
	 * @param {Mixed} default Значение по умолчанию.
	 * @returns {Mixed} Результат.
	 */
	defn: function(v, d) {
		return JW.isSet(v) ? v : d;
	},
	
<span id='JW-static-method-applyIf'>	/**
</span>	 * То же самое, что и JW.apply, только игнорирует поля, которые уже определены в target (не undefined).
	 *
	 * Пример
	 * 
	 *     var x = {         var y = {         // Результат = {
	 *         a: 10,                          //     a: 10,
	 *         b: 20,            b: 30,        //     b: 20,
	 *         c: null,          c: 40,        //     c: null,
	 *         d: undefined      d: 50,        //     d: 50,
	 *                           e: 60,        //     e: 60
	 *                           f: undefined  // 
	 *     };                };                // };
	 *     
	 *     JW.applyIf(x, y);
	 *
	 * @static
	 *
	 * @param {Object} target
	 * Целевой объект.
	 *
	 * @param {Object} [sources]
	 * Объекты-источники.
	 *
	 * @returns {Object}
	 * Возвращает target.
	 */
	applyIf: function(target /*, sources */) {
		for (var i = 1; i &lt; arguments.length; ++i) {
			var source = arguments[i];
			if (!source) {
				continue;
			}
			for (var key in source) {
				if (JW.isDefined(source[key]) &amp;&amp; !JW.isDefined(target[key])) {
					target[key] = source[key];
				}
			}
		}
		return target;
	},
	
<span id='JW-static-method-applyIfn'>	/**
</span>	 * То же самое, что и JW.apply, только игнорирует поля, которые уже присвоены в target (не undefined или null).
	 *
	 * **Пример**
	 * 
	 *     var x = {         var y = {         // Результат = {
	 *         a: 10,                          //     a: 10,
	 *         b: 20,            b: 30,        //     b: 20,
	 *         c: null,          c: 40,        //     c: 40,
	 *         d: undefined      d: 50,        //     d: 50,
	 *                           e: 60,        //     e: 60
	 *                           f: undefined  // 
	 *     };                };                // };
	 *     
	 *     JW.applyIf(x, y);
	 *
	 * @static
	 *
	 * @param {Object} target
	 * Целевой объект.
	 *
	 * @param {Object} [sources]
	 * Объекты-источники.
	 *
	 * @returns {Object}
	 * Возвращает target.
	 */
	applyIfn: function(target /*, sources */) {
		for (var i = 1; i &lt; arguments.length; ++i) {
			var source = arguments[i];
			if (!source) {
				continue;
			}
			for (var key in source) {
				if (JW.isDefined(source[key]) &amp;&amp; !JW.isSet(target[key])) {
					target[key] = source[key];
				}
			}
		}
		return target;
	},
	
<span id='JW-static-method-clean'>	/**
</span>	 * Очищает словарь от значений undefined. Возвращает новый словарь, в котором есть все поля словаря target, кроме
	 * тех, что равны undefined.
	 * 
	 * Функция не меняет объект target.
	 * 
	 * Если вы хотите удалить еще и все значения равные null, воспользуйтесь функцией JW.cleann.
	 * 
	 * Пример:
	 * 
	 *     var x = {          // Результат: y = {
	 *         a : 10,        //     a: 10,
	 *         b : 20,        //     b: 20,
	 *         c : null,      //     c: null
	 *         d : undefined  //
	 *     };                 // };
	 *     
	 *     var y = JW.clean(x);
	 *
	 * @static
	 *
	 * @param {Object} target
	 * Словарь.
	 *
	 * @returns {Object}
	 * Очищенный словарь.
	 */
	clean: function(source) {
		var result = {};
		for (var i in source) {
			if (JW.isDefined(source[i])) {
				result[i] = source[i];
			}
		}
		return result;
	},
	
<span id='JW-static-method-cleann'>	/**
</span>	 * Очищает словарь от значений null и undefined. Возвращает новый словарь, в котором есть все поля словаря target,
	 * кроме тех, что равны null или undefined.
	 * 
	 * Функция не меняет объект target.
	 * 
	 * Если вы хотите удалить только undefined, воспользуйтесь функцией JW.clean.
	 * 
	 * Пример:
	 * 
	 *     var x = {          // Результат: y = {
	 *         a : 10,        //     a: 10,
	 *         b : 20,        //     b: 20
	 *         c : null,      //
	 *         d : undefined  //
	 *     };                 // };
	 *     
	 *     var y = JW.clean(x);
	 *
	 * @static
	 *
	 * @param {Object} target
	 * Словарь.
	 *
	 * @returns {Object}
	 * Очищенный словарь.
	 */
	cleann: function(source) {
		var result = {};
		for (var i in source) {
			if (JW.isSet(source[i])) {
				result[i] = source[i];
			}
		}
		return result;
	},
	
<span id='JW-static-method-toArray'>	/**
</span>	 * @method toArray
	 *
	 * Преобразует объект в массив. Объект должен иметь свойство length и элементы, пронумерованные от 0 до
	 * (length - 1).
	 * 
	 * Примером такого объекта является список аргументов функции. Это позволяет применять произвольные методы массива
	 * к списку аргументов.
	 * 
	 * Пример
	 * 
	 *     function applyOperations(
	 *         value
	 *         // operations
	 *         ) {
	 *         var operations = JW.toArray(arguments, 1);
	 *         // ...
	 *     }
	 *
	 * @static
	 *
	 * @param {Mixed} a
	 * Исходный объект.
	 *
	 * @param {number} [index]
	 * Номер аргумента, начиная с которого выполнить преобразование. По умолчанию, преобразует все аргументы.
	 *
	 * @param {number} [count]
	 * Количество аргументов для преобразования. По умолчанию, преобразует все аргументы, начиная с index.
	 *
	 * @returns {Array}
	 * Массив.
	 */
<span id='JW-static-method-args'>	/**
</span>	 * Эквивалент метода JW.toArray.
	 * @static
	 * @param {Mixed} a Исходный объект.
	 * @param {number} [index]
	 * Номер аргумента, начиная с которого выполнить преобразование. По умолчанию, преобразует все аргументы.
	 * @param {number} [count]
	 * Количество аргументов для преобразования. По умолчанию, преобразует все аргументы, начиная с index.
	 * @returns {Array} Массив.
	 */
	args: function(a, index, count) {
		index = index || 0;
		count = count || (a.length - index);
		var r = [];
		for (var i = 0; i &lt; count; ++i) {
			r.push(a[index + i]);
		}
		return r;
	},
	
<span id='JW-static-method-emptyFn'>	/**
</span>	 * Пустая функция.
	 * @static
	 * @returns {void}
	 */
	emptyFn: function() {},
	
<span id='JW-static-method-cmp'>	/**
</span>	 * Универсальная функция сравнения значений для сортировки массива.
	 * 
	 * - Возвращает 1, если x &gt; y
	 * - Возвращает -1, если x &lt; y
	 * - Возвращает 0, если x == y
	 * 
	 * Функция умеет сравнивать: boolean, number, string, Array.
	 *
	 * @static
	 * @param {Mixed} x Первое значение.
	 * @param {Mixed} y Второе значение.
	 * @param {boolean} caseInsensitive Не учитывать регистр.
	 * @returns {number} Результат сравнения.
	 */
	cmp: function(x, y, caseInsensitive) {
		if (typeof x === &quot;boolean&quot; &amp;&amp; typeof y === &quot;boolean&quot;) {
			return x ? (y ? 0 : 1) : (y ? -1 : 0);
		}
		if (JW.isArray(x) &amp;&amp; JW.isArray(y)) {
			return JW.Array.cmp(x, y, caseInsensitive);
		}
		if (caseInsensitive) {
			if (typeof x === &quot;string&quot;) {
				x = x.toLowerCase();
			}
			if (typeof y === &quot;string&quot;) {
				y = y.toLowerCase();
			}
		}
		if (x &gt; y) return 1;
		if (x &lt; y) return -1;
		return 0;
	},
	
<span id='JW-static-method-cmpCaseInsensitive'>	/**
</span>	 * Эквивалент JW.cmp(x, y, true). Сравнивает значения без учета регистра.
	 * @static
	 * @param {Mixed} x Первое значение.
	 * @param {Mixed} y Второе значение.
	 * @returns {number} Результат сравнения.
	 */
	cmpCaseInsensitive: function(x, y) {
		return JW.cmp(x, y, true);
	},
	
<span id='JW-static-method-get'>	/**
</span>	 * Возвращает элемент объекта по выражению. Выражение представляет собой несколько слов, записанных в массиве или в
	 * строке через точку. Если field равен null, undefined или пустой строке, то функция вернет obj.
	 * 
	 * Пример 1
	 * 
	 *     var obj = {
	 *         abc : [
	 *             {
	 *                 qwe : &quot;xyz&quot;
	 *             }
	 *         ]
	 *     };
	 *     
	 *     return JW.get(obj, &quot;abc.0.qwe&quot;); // &quot;xyz&quot;
	 *     
	 *     // эквивалентный вариант
	 *     return JW.get(obj, [ &quot;abc&quot;, 0, &quot;qwe&quot; ]); // &quot;xyz&quot;
	 * 
	 * Функция используется коллбеками JW.byField и JW.byValue.
	 * 
	 * Пример 2
	 * 
	 *     var arr = [
	 *         {
	 *             id   : 1,
	 *             name : &quot;First item&quot;
	 *         }, {
	 *             id   : 2,
	 *             name : &quot;Second item&quot;
	 *         }
	 *     ];
	 *     
	 *     return JW.Array.search(arr, JW.byValue(&quot;id&quot;, 2)).name; // &quot;Second item&quot;
	 * 
	 * В данном примере функция JW.get неявно вызывается внутри метода JW.byValue с аргументом field === &quot;id&quot;.
	 *
	 * @static
	 * @param {Object} obj Объект.
	 * @param {string/Array} field Название элемента объекта. Набор слов массивом или строкой через точку.
	 * @param {Mixed} def Значение, которое вернется, если элемент не найден. По умолчанию undefined.
	 * @returns {Mixed} Элемент объекта.
	 */
	get: function(obj, field, def) {
		if (!field) {
			return JW.def(obj, def);
		}
		if (typeof field === &quot;string&quot;) {
			field = field.split(&quot;.&quot;);
		}
		field = JW.Array.filter(field, function(token) {
			return JW.isSet(token) &amp;&amp; (token !== &quot;&quot;);
		});
		for (var i = 0, l = field.length; i &lt; l; ++i) {
			if (!obj) {
				return def;
			}
			obj = obj[field[i]];
		}
		return JW.def(obj, def);
	},
	
<span id='JW-static-method-set'>	/**
</span>	 * Присваивает элемент объекта по выражению. Выражение представляет собой несколько слов, записанных в массиве или
	 * в строке через точку.
	 * 
	 * Пример:
	 * 
	 *     var obj = {
	 *         abc : [
	 *             {
	 *                 qwe : &quot;xyz&quot;
	 *             }
	 *         ]
	 *     };
	 *     
	 *     return JW.set(obj, &quot;def&quot;, &quot;abc.0.qwe&quot;); // заменит значение &quot;xyz&quot; на &quot;def&quot;
	 *     
	 *     // эквивалентный вариант
	 *     return JW.set(obj, &quot;def&quot;, [ &quot;abc&quot;, 0, &quot;qwe&quot; ]); // заменит значение &quot;xyz&quot; на &quot;def&quot;
	 *
	 * @static
	 * @param {Object} obj Объект.
	 * @param {Mixed} value Значение.
	 * @param {string/Array} field Название элемента объекта. Набор слов массивом или строкой через точку.
	 * @returns {void}
	 */
	set: function(obj, value, field) {
		if (!field) {
			return;
		}
		if (typeof field === &quot;string&quot;) {
			field = field.split(&quot;.&quot;);
		}
		field = JW.Array.filter(field, function(token) {
			return JW.isSet(token) &amp;&amp; (token !== &quot;&quot;);
		});
		for (var i = 0, l = field.length - 1; i &lt; l; ++i) {
			token = field[i];
			obj[token] = obj[token] || {};
			obj = obj[token];
		}
		obj[JW.Array.getLast(field)] = value;
	},
	
<span id='JW-static-method-iid'>	/**
</span>	 * Возвращает уникальный идентификатор объекта. Вернет {@link JW.Class#_iid iid} объекта, если он является
	 * экземпляром JW.Class, в противном случае вернет сам объект.
	 *
	 * Эта функция является значением о умолчанию для полей JW.AbstractArray#getKey и JW.AbstractMap#getKey, а также
	 * для параметра getKey статических методов JW.Array#static-method-detectSplice,
	 * JW.Array#static-method-performSplice, JW.Array#static-method-detectReorder,
	 * JW.Array#static-method-performReorder, JW.Map#static-method-detectReindex,
	 * JW.Map#static-method-performReindex.
	 *
	 * @static
	 * @param {Object} obj Объект.
	 * @returns {Mixed} Уникальный идентификатор объекта.
	 */
	iid: function(obj) {
		return (typeof obj === &quot;object&quot;) ? obj._iid : obj;
	},
	
	
<span id='JW-static-method-destroy'>	/**
</span>	 * Уничтожает объект, вызвав его метод {@link JW.Class#destroy destroy}. Удобно использовать в конфигурации конвертеров:
	 * 
	 *     var mapper = collection.createMapper({
	 *         createItem  : function(data) { return new View(data); },
	 *         destroyItem : JW.destroy, // вместо function(view) { view.destroy(); }
	 *         scope       : this
	 *     });
	 *
	 * @static
	 * @param {Object} obj Объект.
	 * @returns {void}
	 */
	destroy: function(obj) {
		obj.destroy();
	},
	
<span id='JW-static-method-mod'>	/**
</span>	 * Берет значение value по модулю mod. Функция работает корректно для любого вещественного value и положительного
	 * вещественного mod. Возвращает значение в полуинтервале [0, mod).
	 * @static
	 * @param {number} value Значение.
	 * @param {number} mod Модуль.
	 * @returns {number} value по модулю mod.
	 */
	mod: function(value, mod) {
		return value - mod * Math.floor(value / mod);
	},
	
<span id='JW-static-method-smod'>	/**
</span>	 * Берет значение value по модулю mod. Функция работает корректно для любого вещественного value и положительного
	 * вещественного mod. Возвращает значение в полуинтервале [-mod/2, mod/2).
	 * @static
	 * @param {number} value Значение.
	 * @param {number} mod Модуль.
	 * @returns {number} value по модулю mod.
	 */
	smod: function(value, mod) {
		return value - mod * Math.round(value / mod);
	},
	
<span id='JW-static-method-sgn'>	/**
</span>	 * Возвращает знак числа `value`: 0, 1 или -1.
	 * @static
	 * @param {number} value Значение.
	 * @returns {number} Знак.
	 */
	sgn: function(value) {
		return !value ? 0 : value &gt; 0 ? 1 : -1;
	},
	
<span id='JW-static-method-sgnnz'>	/**
</span>	 * Возвращает ненулевой знак числа `value`: 1 или -1. Для нуля вернет 1.
	 * @static
	 * @param {number} value Значение.
	 * @returns {number} Знак.
	 */
	sgnnz: function(value) {
		return value &gt;= 0 ? 1 : -1;
	},
	
<span id='JW-static-method-inScope'>	/**
</span>	 * Закрепляет контекст вызова функции.
	 * 
	 * **Пример**
	 * 
	 *     setTimeout(JW.inScope(this.onTimeout, this), 1000);
	 * 
	 * **Эквивалентная реализация**
	 * 
	 *     var self = this;
	 *     setTimeout(function() {
	 *         self.onTimeout();
	 *     }, 1000);
	 * 
	 * Контекст методов класса удобно закреплять в конструкторе до вызова конструктора базового класса:
	 * 
	 *     var MyClass = function(el, message) {
	 *         this._onClick = JW.inScope(this._onClick, this);
	 *         MyClass._super.call(this);
	 *         this.el = el;
	 *         this.message = message;
	 *         this.el.bind(&quot;click&quot;, this._onClick);
	 *     };
	 *     
	 *     JW.extend(MyClass, JW.Class, {
	 *         // Element el;
	 *         // String message;
	 *         
	 *         // override
	 *         destroy: function() {
	 *             this.el.unbind(&quot;click&quot;, this._onClick);
	 *         },
	 *         
	 *         _onClick: function() {
	 *             alert(this.message);
	 *         }
	 *     });
	 *
	 * @static
	 * @param {Function} fn Функция.
	 * @param {Object} scope Контекст вызова функции.
	 * @returns {Function} Функция с закрепленным контекстом.
	 */
	inScope: function(func, scope) {
		return function() {
			return func.apply(scope, arguments);
		};
	},
	
<span id='JW-static-method-byField'>	/**
</span>	 * Возвращает коллбек-функцию для алгоритмов коллекций. Функция возвращает значение указанного поля
	 * элемента коллекции. Поле элемента извлекается с помощью функции JW.get.
	 *
	 * Пример (получить имена всех элементов коллекции):
	 *
	 *     var titles = collection.$map(JW.byField(&quot;title&quot;));
	 *
	 * @static
	 * @param {string} field Имя поля элемента коллекции.
	 * @returns {Function} Коллбек-функция.
	 */
	byField: function(field) {
		return function(item) {
			return JW.get(item, field);
		};
	},
	
<span id='JW-static-method-byValue'>	/**
</span>	 * Возвращает коллбек-функцию для алгоритмов коллекций. Функция проверяет, равно ли (===) указанное поле элемента
	 * коллекции указанному значению. Поле элемента извлекается с помощью функции JW.get.
	 *
	 * Пример (найти элемент по id):
	 *
	 *     var item = collection.$search(JW.byValue(&quot;id&quot;, id));
	 *
	 * @static
	 * @param {string} field Имя поля элемента коллекции.
	 * @param {Mixed} value Значение поля.
	 * @returns {Function} Коллбек-функция.
	 */
	byValue: function(field, value) {
		return function(item) {
			return JW.get(item, field) === value;
		};
	},
	
<span id='JW-static-method-byMethod'>	/**
</span>	 * Возвращает коллбек-функцию для алгоритмов коллекций. Функция проверяет, возвращает ли указанный метод
	 * элемента с указанными аргументами не false (!==).
	 *
	 * Пример (отфильтровать задачи, относящиеся к указанной задаче):
	 *
	 *     var tasks = collection.$filter(JW.byMethod(&quot;relatesTo&quot;, [task]));
	 *
	 * @static
	 * @param {string} method Имя метода элемента коллекции.
	 * @param {Array} [args] Аргументы метода.
	 * @returns {Function} Коллбек-функция.
	 */
	byMethod: function(method, args) {
		args = args || [];
		return function(item) {
			return item[method].apply(item, args);
		};
	}
});

JW.toArray = JW.args;
</pre>
</body>
</html>
