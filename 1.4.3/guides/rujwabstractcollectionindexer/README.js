Ext.data.JsonP.rujwabstractcollectionindexer({"guide":"<h1 id='rujwabstractcollectionindexer-section-jw.abstractcollection.indexer'>JW.AbstractCollection.Indexer</h1>\n\n<p>Это краткое описание класса на русском языке.</p>\n\n<p>Полная документация на английском: <a href=\"#!/api/JW.AbstractCollection.Indexer\" rel=\"JW.AbstractCollection.Indexer\" class=\"docClass\">JW.AbstractCollection.Indexer</a></p>\n\n<p><code>&lt;T, C extends <a href=\"#!/api/JW.AbstractCollection\" rel=\"JW.AbstractCollection\" class=\"docClass\">JW.AbstractCollection</a>&lt;T&gt;&gt;</code></p>\n\n<p>Индексатор коллекции. Преобразует исходную коллекцию в словарь, присваивая каждому элементу определенный ключ,\nиспользуя функцию, указанную пользователем. Используется для быстрого поиска элементов по ключу (например, по ID).\nЕсли исходная коллекция наблюдаемая (observable), начинает непрерывную синхронизацию.</p>\n\n<pre><code>var array = new <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>([{id: 9, label: \"The item\"}]);\nvar indexer = array.<a href=\"#!/api/JW.ObservableArray-method-createIndexer\" rel=\"JW.ObservableArray-method-createIndexer\" class=\"docClass\">createIndexer</a>({\n    <a href=\"#!/api/JW.AbstractCollection.Indexer-cfg-getKey\" rel=\"JW.AbstractCollection.Indexer-cfg-getKey\" class=\"docClass\">getKey</a>: function(item) { return item.id; },\n    <a href=\"#!/api/JW.AbstractCollection.Indexer-cfg-scope\" rel=\"JW.AbstractCollection.Indexer-cfg-scope\" class=\"docClass\">scope</a>: this\n});\nvar map = indexer.<a href=\"#!/api/JW.AbstractCollection.Indexer-property-target\" rel=\"JW.AbstractCollection.Indexer-property-target\" class=\"docClass\">target</a>;\n\n// Получаем элемент с ID = 9\nassert(map.<a href=\"#!/api/JW.AbstractMap-method-get\" rel=\"JW.AbstractMap-method-get\" class=\"docClass\">get</a>(9).label === \"The item\");\nassert(map.<a href=\"#!/api/JW.AbstractMap-method-get\" rel=\"JW.AbstractMap-method-get\" class=\"docClass\">get</a>(5) == null);\n\n// Целевой словарь автоматически синхронизируется с исходной наблюдаемой коллекцией\narray.add({id: 5, label: \"New item\"});\nassert(map.<a href=\"#!/api/JW.AbstractMap-method-get\" rel=\"JW.AbstractMap-method-get\" class=\"docClass\">get</a>(5).label === \"New item\");\n\nindexer.<a href=\"#!/api/JW.AbstractCollection.Indexer-method-destroy\" rel=\"JW.AbstractCollection.Indexer-method-destroy\" class=\"docClass\">destroy</a>();\n</code></pre>\n\n<p><strong>Замечание:</strong> Все элементы должны иметь различные (уникальные) ключи.</p>\n\n<p>Создавайте синхронизатор с помощью метода <a href=\"#!/api/JW.AbstractCollection-method-createIndexer\" rel=\"JW.AbstractCollection-method-createIndexer\" class=\"docClass\">JW.AbstractCollection.createIndexer</a>.\nМетод сам определит, какая реализация синхронизатора лучше подойдет (простая или observable).</p>\n\n<p>Словарь можно передать в качестве конфигурационной опции:</p>\n\n<pre><code>var map = new <a href=\"#!/api/JW.Map\" rel=\"JW.Map\" class=\"docClass\">JW.Map</a>();\nvar indexer = collection.<a href=\"#!/api/JW.AbstractCollection-method-createIndexer\" rel=\"JW.AbstractCollection-method-createIndexer\" class=\"docClass\">createIndexer</a>({\n    <a href=\"#!/api/JW.AbstractCollection.Indexer-cfg-target\" rel=\"JW.AbstractCollection.Indexer-cfg-target\" class=\"docClass\">target</a>: map,\n    <a href=\"#!/api/JW.AbstractCollection.Indexer-cfg-getKey\" rel=\"JW.AbstractCollection.Indexer-cfg-getKey\" class=\"docClass\">getKey</a>: function(item) { return item.id; },\n    <a href=\"#!/api/JW.AbstractCollection.Indexer-cfg-scope\" rel=\"JW.AbstractCollection.Indexer-cfg-scope\" class=\"docClass\">scope</a>: this\n});\n</code></pre>\n\n<p>В простых случаях, вы можете использовать упрощенный метод <a href=\"#!/api/JW.AbstractCollection-method-S-S-index\" rel=\"JW.AbstractCollection-method-S-S-index\" class=\"docClass\">JW.AbstractCollection.$$index</a>. Он сразу возвращает целевой словарь:</p>\n\n<pre><code>var array = new <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>([{id: 9, label: \"The item\"}]);\nvar map = array.<a href=\"#!/api/JW.ObservableArray-method-S-S-index\" rel=\"JW.ObservableArray-method-S-S-index\" class=\"docClass\">$$index</a>(function(item) { return item.id; });\n\n// Получаем элемент с ID = 9\nassert(map.<a href=\"#!/api/JW.AbstractMap-method-get\" rel=\"JW.AbstractMap-method-get\" class=\"docClass\">get</a>(9).label === \"The item\");\nassert(map.<a href=\"#!/api/JW.AbstractMap-method-get\" rel=\"JW.AbstractMap-method-get\" class=\"docClass\">get</a>(5) == null);\n\n// Целевой словарь автоматически синхронизируется с исходным наблюдаемым словарем\narray.add({id: 5, label: \"New item\"});\nassert(map.<a href=\"#!/api/JW.AbstractMap-method-get\" rel=\"JW.AbstractMap-method-get\" class=\"docClass\">get</a>(5).label === \"New item\");\n\nmap.<a href=\"#!/api/JW.AbstractMap-method-destroy\" rel=\"JW.AbstractMap-method-destroy\" class=\"docClass\">destroy</a>();\n</code></pre>\n\n<p>Правила работы синхронизатора:</p>\n\n<ul>\n<li>Целевой словарь находится в поле <a href=\"#!/api/JW.AbstractCollection.Indexer-property-target\" rel=\"JW.AbstractCollection.Indexer-property-target\" class=\"docClass\">target</a>.</li>\n<li>При конструировании синхронизатора все элементы исходной коллекции сразу добавляются в <a href=\"#!/api/JW.AbstractCollection.Indexer-property-target\" rel=\"JW.AbstractCollection.Indexer-property-target\" class=\"docClass\">target</a>.</li>\n<li>При уничтожении синхронизатора все элементы исходной коллекции удаляются из <a href=\"#!/api/JW.AbstractCollection.Indexer-property-target\" rel=\"JW.AbstractCollection.Indexer-property-target\" class=\"docClass\">target</a>.</li>\n<li>Словарь можно передать в качестве конфигурационной опции <a href=\"#!/api/JW.AbstractCollection.Indexer-cfg-target\" rel=\"JW.AbstractCollection.Indexer-cfg-target\" class=\"docClass\">target</a>.\nВ этом случае, вся забота о его уничтожении ложится на вас.</li>\n<li>Если <a href=\"#!/api/JW.AbstractCollection.Indexer-cfg-target\" rel=\"JW.AbstractCollection.Indexer-cfg-target\" class=\"docClass\">target</a> не передан, то он будет создан автоматически. Синхронизатор подберет наиболее подходящую\nреализацию <a href=\"#!/api/JW.AbstractCollection.Indexer-property-target\" rel=\"JW.AbstractCollection.Indexer-property-target\" class=\"docClass\">target</a> (простая или observable). В этом\nслучае, <a href=\"#!/api/JW.AbstractCollection.Indexer-property-target\" rel=\"JW.AbstractCollection.Indexer-property-target\" class=\"docClass\">target</a> будет уничтожен автоматически при уничтожении синхронизатора.</li>\n<li>Можно индексировать несколько коллекций в один и тот же словарь, если ключи всех элементов различны.</li>\n</ul>\n\n","title":"JW.AbstractCollection.Indexer"});