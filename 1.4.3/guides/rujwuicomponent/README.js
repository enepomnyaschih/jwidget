Ext.data.JsonP.rujwuicomponent({"guide":"<h1 id='rujwuicomponent-section-jw.ui.component'>JW.UI.Component</h1>\n\n<p>Это краткое описание класса на русском языке.</p>\n\n<p>Полная документация на английском: <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a></p>\n\n<p>Базовый класс UI компонента.</p>\n\n<p>Возможности:</p>\n\n<ul>\n<li>Рендеринг по HTML шаблону</li>\n<li>Прямой доступ к элементам компонента</li>\n<li><a href=\"http://api.jquery.com/\">jQuery-интерфейс</a> для работы с элементами</li>\n<li>Удобный API для работы с дочерними компонентами</li>\n</ul>\n\n\n<p>У jWidget очень простой интерфейс, но весьма необычная философия, которая гарантирует соответствие архитектуре\nModel-View без больших усилий. Начнем с примеров.</p>\n\n<h3 id='rujwuicomponent-section-%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80-ui-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0-jwidget'>Пример UI компонента jWidget</h3>\n\n<pre><code>// Объявляем пространство имен\nvar MyApp = {};\n\n// Объявляем конструктор компонента\nMyApp.Component = function(message, link) {\n    MyApp.Component.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.message = message;\n    this.link = link;\n};\n\n// Наследуемся от <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyApp.Component, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // String message;\n    // String link;\n\n    // override\n    <a href=\"#!/api/JW.UI.Component-method-afterRender\" rel=\"JW.UI.Component-method-afterRender\" class=\"docClass\">afterRender</a>: function() {\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"hello-message\").text(this.message);\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"link\").attr(\"href\", this.link);\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyApp.Component, {\n    main:\n        '&lt;div jwclass=\"myapp-component\"&gt;' +\n            '&lt;div jwid=\"hello-message\"&gt;&lt;/div&gt;' +\n            '&lt;a href=\"#\" jwid=\"link\"&gt;Click me!&lt;/a&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p>Рассмотрим, как это работает. У каждого компонента есть главный шаблон, который передается в функцию\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a> с именем <code>main</code> и по умолчанию равен\n<code>&lt;div&gt;&lt;/div&gt;</code>. Вы можете добавить и другие шаблоны, они будут доступны в поле компонента\n<code><a href=\"#!/api/JW.UI.Component-property-templates\" rel=\"JW.UI.Component-property-templates\" class=\"docClass\">this.templates</a>.&lt;template_name&gt;</code> (но они используются очень редко).\nПодкласс наследует шаблоны базового класса.</p>\n\n<p>Обратите внимание на специальные атрибуты <code>jwclass</code> и <code>jwid</code>. <code>jwclass</code> - это корневой CSS-класс компонента,\n<code>jwid</code> - это суффикс к <code>jwclass</code> в данном элементе. Так, в результате рендеринга этого компонента мы получим\nследующий фрагмент HTML:</p>\n\n<pre><code>&lt;div class=\"myapp-component\"&gt;\n    &lt;div class=\"myapp-component-hello-message\"&gt;&lt;/div&gt;\n    &lt;a href=\"#\" class=\"myapp-component-link\"&gt;Click me!&lt;/a&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Вы можете получить элемент по его <code>jwid</code>, используя метод <a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>. В результате вызова этого метода вы получите\n<a href=\"http://api.jquery.com/\">jQuery-обертку</a> над этим элементом. У корневого элемента <code>jwid</code> равен \"root\".\nКроме того, у компонента есть поле <a href=\"#!/api/JW.UI.Component-property-el\" rel=\"JW.UI.Component-property-el\" class=\"docClass\">el</a>, которое ссылается на корневой jQuery-элемент компонента.</p>\n\n<h3 id='rujwuicomponent-section-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0-%D0%B2-%D0%BA%D0%BE%D0%B4%D0%B5'>Создание компонента в коде</h3>\n\n<p>Компонент может быть создан простым конструированием. После этого, вы можете использовать метод <a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>\nили <a href=\"#!/api/JW.UI.Component-method-renderAs\" rel=\"JW.UI.Component-method-renderAs\" class=\"docClass\">renderAs</a>, чтобы вставить этот компонент в DOM.</p>\n\n<pre><code>var component;\n\njQuery(function() {\n    component = new MyApp.Component(\"Hello world!\", \"http://google.com\");\n    component.<a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>(\"body\");\n});\n</code></pre>\n\n<h3 id='rujwuicomponent-section-%D0%94%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B'>Дочерние компоненты</h3>\n\n<p>Есть 5 способов добавить дочерний компонент:</p>\n\n<ul>\n<li>Добавить компонент в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> с ключом, равным <code>jwid</code> элемента, который вы хотите заменить дочерним\nкомпонентом. Обычно, это делается в методе <a href=\"#!/api/JW.UI.Component-method-afterRender\" rel=\"JW.UI.Component-method-afterRender\" class=\"docClass\">afterRender</a>.</li>\n<li>Добавить легко заменяемый дочерний компонент, используя метод <a href=\"#!/api/JW.UI.Component-method-addReplaceable\" rel=\"JW.UI.Component-method-addReplaceable\" class=\"docClass\">addReplaceable</a>. Передайте туда <a href=\"#!/guide/rujwproperty\">JW.Property</a> и фреймворк\nобеспечит непрерывную синхронизацию с этим свойством во время работы приложения.</li>\n<li>Добавить массив дочерних компонентов в один из элементов с помощью метода <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>. Если переданный массив\nявляется <a href=\"#!/api/JW.ObservableArray\" rel=\"JW.ObservableArray\" class=\"docClass\">JW.ObservableArray</a>, то фреймворк обеспечит непрерывную синхронизацию с этим массивом во время\nработы приложения.</li>\n<li>Добавить коллекцию дочерних компонентов в один из элементов с помощью метода\n<a href=\"#!/api/JW.UI.Component-method-addCollection\" rel=\"JW.UI.Component-method-addCollection\" class=\"docClass\">addCollection</a>. В отличие от метода <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>,\n<a href=\"#!/api/JW.UI.Component-method-addCollection\" rel=\"JW.UI.Component-method-addCollection\" class=\"docClass\">addCollection</a> не сохраняет порядок дочерних компонентов.\nКаждый новый добавленный компонент всегда добавляется в конец. Если переданная коллекция\nявляется прослушиваемой (observable), то фреймворк обеспечит непрерывную синхронизацию с этой коллекцией во время\nработы приложения.</li>\n<li>Определить метод <code>render&lt;ChildId&gt;</code>, где <code>&lt;ChildId&gt;</code> - это <code>jwid</code> элемента,\nзаписанный в CamelCase с заглавной буквы. Пример: <code>renderArticle</code> (рендерит элемент <code>jwid=\"article\"</code>).\nЕсли метод возвращает <a href=\"#!/guide/rujwuicomponent\">JW.UI.Component</a>, <a href=\"#!/guide/rujwproperty\">JW.Property</a> или <a href=\"#!/guide/rujwabstractcollection\">JW.AbstractCollection</a>, то результат будет трактоваться как дочерний компонент\nили коллекция дочерних компонентов. Определите метод <code>renderRoot</code> для рендеринга корневого элемента, но вы сможете\nвернуть там только <a href=\"#!/guide/rujwabstractcollection\">JW.AbstractCollection</a>. Смотрите параграф <strong>Подробнее о методе render&lt;ChildId&gt;</strong> для деталей.</li>\n</ul>\n\n\n<p>Такой интерфейс с одной стороны прост, с другой стороны гибок в плане следования архитектуре Model-View.</p>\n\n<p><a href=\"#!/guide/rusample1\">Учебник. Часть 1. Модель и представление</a></p>\n\n<h3 id='rujwuicomponent-section-%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5-%D0%BE-%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%D1%85-%D0%B4%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D1%85-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2'>Подробнее о коллекциях дочерних компонентов</h3>\n\n<p>Для создания коллекций UI компонентов на основе коллекций данных удобно использовать метод\n<a href=\"#!/api/JW.AbstractCollection-method-S-S-mapObjects\" rel=\"JW.AbstractCollection-method-S-S-mapObjects\" class=\"docClass\">$$mapObjects</a>.\nБлагодаря ему, представление будет автоматически обновляться при изменении данных.</p>\n\n<p>По этой же причине рекомендуем использовать коллекции jWidget в реализации классов модели вместо нативных\nJavaScript Array и Object: у коллекций jWidget есть Observable-реализации, и они могут синхронизироваться друг с другом.</p>\n\n<p><a href=\"#!/guide/rusample6\">Учебник. Часть 6. Синхронизаторы коллекций</a></p>\n\n<h3 id='rujwuicomponent-section-%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5-%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B5-render%26lt%3Bchildid%26gt%3B'>Подробнее о методе render&lt;ChildId&gt;</h3>\n\n<p>Вы можете определить метод <code>render&lt;ChildId&gt;</code> для всех элементов HTML шаблона, у которых есть атрибут <code>jwid</code>.\n<code>&lt;ChildId&gt;</code> равен этому <code>jwid</code>, записанному в CamelCase с большой буквы. Сигнатура метода:</p>\n\n<p><code>renderChildId(el: <a href=\"http://api.jquery.com/\">jQuery</a>): Mixed</code></p>\n\n<p><code>el</code> - элемент с соответствующим <code>jwid</code>.</p>\n\n<p>В зависимости от того, какой результат возвращает этот метод, есть следующие варианты:</p>\n\n<ul>\n<li>Если метод возвращает <a href=\"#!/guide/rujwuicomponent\">JW.UI.Component</a>, то он будет добавлен в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a> и станет дочерним компонентом. Не работает для корневого элемента.</li>\n<li>Если метод возвращает <a href=\"#!/guide/rujwproperty\">JW.Property</a>, то он будет добавлен как легко заменяемый дочерний компонент методом <a href=\"#!/api/JW.UI.Component-method-addReplaceable\" rel=\"JW.UI.Component-method-addReplaceable\" class=\"docClass\">addReplaceable</a>. Не работает для корневого элемента.</li>\n<li>Если метод возвращает <a href=\"#!/guide/rujwabstractarray\">JW.AbstractArray</a>, то он будет добавлен как массив дочерних компонентов методом <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>.</li>\n<li>Если метод возвращает <a href=\"#!/guide/rujwabstractcollection\">JW.AbstractCollection</a> (не являющаяся <a href=\"#!/guide/rujwabstractarray\">JW.AbstractArray</a>), то она будет добавлена как коллекция дочерних компонентов методом <a href=\"#!/api/JW.UI.Component-method-addCollection\" rel=\"JW.UI.Component-method-addCollection\" class=\"docClass\">addCollection</a>.</li>\n<li>Если метод возвращает <code>false</code> (===), то элемент будет удален из HTML компонента. Не работает для корневого элемента.</li>\n<li>В противном случае, фреймворк не выполнит никаких дополнительных действий по инициализации элемента.</li>\n</ul>\n\n\n<h3 id='rujwuicomponent-section-%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2'>Удаление и уничтожение компонентов</h3>\n\n<p>Вы можете уничтожать компоненты методом <a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>. Тем не менее, вы не можете уничтожить\nкомпонент, который был добавлен в другой в качестве дочернего (в этом случае, фреймворк выбросит исключение).\nВы должны сначала удалить дочерний компонент из родителя. Чтобы это сделать, вам нужно выполнить операцию,\nобратную операции добавления.</p>\n\n<ul>\n<li>Если вы добавили компонент в объект <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>, то вам нужно удалить его оттуда\nметодом <a href=\"#!/api/JW.AbstractMap-method-remove\" rel=\"JW.AbstractMap-method-remove\" class=\"docClass\">remove</a>.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-addReplaceable\" rel=\"JW.UI.Component-method-addReplaceable\" class=\"docClass\">addReplaceable</a> возвращает экземпляр класса <a href=\"#!/api/JW.UI.Component.Replaceable\" rel=\"JW.UI.Component.Replaceable\" class=\"docClass\">JW.UI.Component.Replaceable</a>.\nЕго уничтожение влечет удаление заменяемого дочернего компонента.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a> возвращает экземпляр класса <a href=\"#!/api/JW.UI.Component.Array\" rel=\"JW.UI.Component.Array\" class=\"docClass\">JW.UI.Component.Array</a>.\nЕго уничтожение влечет удаление массива дочерних компонентов.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-addCollection\" rel=\"JW.UI.Component-method-addCollection\" class=\"docClass\">addCollection</a> возвращает экземпляр класса <a href=\"#!/api/JW.UI.Component.Collection\" rel=\"JW.UI.Component.Collection\" class=\"docClass\">JW.UI.Component.Collection</a>.\nЕго уничтожение влечет удаление коллекции дочерних компонентов.</li>\n</ul>\n\n\n<p>Как только дочерний компонент удален, вы можете уничтожить его:</p>\n\n<pre><code>this.<a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>.<a href=\"#!/api/JW.AbstractMap-method-remove\" rel=\"JW.AbstractMap-method-remove\" class=\"docClass\">remove</a>(\"comments\").<a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>();\n</code></pre>\n\n<p>Другой пример:</p>\n\n<pre><code>// следует вызывать не ранее начала рендеринга компонента\ninitLabels: function() {\n    this._labelViews = this.labels.<a href=\"#!/api/JW.AbstractArray-method-S-S-mapObjects\" rel=\"JW.AbstractArray-method-S-S-mapObjects\" class=\"docClass\">$$mapObjects</a>(function(label) {\n        return new LabelView(label);\n    }, this);\n    // Добавляем метки в элемент с jwid=\"labels\"\n    this._labelArray = this.<a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>(this._labelViews, \"labels\");\n},\n\nclearLabels: function() {\n    this._labelArray.<a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>();\n    this._labelArray = null;\n    this._labelViews.<a href=\"#!/api/JW.Class-method-destroy\" rel=\"JW.Class-method-destroy\" class=\"docClass\">destroy</a>();\n    this._labelViews = null;\n}\n</code></pre>\n\n<p>Вам не нужно каждый раз явно удалять дочерние компоненты. При уничтожении родителя, фреймворк автоматически\nудаляет все дочерние компоненты непосредственно перед вызовом метода <a href=\"#!/api/JW.UI.Component-method-unrender\" rel=\"JW.UI.Component-method-unrender\" class=\"docClass\">unrender</a>.\nТем не менее, он не уничтожает их. Вы можете воспользоваться методом агрегации объектов <a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>,\nчтобы их уничтожить. Так что в большинстве случаев ваш код будет выглядеть очень просто:</p>\n\n<pre><code>renderTitleBox: function() {\n    return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(new TitleBox());\n},\n\nrenderLabels: function() {\n    return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.labels.<a href=\"#!/api/JW.AbstractArray-method-S-S-mapObjects\" rel=\"JW.AbstractArray-method-S-S-mapObjects\" class=\"docClass\">$$mapObjects</a>(function(label) {\n        return new LabelView(label);\n    }, this));\n}\n</code></pre>\n\n<h3 id='rujwuicomponent-section-%D0%9E%D0%B1%D1%89%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-%D0%B4%D0%BE%D1%87%D0%B5%D1%80%D0%BD%D0%B8%D0%BC%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8'>Общие практики работы с дочерними компонентами</h3>\n\n<p><strong>Создание дочернего компонента</strong></p>\n\n<p>Этот пример описывает, как создается и уничтожается дочерний компонент с <code>jwid=\"title-box\"</code>.</p>\n\n<pre><code>var MyComponent = function() {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    renderTitleBox: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(new TitleBox());\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"title-box\"&gt;&lt;/div&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p><strong>Создание заменяемого дочернего компонента</strong></p>\n\n<p>Этот пример описывает, как создается легко заменяемый дочерний компонент с <code>jwid=\"document\"</code>.\nПредположим, что у вас есть свойство \"document\", и вы хотите заменять старое представление документа новым при смене\nзначения этого свойства.</p>\n\n<pre><code>var MyComponent = function(document) {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.document = document;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // <a href=\"#!/api/JW.Property\" rel=\"JW.Property\" class=\"docClass\">JW.Property</a>&lt;Document&gt; document;\n\n    renderDocument: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.document.<a href=\"#!/api/JW.Property-method-S-S-mapObject\" rel=\"JW.Property-method-S-S-mapObject\" class=\"docClass\">$$mapObject</a>(function(document) {\n            return new DocumentView(document);\n        }, this));\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"document\"&gt;&lt;/div&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p><strong>Создание коллекции дочерних компонентов</strong></p>\n\n<p>Этот пример описывает, как дочерние компоненты создаются и уничтожаются на основе коллекции данных, и\nкак они добавляются внутрь элемента с <code>jwid=\"labels\"</code>. Если коллекция данных наблюдаемая (observable),\nто коллекция дочерних компонентов будет непрерывно синхронизироваться с данными.</p>\n\n<pre><code>var MyComponent = function(labels) {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.labels = labels;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // <a href=\"#!/api/JW.AbstractArray\" rel=\"JW.AbstractArray\" class=\"docClass\">JW.AbstractArray</a>&lt;Label&gt; labels;\n\n    renderLabels: function() {\n        return this.<a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>(this.labels.<a href=\"#!/api/JW.AbstractArray-method-S-S-mapObjects\" rel=\"JW.AbstractArray-method-S-S-mapObjects\" class=\"docClass\">$$mapObjects</a>(function(label) {\n            return new LabelView(label);\n        }, this));\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"labels\"&gt;&lt;/div&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<p><strong>Добавление существующих компонентов в качестве дочерних</strong></p>\n\n<p>Этот пример описывает, как добавить дочерние компоненты, которые созданы кем-то другим и, следовательно,\nне должны быть уничтожены здесь автоматически. Здесь, \"titleBox\" может быть <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>,\n<a href=\"#!/guide/rujwproperty\">JW.Property</a>&lt;<a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>> или <a href=\"#!/guide/rujwabstractcollection\">JW.AbstractCollection</a>&lt;<a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>>.</p>\n\n<pre><code>var MyComponent = function(titleBox) {\n    MyComponent.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.titleBox = titleBox;\n};\n\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyComponent, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // Mixed titleBox;\n\n    renderTitleBox: function() {\n        return this.titleBox;\n    }\n});\n\n<a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>(MyComponent, {\n    main:\n        '&lt;div jwclass=\"my-component\"&gt;' +\n            '&lt;div jwid=\"title-box\"&gt;&lt;/div&gt;' +\n        '&lt;/div&gt;'\n});\n</code></pre>\n\n<h3 id='rujwuicomponent-section-%D0%AD%D1%82%D0%B0%D0%BF%D1%8B-%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0'>Этапы жизни компонента</h3>\n\n<p>Каждый компонент проходит несколько этапов жизненного цикла.</p>\n\n<ol>\n<li>Как и у всех остальных классов, сначала вызывается <strong>конструктор</strong>. Обычно здесь объявляются все поля и присваиваются\nих изначальные значения, создаются события и т.д. Здесь затрагивается только модель компонента, представление\nполностью игнорируется. Обратите внимание, что компонент после конструирования еще не отрендерен, так что у него\nеще нет полей <a href=\"#!/api/JW.UI.Component-property-el\" rel=\"JW.UI.Component-property-el\" class=\"docClass\">el</a> и <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>, а\nметоды <a href=\"#!/api/JW.UI.Component-method-addArray\" rel=\"JW.UI.Component-method-addArray\" class=\"docClass\">addArray</a>, <a href=\"#!/api/JW.UI.Component-method-addCollection\" rel=\"JW.UI.Component-method-addCollection\" class=\"docClass\">addCollection</a> и\n<a href=\"#!/api/JW.UI.Component-method-addReplaceable\" rel=\"JW.UI.Component-method-addReplaceable\" class=\"docClass\">addReplaceable</a> не будут работать. Смысл этого в том, чтобы дать вам возможность\nсделать что-то еще между конструированием и рендерингом компонента, например, изменить значения каких-то полей и\nвызвать какие-то методы. Вторая причина: вообще, во всех объектно-ориентированных языках программирования не\nрекомендуется вызывать виртуальные методы внутри конструктора. Вы можете отрендерить компонент напрямую вызовом\nметода <a href=\"#!/api/JW.UI.Component-method-render\" rel=\"JW.UI.Component-method-render\" class=\"docClass\">render</a>, <a href=\"#!/api/JW.UI.Component-method-renderTo\" rel=\"JW.UI.Component-method-renderTo\" class=\"docClass\">renderTo</a>,\n<a href=\"#!/api/JW.UI.Component-method-renderAs\" rel=\"JW.UI.Component-method-renderAs\" class=\"docClass\">renderAs</a>, или неявно путем добавления этого компонента в другой компонент в качестве\nдочернего. Например, компонент будет сразу же отрендерен, если его добавить в словарь <a href=\"#!/api/JW.UI.Component-property-children\" rel=\"JW.UI.Component-property-children\" class=\"docClass\">children</a>. Вы можете\nинициировать рендеринг компонента несколько раз, но отрендерен он будет лишь при первой попытке.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-beforeRender\" rel=\"JW.UI.Component-method-beforeRender\" class=\"docClass\">beforeRender</a> вызывается во время рендеринга компонента, после чтения HTML шаблона и инициализации всех ссылок\nна элементы шаблона. Здесь удобно выполнять какие-либо предварительные действия перед созданием дочерних компонентов.\nНо вы уже имеете право создавать здесь дочерние компоненты. Вызов <code>this._super()</code> выполняется в первой\nстроке метода.</li>\n<li>Методы <code>render&lt;ChildId&gt;</code> вызываются для всех элементов HTML шаблона, т.е. выполняется\nсоздание дочерних компонентов.</li>\n<li>Вызывается метод <a href=\"#!/api/JW.UI.Component-method-afterRender\" rel=\"JW.UI.Component-method-afterRender\" class=\"docClass\">afterRender</a>. Здесь следует присваивать атрибуты элементов, создавать дочерние компоненты,\nподписываться на события и наполнять компонент поведением, если вы не захотели этого делать на предыдущем шаге.\nЗдесь заканчивается рендеринг компонента. Вызов <code>this._super()</code> выполняется в первой строке метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-afterAppend\" rel=\"JW.UI.Component-method-afterAppend\" class=\"docClass\">afterAppend</a> вызывается после первого появления компонента в HTML DOM и дереве UI компонентов.\nЗдесь следует выполнять лайаутинг компонента (вычислять размеры элементов).\nВызов <code>this._super()</code> выполняется в первой строке метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-releaseDom\" rel=\"JW.UI.Component-method-releaseDom\" class=\"docClass\">releaseDom</a> вызывается при уничтожении компонента. Здесь откатывается все, что было сделано в методе <a href=\"#!/api/JW.UI.Component-method-afterAppend\" rel=\"JW.UI.Component-method-afterAppend\" class=\"docClass\">afterAppend</a>,\nт.е. на шаге 5. Вызов <code>this._super()</code> выполняется в последней строке метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-unrender\" rel=\"JW.UI.Component-method-unrender\" class=\"docClass\">unrender</a> вызывается при уничтожении компонента. Здесь откатывается все, что было сделано во\nвремя рендеринга компонента, т.е. на шагах 2-4. Фреймворк уже удалил все дочерние компоненты перед вызовом этого\nметода, но сами компоненты еще не уничтожены. Вы должны уничтожить их явно, если вы не заагрегировали их\nметодом <a href=\"#!/api/JW.Class-method-own\" rel=\"JW.Class-method-own\" class=\"docClass\">own</a>.\nВызов <code>this._super()</code> выполняется в последней строке метода.</li>\n<li>Метод <a href=\"#!/api/JW.UI.Component-method-afterDestroy\" rel=\"JW.UI.Component-method-afterDestroy\" class=\"docClass\">afterDestroy</a> вызывается при уничтожении компонента. Здесь откатывается все, что было сделано в\nконструкторе компонента, т.е. на первом шаге.\nВызов <code>this._super()</code> выполняется в последней строке метода.</li>\n</ol>\n\n\n<h3 id='rujwuicomponent-section-%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%81-jwidget-sdk'>Интеграция с jWidget SDK</h3>\n\n<p>Библиотека jWidget UI идеально интегрирована с <a href=\"https://github.com/enepomnyaschih/jwsdk/wiki/ru\">jWidget SDK</a>, что\nдает вам хорошую оптимизацию JS-кода прямо из коробки, а также возможность выносить HTML шаблоны в отдельные файлы.\nНапример, вы можете упростить самый первый пример, разбив его на 2 файла:</p>\n\n<p><strong>component.js</strong></p>\n\n<pre><code>// Объявляем пространство имен\nvar MyApp = {};\n\n// Объявляем конструктор компонента\nMyApp.Component = function(message, link) {\n    MyApp.Component.<a href=\"#!/api/JW.Class-static-property-_super\" rel=\"JW.Class-static-property-_super\" class=\"docClass\">_super</a>.call(this);\n    this.message = message;\n    this.link = link;\n};\n\n// Наследуемся от <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>\n<a href=\"#!/api/JW-static-method-extend\" rel=\"JW-static-method-extend\" class=\"docClass\">JW.extend</a>(MyApp.Component, <a href=\"#!/api/JW.UI.Component\" rel=\"JW.UI.Component\" class=\"docClass\">JW.UI.Component</a>, {\n    // String message;\n    // String link;\n\n    // override\n    <a href=\"#!/api/JW.UI.Component-method-afterRender\" rel=\"JW.UI.Component-method-afterRender\" class=\"docClass\">afterRender</a>: function() {\n        this.<a href=\"#!/api/JW.Class-method-_super\" rel=\"JW.Class-method-_super\" class=\"docClass\">_super</a>();\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"hello-message\").text(this.message);\n        this.<a href=\"#!/api/JW.UI.Component-method-getElement\" rel=\"JW.UI.Component-method-getElement\" class=\"docClass\">getElement</a>(\"link\").attr(\"href\", this.link);\n    }\n});\n</code></pre>\n\n<p><strong>component.jw.html</strong></p>\n\n<pre><code>&lt;div jwclass=\"myapp-component\"&gt;\n    &lt;div jwid=\"hello-message\"&gt;&lt;/div&gt;\n    &lt;a href=\"#\" jwid=\"link\"&gt;Click me!&lt;/a&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Чтобы это работало, вам нужно просто зарегистрировать следующие ресурсы в соответствующем пакете jWidget SDK:</p>\n\n<pre><code>{\n    \"resources\" : [\n        \"component.js\",\n        \"component.jw.html : MyApp.Component\",\n        ...\n    ]\n}\n</code></pre>\n\n<p>Конечно, вы можете использовать jWidget и без jWidget SDK, но в таком случае вам потребуется либо загружать\nHTML шаблоны динамически, либо объявлять их явно прямо в JavaScript коде, используя функцию <a href=\"#!/api/JW.UI-static-method-template\" rel=\"JW.UI-static-method-template\" class=\"docClass\">JW.UI.template</a>.</p>\n\n<p>Ищите дополнительные примеры по использованию jWidget SDK в учебнике:</p>\n\n<p><a href=\"#!/guide/rusample7\">Учебник. Часть 7. Инфраструктура проекта</a></p>\n\n<h3 id='rujwuicomponent-section-%D0%A1%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C-clear-div'>Сохранность clear-div</h3>\n\n<p>Начиная с jWidget 1.4, вы можете рендерить коллекции дочерних компонентов в непустые DOM элементы. В этом случае,\nвсе существующие узлы останутся в конце элемента. Наиболее частое приложение для\nэтого - <a href=\"https://css-tricks.com/the-how-and-why-of-clearing-floats/\" target=\"_blank\">использование clear-div</a>.</p>\n\n<iframe style=\"border: 1px solid green; padding: 10px;\" width=\"600\" height=\"260\" src=\"http://enepomnyaschih.github.io/mt/1.4/jwui-clear-div.html\"></iframe>\n\n","title":"JW.UI.Component"});